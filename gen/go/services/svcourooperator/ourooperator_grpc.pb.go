// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             (unknown)
// source: services/svcourooperator/ourooperator.proto

package svcourooperator

import (
	context "context"
	acquisition "github.com/cybroslabs/ouro-api-shared/gen/go/acquisition"
	system "github.com/cybroslabs/ouro-api-shared/gen/go/system"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	OuroOperatorService_ListDrivers_FullMethodName                = "/io.clbs.openhes.services.svcourooperator.OuroOperatorService/ListDrivers"
	OuroOperatorService_SetDriver_FullMethodName                  = "/io.clbs.openhes.services.svcourooperator.OuroOperatorService/SetDriver"
	OuroOperatorService_GetDriver_FullMethodName                  = "/io.clbs.openhes.services.svcourooperator.OuroOperatorService/GetDriver"
	OuroOperatorService_SetDriverScale_FullMethodName             = "/io.clbs.openhes.services.svcourooperator.OuroOperatorService/SetDriverScale"
	OuroOperatorService_GetDriverScale_FullMethodName             = "/io.clbs.openhes.services.svcourooperator.OuroOperatorService/GetDriverScale"
	OuroOperatorService_GetApplicationConfig_FullMethodName       = "/io.clbs.openhes.services.svcourooperator.OuroOperatorService/GetApplicationConfig"
	OuroOperatorService_UpdateApplicationConfig_FullMethodName    = "/io.clbs.openhes.services.svcourooperator.OuroOperatorService/UpdateApplicationConfig"
	OuroOperatorService_SynchronizeComponentConfig_FullMethodName = "/io.clbs.openhes.services.svcourooperator.OuroOperatorService/SynchronizeComponentConfig"
	OuroOperatorService_StartUpgrade_FullMethodName               = "/io.clbs.openhes.services.svcourooperator.OuroOperatorService/StartUpgrade"
	OuroOperatorService_GetLicense_FullMethodName                 = "/io.clbs.openhes.services.svcourooperator.OuroOperatorService/GetLicense"
	OuroOperatorService_GetLicenseRequestCode_FullMethodName      = "/io.clbs.openhes.services.svcourooperator.OuroOperatorService/GetLicenseRequestCode"
	OuroOperatorService_SetLicense_FullMethodName                 = "/io.clbs.openhes.services.svcourooperator.OuroOperatorService/SetLicense"
	OuroOperatorService_GetSbom_FullMethodName                    = "/io.clbs.openhes.services.svcourooperator.OuroOperatorService/GetSbom"
)

// OuroOperatorServiceClient is the client API for OuroOperatorService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Defines a specification for the Ouro Operator service.
// The Ouro Operator manages the Kubernetes infrastructure for the Ouro platform, handling driver lifecycle, scaling, configuration, licensing, and system upgrades.
type OuroOperatorServiceClient interface {
	// Retrieves a complete list of all registered drivers. Returns driver metadata including versions, capabilities, connection templates, and action definitions.
	ListDrivers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*acquisition.ListOfDriver, error)
	// Creates or updates a driver template. This method allows administrators to define or modify driver configurations that determine how driver instances are deployed in the Kubernetes cluster.
	SetDriver(ctx context.Context, in *acquisition.Driver, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Retrieves the template configuration of the specified driver including its deployment specifications, resource requirements, and connection templates.
	GetDriver(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*acquisition.Driver, error)
	// Sets the number of replicas (instances) for a specific driver type. This controls horizontal scaling of driver pods in the Kubernetes cluster to handle varying workloads.
	SetDriverScale(ctx context.Context, in *acquisition.SetDriverScaleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Retrieves the current number of replicas for the specified driver type, indicating how many instances are currently deployed.
	GetDriverScale(ctx context.Context, in *acquisition.GetDriverScaleRequest, opts ...grpc.CallOption) (*wrapperspb.UInt32Value, error)
	// Retrieves the current application configuration including all component-specific settings and their descriptors. Returns both the configuration values and their field definitions.
	GetApplicationConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*system.ApplicationConfigDescriptor, error)
	// Updates the application configuration. Only the fields provided in the request are modified; omitted fields retain their current values. This allows partial configuration updates without affecting other settings.
	UpdateApplicationConfig(ctx context.Context, in *system.ApplicationConfig, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Synchronizes component-specific configuration with the system. Components should provide all their default values and known configuration keys (including null values). The method merges defaults with existing values and removes any settings not declared in the defaults. Returns the current effective configuration for the component.
	SynchronizeComponentConfig(ctx context.Context, in *system.ComponentConfigDescriptor, opts ...grpc.CallOption) (*system.ComponentConfig, error)
	// Initiates a driver upgrade process. Starts a driver in upgrade mode as a Kubernetes job to perform schema migrations and data structure upgrades between driver versions. The upgrade job is coordinated by the DeviceRegistry and automatically terminates after completion.
	StartUpgrade(ctx context.Context, in *acquisition.StartUpgradeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Retrieves the currently installed license information including expiration date, feature flags, and capacity limits.
	GetLicense(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*system.License, error)
	// Retrieves the license request code for the system. This code is used to generate a license for air-gapped installations. Returns an empty string if a valid license is already installed.
	GetLicenseRequestCode(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.StringValue, error)
	// Installs a new license key. This method is intended for air-gapped installations where the license cannot be activated through online channels. The license key must be obtained from Cybroslabs using the license request code.
	SetLicense(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// @group: System
	// Retrieves the software bill of materials (SBOM) information in CycloneDX JSON format. This provides a comprehensive inventory of all software components and their dependencies used by the Ouro Operator service.
	GetSbom(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.StringValue, error)
}

type ouroOperatorServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewOuroOperatorServiceClient(cc grpc.ClientConnInterface) OuroOperatorServiceClient {
	return &ouroOperatorServiceClient{cc}
}

func (c *ouroOperatorServiceClient) ListDrivers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*acquisition.ListOfDriver, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(acquisition.ListOfDriver)
	err := c.cc.Invoke(ctx, OuroOperatorService_ListDrivers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ouroOperatorServiceClient) SetDriver(ctx context.Context, in *acquisition.Driver, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, OuroOperatorService_SetDriver_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ouroOperatorServiceClient) GetDriver(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*acquisition.Driver, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(acquisition.Driver)
	err := c.cc.Invoke(ctx, OuroOperatorService_GetDriver_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ouroOperatorServiceClient) SetDriverScale(ctx context.Context, in *acquisition.SetDriverScaleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, OuroOperatorService_SetDriverScale_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ouroOperatorServiceClient) GetDriverScale(ctx context.Context, in *acquisition.GetDriverScaleRequest, opts ...grpc.CallOption) (*wrapperspb.UInt32Value, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(wrapperspb.UInt32Value)
	err := c.cc.Invoke(ctx, OuroOperatorService_GetDriverScale_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ouroOperatorServiceClient) GetApplicationConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*system.ApplicationConfigDescriptor, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(system.ApplicationConfigDescriptor)
	err := c.cc.Invoke(ctx, OuroOperatorService_GetApplicationConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ouroOperatorServiceClient) UpdateApplicationConfig(ctx context.Context, in *system.ApplicationConfig, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, OuroOperatorService_UpdateApplicationConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ouroOperatorServiceClient) SynchronizeComponentConfig(ctx context.Context, in *system.ComponentConfigDescriptor, opts ...grpc.CallOption) (*system.ComponentConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(system.ComponentConfig)
	err := c.cc.Invoke(ctx, OuroOperatorService_SynchronizeComponentConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ouroOperatorServiceClient) StartUpgrade(ctx context.Context, in *acquisition.StartUpgradeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, OuroOperatorService_StartUpgrade_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ouroOperatorServiceClient) GetLicense(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*system.License, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(system.License)
	err := c.cc.Invoke(ctx, OuroOperatorService_GetLicense_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ouroOperatorServiceClient) GetLicenseRequestCode(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.StringValue, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(wrapperspb.StringValue)
	err := c.cc.Invoke(ctx, OuroOperatorService_GetLicenseRequestCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ouroOperatorServiceClient) SetLicense(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, OuroOperatorService_SetLicense_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ouroOperatorServiceClient) GetSbom(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.StringValue, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(wrapperspb.StringValue)
	err := c.cc.Invoke(ctx, OuroOperatorService_GetSbom_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OuroOperatorServiceServer is the server API for OuroOperatorService service.
// All implementations must embed UnimplementedOuroOperatorServiceServer
// for forward compatibility.
//
// Defines a specification for the Ouro Operator service.
// The Ouro Operator manages the Kubernetes infrastructure for the Ouro platform, handling driver lifecycle, scaling, configuration, licensing, and system upgrades.
type OuroOperatorServiceServer interface {
	// Retrieves a complete list of all registered drivers. Returns driver metadata including versions, capabilities, connection templates, and action definitions.
	ListDrivers(context.Context, *emptypb.Empty) (*acquisition.ListOfDriver, error)
	// Creates or updates a driver template. This method allows administrators to define or modify driver configurations that determine how driver instances are deployed in the Kubernetes cluster.
	SetDriver(context.Context, *acquisition.Driver) (*emptypb.Empty, error)
	// Retrieves the template configuration of the specified driver including its deployment specifications, resource requirements, and connection templates.
	GetDriver(context.Context, *wrapperspb.StringValue) (*acquisition.Driver, error)
	// Sets the number of replicas (instances) for a specific driver type. This controls horizontal scaling of driver pods in the Kubernetes cluster to handle varying workloads.
	SetDriverScale(context.Context, *acquisition.SetDriverScaleRequest) (*emptypb.Empty, error)
	// Retrieves the current number of replicas for the specified driver type, indicating how many instances are currently deployed.
	GetDriverScale(context.Context, *acquisition.GetDriverScaleRequest) (*wrapperspb.UInt32Value, error)
	// Retrieves the current application configuration including all component-specific settings and their descriptors. Returns both the configuration values and their field definitions.
	GetApplicationConfig(context.Context, *emptypb.Empty) (*system.ApplicationConfigDescriptor, error)
	// Updates the application configuration. Only the fields provided in the request are modified; omitted fields retain their current values. This allows partial configuration updates without affecting other settings.
	UpdateApplicationConfig(context.Context, *system.ApplicationConfig) (*emptypb.Empty, error)
	// Synchronizes component-specific configuration with the system. Components should provide all their default values and known configuration keys (including null values). The method merges defaults with existing values and removes any settings not declared in the defaults. Returns the current effective configuration for the component.
	SynchronizeComponentConfig(context.Context, *system.ComponentConfigDescriptor) (*system.ComponentConfig, error)
	// Initiates a driver upgrade process. Starts a driver in upgrade mode as a Kubernetes job to perform schema migrations and data structure upgrades between driver versions. The upgrade job is coordinated by the DeviceRegistry and automatically terminates after completion.
	StartUpgrade(context.Context, *acquisition.StartUpgradeRequest) (*emptypb.Empty, error)
	// Retrieves the currently installed license information including expiration date, feature flags, and capacity limits.
	GetLicense(context.Context, *emptypb.Empty) (*system.License, error)
	// Retrieves the license request code for the system. This code is used to generate a license for air-gapped installations. Returns an empty string if a valid license is already installed.
	GetLicenseRequestCode(context.Context, *emptypb.Empty) (*wrapperspb.StringValue, error)
	// Installs a new license key. This method is intended for air-gapped installations where the license cannot be activated through online channels. The license key must be obtained from Cybroslabs using the license request code.
	SetLicense(context.Context, *wrapperspb.StringValue) (*emptypb.Empty, error)
	// @group: System
	// Retrieves the software bill of materials (SBOM) information in CycloneDX JSON format. This provides a comprehensive inventory of all software components and their dependencies used by the Ouro Operator service.
	GetSbom(context.Context, *emptypb.Empty) (*wrapperspb.StringValue, error)
	mustEmbedUnimplementedOuroOperatorServiceServer()
}

// UnimplementedOuroOperatorServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedOuroOperatorServiceServer struct{}

func (UnimplementedOuroOperatorServiceServer) ListDrivers(context.Context, *emptypb.Empty) (*acquisition.ListOfDriver, error) {
	return nil, status.Error(codes.Unimplemented, "method ListDrivers not implemented")
}
func (UnimplementedOuroOperatorServiceServer) SetDriver(context.Context, *acquisition.Driver) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method SetDriver not implemented")
}
func (UnimplementedOuroOperatorServiceServer) GetDriver(context.Context, *wrapperspb.StringValue) (*acquisition.Driver, error) {
	return nil, status.Error(codes.Unimplemented, "method GetDriver not implemented")
}
func (UnimplementedOuroOperatorServiceServer) SetDriverScale(context.Context, *acquisition.SetDriverScaleRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method SetDriverScale not implemented")
}
func (UnimplementedOuroOperatorServiceServer) GetDriverScale(context.Context, *acquisition.GetDriverScaleRequest) (*wrapperspb.UInt32Value, error) {
	return nil, status.Error(codes.Unimplemented, "method GetDriverScale not implemented")
}
func (UnimplementedOuroOperatorServiceServer) GetApplicationConfig(context.Context, *emptypb.Empty) (*system.ApplicationConfigDescriptor, error) {
	return nil, status.Error(codes.Unimplemented, "method GetApplicationConfig not implemented")
}
func (UnimplementedOuroOperatorServiceServer) UpdateApplicationConfig(context.Context, *system.ApplicationConfig) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateApplicationConfig not implemented")
}
func (UnimplementedOuroOperatorServiceServer) SynchronizeComponentConfig(context.Context, *system.ComponentConfigDescriptor) (*system.ComponentConfig, error) {
	return nil, status.Error(codes.Unimplemented, "method SynchronizeComponentConfig not implemented")
}
func (UnimplementedOuroOperatorServiceServer) StartUpgrade(context.Context, *acquisition.StartUpgradeRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method StartUpgrade not implemented")
}
func (UnimplementedOuroOperatorServiceServer) GetLicense(context.Context, *emptypb.Empty) (*system.License, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLicense not implemented")
}
func (UnimplementedOuroOperatorServiceServer) GetLicenseRequestCode(context.Context, *emptypb.Empty) (*wrapperspb.StringValue, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLicenseRequestCode not implemented")
}
func (UnimplementedOuroOperatorServiceServer) SetLicense(context.Context, *wrapperspb.StringValue) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method SetLicense not implemented")
}
func (UnimplementedOuroOperatorServiceServer) GetSbom(context.Context, *emptypb.Empty) (*wrapperspb.StringValue, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSbom not implemented")
}
func (UnimplementedOuroOperatorServiceServer) mustEmbedUnimplementedOuroOperatorServiceServer() {}
func (UnimplementedOuroOperatorServiceServer) testEmbeddedByValue()                             {}

// UnsafeOuroOperatorServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OuroOperatorServiceServer will
// result in compilation errors.
type UnsafeOuroOperatorServiceServer interface {
	mustEmbedUnimplementedOuroOperatorServiceServer()
}

func RegisterOuroOperatorServiceServer(s grpc.ServiceRegistrar, srv OuroOperatorServiceServer) {
	// If the following call panics, it indicates UnimplementedOuroOperatorServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&OuroOperatorService_ServiceDesc, srv)
}

func _OuroOperatorService_ListDrivers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OuroOperatorServiceServer).ListDrivers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OuroOperatorService_ListDrivers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OuroOperatorServiceServer).ListDrivers(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _OuroOperatorService_SetDriver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(acquisition.Driver)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OuroOperatorServiceServer).SetDriver(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OuroOperatorService_SetDriver_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OuroOperatorServiceServer).SetDriver(ctx, req.(*acquisition.Driver))
	}
	return interceptor(ctx, in, info, handler)
}

func _OuroOperatorService_GetDriver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OuroOperatorServiceServer).GetDriver(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OuroOperatorService_GetDriver_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OuroOperatorServiceServer).GetDriver(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _OuroOperatorService_SetDriverScale_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(acquisition.SetDriverScaleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OuroOperatorServiceServer).SetDriverScale(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OuroOperatorService_SetDriverScale_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OuroOperatorServiceServer).SetDriverScale(ctx, req.(*acquisition.SetDriverScaleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OuroOperatorService_GetDriverScale_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(acquisition.GetDriverScaleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OuroOperatorServiceServer).GetDriverScale(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OuroOperatorService_GetDriverScale_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OuroOperatorServiceServer).GetDriverScale(ctx, req.(*acquisition.GetDriverScaleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OuroOperatorService_GetApplicationConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OuroOperatorServiceServer).GetApplicationConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OuroOperatorService_GetApplicationConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OuroOperatorServiceServer).GetApplicationConfig(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _OuroOperatorService_UpdateApplicationConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(system.ApplicationConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OuroOperatorServiceServer).UpdateApplicationConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OuroOperatorService_UpdateApplicationConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OuroOperatorServiceServer).UpdateApplicationConfig(ctx, req.(*system.ApplicationConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _OuroOperatorService_SynchronizeComponentConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(system.ComponentConfigDescriptor)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OuroOperatorServiceServer).SynchronizeComponentConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OuroOperatorService_SynchronizeComponentConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OuroOperatorServiceServer).SynchronizeComponentConfig(ctx, req.(*system.ComponentConfigDescriptor))
	}
	return interceptor(ctx, in, info, handler)
}

func _OuroOperatorService_StartUpgrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(acquisition.StartUpgradeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OuroOperatorServiceServer).StartUpgrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OuroOperatorService_StartUpgrade_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OuroOperatorServiceServer).StartUpgrade(ctx, req.(*acquisition.StartUpgradeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OuroOperatorService_GetLicense_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OuroOperatorServiceServer).GetLicense(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OuroOperatorService_GetLicense_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OuroOperatorServiceServer).GetLicense(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _OuroOperatorService_GetLicenseRequestCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OuroOperatorServiceServer).GetLicenseRequestCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OuroOperatorService_GetLicenseRequestCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OuroOperatorServiceServer).GetLicenseRequestCode(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _OuroOperatorService_SetLicense_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OuroOperatorServiceServer).SetLicense(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OuroOperatorService_SetLicense_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OuroOperatorServiceServer).SetLicense(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _OuroOperatorService_GetSbom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OuroOperatorServiceServer).GetSbom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OuroOperatorService_GetSbom_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OuroOperatorServiceServer).GetSbom(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// OuroOperatorService_ServiceDesc is the grpc.ServiceDesc for OuroOperatorService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OuroOperatorService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "io.clbs.openhes.services.svcourooperator.OuroOperatorService",
	HandlerType: (*OuroOperatorServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListDrivers",
			Handler:    _OuroOperatorService_ListDrivers_Handler,
		},
		{
			MethodName: "SetDriver",
			Handler:    _OuroOperatorService_SetDriver_Handler,
		},
		{
			MethodName: "GetDriver",
			Handler:    _OuroOperatorService_GetDriver_Handler,
		},
		{
			MethodName: "SetDriverScale",
			Handler:    _OuroOperatorService_SetDriverScale_Handler,
		},
		{
			MethodName: "GetDriverScale",
			Handler:    _OuroOperatorService_GetDriverScale_Handler,
		},
		{
			MethodName: "GetApplicationConfig",
			Handler:    _OuroOperatorService_GetApplicationConfig_Handler,
		},
		{
			MethodName: "UpdateApplicationConfig",
			Handler:    _OuroOperatorService_UpdateApplicationConfig_Handler,
		},
		{
			MethodName: "SynchronizeComponentConfig",
			Handler:    _OuroOperatorService_SynchronizeComponentConfig_Handler,
		},
		{
			MethodName: "StartUpgrade",
			Handler:    _OuroOperatorService_StartUpgrade_Handler,
		},
		{
			MethodName: "GetLicense",
			Handler:    _OuroOperatorService_GetLicense_Handler,
		},
		{
			MethodName: "GetLicenseRequestCode",
			Handler:    _OuroOperatorService_GetLicenseRequestCode_Handler,
		},
		{
			MethodName: "SetLicense",
			Handler:    _OuroOperatorService_SetLicense_Handler,
		},
		{
			MethodName: "GetSbom",
			Handler:    _OuroOperatorService_GetSbom_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services/svcourooperator/ourooperator.proto",
}
