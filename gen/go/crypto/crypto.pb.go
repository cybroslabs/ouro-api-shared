// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: crypto/crypto.proto

package crypto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Defines the supported DLMS authenticated encryption modes.
type AuthenticatedEncryption int32

const (
	AuthenticatedEncryption_AE_UNSPECIFIED AuthenticatedEncryption = 0 // No authenticated encryption.
	AuthenticatedEncryption_AE_AES_GCM_128 AuthenticatedEncryption = 1 // AES-GCM with 128-bit key.
	AuthenticatedEncryption_AE_AES_GCM_256 AuthenticatedEncryption = 2 // AES-GCM with 256-bit key.
)

// Enum value maps for AuthenticatedEncryption.
var (
	AuthenticatedEncryption_name = map[int32]string{
		0: "AE_UNSPECIFIED",
		1: "AE_AES_GCM_128",
		2: "AE_AES_GCM_256",
	}
	AuthenticatedEncryption_value = map[string]int32{
		"AE_UNSPECIFIED": 0,
		"AE_AES_GCM_128": 1,
		"AE_AES_GCM_256": 2,
	}
)

func (x AuthenticatedEncryption) Enum() *AuthenticatedEncryption {
	p := new(AuthenticatedEncryption)
	*p = x
	return p
}

func (x AuthenticatedEncryption) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AuthenticatedEncryption) Descriptor() protoreflect.EnumDescriptor {
	return file_crypto_crypto_proto_enumTypes[0].Descriptor()
}

func (AuthenticatedEncryption) Type() protoreflect.EnumType {
	return &file_crypto_crypto_proto_enumTypes[0]
}

func (x AuthenticatedEncryption) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Defines the supported digital signature algorithms.
type DigitalSignature int32

const (
	DigitalSignature_DS_ECDSA_UNSPECIFIED DigitalSignature = 0 // No digital signature.
	DigitalSignature_DS_ECDSA_P_256       DigitalSignature = 1 // ECDSA using the NIST P-256 curve.
	DigitalSignature_DS_ECDSA_P_384       DigitalSignature = 2 // ECDSA using the NIST P-384 curve.
)

// Enum value maps for DigitalSignature.
var (
	DigitalSignature_name = map[int32]string{
		0: "DS_ECDSA_UNSPECIFIED",
		1: "DS_ECDSA_P_256",
		2: "DS_ECDSA_P_384",
	}
	DigitalSignature_value = map[string]int32{
		"DS_ECDSA_UNSPECIFIED": 0,
		"DS_ECDSA_P_256":       1,
		"DS_ECDSA_P_384":       2,
	}
)

func (x DigitalSignature) Enum() *DigitalSignature {
	p := new(DigitalSignature)
	*p = x
	return p
}

func (x DigitalSignature) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DigitalSignature) Descriptor() protoreflect.EnumDescriptor {
	return file_crypto_crypto_proto_enumTypes[1].Descriptor()
}

func (DigitalSignature) Type() protoreflect.EnumType {
	return &file_crypto_crypto_proto_enumTypes[1]
}

func (x DigitalSignature) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Defines the supported key agreements algorithms.
type KeyAgreement int32

const (
	KeyAgreement_KA_UNSPECIFIED KeyAgreement = 0 // No key agreement.
	KeyAgreement_KA_ECDH_P_256  KeyAgreement = 1 // ECDH using the NIST P-256 curve.
	KeyAgreement_KA_ECDH_P_384  KeyAgreement = 2 // ECDH using the NIST P-384 curve.
)

// Enum value maps for KeyAgreement.
var (
	KeyAgreement_name = map[int32]string{
		0: "KA_UNSPECIFIED",
		1: "KA_ECDH_P_256",
		2: "KA_ECDH_P_384",
	}
	KeyAgreement_value = map[string]int32{
		"KA_UNSPECIFIED": 0,
		"KA_ECDH_P_256":  1,
		"KA_ECDH_P_384":  2,
	}
)

func (x KeyAgreement) Enum() *KeyAgreement {
	p := new(KeyAgreement)
	*p = x
	return p
}

func (x KeyAgreement) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (KeyAgreement) Descriptor() protoreflect.EnumDescriptor {
	return file_crypto_crypto_proto_enumTypes[2].Descriptor()
}

func (KeyAgreement) Type() protoreflect.EnumType {
	return &file_crypto_crypto_proto_enumTypes[2]
}

func (x KeyAgreement) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Defines the supported hash and signature mechanisms.
type Hash int32

const (
	// No hash.
	Hash_HASH_UNSPECIFIED Hash = 0
	// MD5 hash.
	// In standard DLMS:
	//
	//	MD5(StoC || HLS Secret)
	Hash_HASH_MD5 Hash = 1
	// SHA1 hash.
	// In standard DLMS:
	//
	//	SHA1(StoC || HLS Secret)
	Hash_HASH_SHA_1 Hash = 2
	// SHA1 hash.
	// In standard DLMS:
	//
	//	SC || IC || GMAC(SC || AK || StoC)
	Hash_HASH_GMAC Hash = 3
	// SHA256 hash.
	// In standard DLMS:
	//
	//	SHA-256(HLS_Secret || SystemTitle-C || SystemTitle-S || StoC || CtoS)
	Hash_HASH_SHA_256 Hash = 4
	// ECDSA signature.
	// In standard DLMS:
	//
	//	ECDSA(SystemTitle-C || SystemTitle-S || StoC || CtoS)
	Hash_HASH_ECDSA Hash = 5
)

// Enum value maps for Hash.
var (
	Hash_name = map[int32]string{
		0: "HASH_UNSPECIFIED",
		1: "HASH_MD5",
		2: "HASH_SHA_1",
		3: "HASH_GMAC",
		4: "HASH_SHA_256",
		5: "HASH_ECDSA",
	}
	Hash_value = map[string]int32{
		"HASH_UNSPECIFIED": 0,
		"HASH_MD5":         1,
		"HASH_SHA_1":       2,
		"HASH_GMAC":        3,
		"HASH_SHA_256":     4,
		"HASH_ECDSA":       5,
	}
)

func (x Hash) Enum() *Hash {
	p := new(Hash)
	*p = x
	return p
}

func (x Hash) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Hash) Descriptor() protoreflect.EnumDescriptor {
	return file_crypto_crypto_proto_enumTypes[3].Descriptor()
}

func (Hash) Type() protoreflect.EnumType {
	return &file_crypto_crypto_proto_enumTypes[3]
}

func (x Hash) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Defines the direction of hash calculations in DLMS key exchange.
type HashDirection int32

const (
	HashDirection_HASH_DIRECTION_UNSPECIFIED      HashDirection = 0 // Unspecified direction.
	HashDirection_HASH_DIRECTION_CLIENT_TO_SERVER HashDirection = 1 // The hash is calculated for requests from client to server (CtoS, when the client starts the key exchange).
	HashDirection_HASH_DIRECTION_SERVER_TO_CLIENT HashDirection = 2 // The hash is calculated for requests from server to client (StoC, when the server responds to the client's key exchange request).
)

// Enum value maps for HashDirection.
var (
	HashDirection_name = map[int32]string{
		0: "HASH_DIRECTION_UNSPECIFIED",
		1: "HASH_DIRECTION_CLIENT_TO_SERVER",
		2: "HASH_DIRECTION_SERVER_TO_CLIENT",
	}
	HashDirection_value = map[string]int32{
		"HASH_DIRECTION_UNSPECIFIED":      0,
		"HASH_DIRECTION_CLIENT_TO_SERVER": 1,
		"HASH_DIRECTION_SERVER_TO_CLIENT": 2,
	}
)

func (x HashDirection) Enum() *HashDirection {
	p := new(HashDirection)
	*p = x
	return p
}

func (x HashDirection) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (HashDirection) Descriptor() protoreflect.EnumDescriptor {
	return file_crypto_crypto_proto_enumTypes[4].Descriptor()
}

func (HashDirection) Type() protoreflect.EnumType {
	return &file_crypto_crypto_proto_enumTypes[4]
}

func (x HashDirection) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Defines a specification for request messages containing job parameters. Only one request type can be set per message.
type DlmsIn struct {
	state                  protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_Id          uint64                 `protobuf:"varint,1,opt,name=id"`
	xxx_hidden_Request     isDlmsIn_Request       `protobuf_oneof:"request"`
	XXX_raceDetectHookData protoimpl.RaceDetectHookData
	XXX_presence           [1]uint32
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *DlmsIn) Reset() {
	*x = DlmsIn{}
	mi := &file_crypto_crypto_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DlmsIn) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DlmsIn) ProtoMessage() {}

func (x *DlmsIn) ProtoReflect() protoreflect.Message {
	mi := &file_crypto_crypto_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *DlmsIn) GetId() uint64 {
	if x != nil {
		return x.xxx_hidden_Id
	}
	return 0
}

func (x *DlmsIn) GetInit() *DlmsInit {
	if x != nil {
		if x, ok := x.xxx_hidden_Request.(*dlmsIn_Init); ok {
			return x.Init
		}
	}
	return nil
}

func (x *DlmsIn) GetSetup() *DlmsSetServerInfo {
	if x != nil {
		if x, ok := x.xxx_hidden_Request.(*dlmsIn_Setup); ok {
			return x.Setup
		}
	}
	return nil
}

func (x *DlmsIn) GetHash() *DlmsHash {
	if x != nil {
		if x, ok := x.xxx_hidden_Request.(*dlmsIn_Hash); ok {
			return x.Hash
		}
	}
	return nil
}

func (x *DlmsIn) GetEncrypt() *DlmsEncrypt {
	if x != nil {
		if x, ok := x.xxx_hidden_Request.(*dlmsIn_Encrypt); ok {
			return x.Encrypt
		}
	}
	return nil
}

func (x *DlmsIn) GetDecrypt() *DlmsDecrypt {
	if x != nil {
		if x, ok := x.xxx_hidden_Request.(*dlmsIn_Decrypt); ok {
			return x.Decrypt
		}
	}
	return nil
}

func (x *DlmsIn) GetAuthVerify() *DlmsAuthVerify {
	if x != nil {
		if x, ok := x.xxx_hidden_Request.(*dlmsIn_AuthVerify); ok {
			return x.AuthVerify
		}
	}
	return nil
}

func (x *DlmsIn) SetId(v uint64) {
	x.xxx_hidden_Id = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 0, 2)
}

func (x *DlmsIn) SetInit(v *DlmsInit) {
	if v == nil {
		x.xxx_hidden_Request = nil
		return
	}
	x.xxx_hidden_Request = &dlmsIn_Init{v}
}

func (x *DlmsIn) SetSetup(v *DlmsSetServerInfo) {
	if v == nil {
		x.xxx_hidden_Request = nil
		return
	}
	x.xxx_hidden_Request = &dlmsIn_Setup{v}
}

func (x *DlmsIn) SetHash(v *DlmsHash) {
	if v == nil {
		x.xxx_hidden_Request = nil
		return
	}
	x.xxx_hidden_Request = &dlmsIn_Hash{v}
}

func (x *DlmsIn) SetEncrypt(v *DlmsEncrypt) {
	if v == nil {
		x.xxx_hidden_Request = nil
		return
	}
	x.xxx_hidden_Request = &dlmsIn_Encrypt{v}
}

func (x *DlmsIn) SetDecrypt(v *DlmsDecrypt) {
	if v == nil {
		x.xxx_hidden_Request = nil
		return
	}
	x.xxx_hidden_Request = &dlmsIn_Decrypt{v}
}

func (x *DlmsIn) SetAuthVerify(v *DlmsAuthVerify) {
	if v == nil {
		x.xxx_hidden_Request = nil
		return
	}
	x.xxx_hidden_Request = &dlmsIn_AuthVerify{v}
}

func (x *DlmsIn) HasId() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 0)
}

func (x *DlmsIn) HasRequest() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_Request != nil
}

func (x *DlmsIn) HasInit() bool {
	if x == nil {
		return false
	}
	_, ok := x.xxx_hidden_Request.(*dlmsIn_Init)
	return ok
}

func (x *DlmsIn) HasSetup() bool {
	if x == nil {
		return false
	}
	_, ok := x.xxx_hidden_Request.(*dlmsIn_Setup)
	return ok
}

func (x *DlmsIn) HasHash() bool {
	if x == nil {
		return false
	}
	_, ok := x.xxx_hidden_Request.(*dlmsIn_Hash)
	return ok
}

func (x *DlmsIn) HasEncrypt() bool {
	if x == nil {
		return false
	}
	_, ok := x.xxx_hidden_Request.(*dlmsIn_Encrypt)
	return ok
}

func (x *DlmsIn) HasDecrypt() bool {
	if x == nil {
		return false
	}
	_, ok := x.xxx_hidden_Request.(*dlmsIn_Decrypt)
	return ok
}

func (x *DlmsIn) HasAuthVerify() bool {
	if x == nil {
		return false
	}
	_, ok := x.xxx_hidden_Request.(*dlmsIn_AuthVerify)
	return ok
}

func (x *DlmsIn) ClearId() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 0)
	x.xxx_hidden_Id = 0
}

func (x *DlmsIn) ClearRequest() {
	x.xxx_hidden_Request = nil
}

func (x *DlmsIn) ClearInit() {
	if _, ok := x.xxx_hidden_Request.(*dlmsIn_Init); ok {
		x.xxx_hidden_Request = nil
	}
}

func (x *DlmsIn) ClearSetup() {
	if _, ok := x.xxx_hidden_Request.(*dlmsIn_Setup); ok {
		x.xxx_hidden_Request = nil
	}
}

func (x *DlmsIn) ClearHash() {
	if _, ok := x.xxx_hidden_Request.(*dlmsIn_Hash); ok {
		x.xxx_hidden_Request = nil
	}
}

func (x *DlmsIn) ClearEncrypt() {
	if _, ok := x.xxx_hidden_Request.(*dlmsIn_Encrypt); ok {
		x.xxx_hidden_Request = nil
	}
}

func (x *DlmsIn) ClearDecrypt() {
	if _, ok := x.xxx_hidden_Request.(*dlmsIn_Decrypt); ok {
		x.xxx_hidden_Request = nil
	}
}

func (x *DlmsIn) ClearAuthVerify() {
	if _, ok := x.xxx_hidden_Request.(*dlmsIn_AuthVerify); ok {
		x.xxx_hidden_Request = nil
	}
}

const DlmsIn_Request_not_set_case case_DlmsIn_Request = 0
const DlmsIn_Init_case case_DlmsIn_Request = 2
const DlmsIn_Setup_case case_DlmsIn_Request = 3
const DlmsIn_Hash_case case_DlmsIn_Request = 4
const DlmsIn_Encrypt_case case_DlmsIn_Request = 5
const DlmsIn_Decrypt_case case_DlmsIn_Request = 6
const DlmsIn_AuthVerify_case case_DlmsIn_Request = 7

func (x *DlmsIn) WhichRequest() case_DlmsIn_Request {
	if x == nil {
		return DlmsIn_Request_not_set_case
	}
	switch x.xxx_hidden_Request.(type) {
	case *dlmsIn_Init:
		return DlmsIn_Init_case
	case *dlmsIn_Setup:
		return DlmsIn_Setup_case
	case *dlmsIn_Hash:
		return DlmsIn_Hash_case
	case *dlmsIn_Encrypt:
		return DlmsIn_Encrypt_case
	case *dlmsIn_Decrypt:
		return DlmsIn_Decrypt_case
	case *dlmsIn_AuthVerify:
		return DlmsIn_AuthVerify_case
	default:
		return DlmsIn_Request_not_set_case
	}
}

type DlmsIn_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	Id *uint64
	// Fields of oneof xxx_hidden_Request:
	Init       *DlmsInit
	Setup      *DlmsSetServerInfo
	Hash       *DlmsHash
	Encrypt    *DlmsEncrypt
	Decrypt    *DlmsDecrypt
	AuthVerify *DlmsAuthVerify
	// -- end of xxx_hidden_Request
}

func (b0 DlmsIn_builder) Build() *DlmsIn {
	m0 := &DlmsIn{}
	b, x := &b0, m0
	_, _ = b, x
	if b.Id != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 0, 2)
		x.xxx_hidden_Id = *b.Id
	}
	if b.Init != nil {
		x.xxx_hidden_Request = &dlmsIn_Init{b.Init}
	}
	if b.Setup != nil {
		x.xxx_hidden_Request = &dlmsIn_Setup{b.Setup}
	}
	if b.Hash != nil {
		x.xxx_hidden_Request = &dlmsIn_Hash{b.Hash}
	}
	if b.Encrypt != nil {
		x.xxx_hidden_Request = &dlmsIn_Encrypt{b.Encrypt}
	}
	if b.Decrypt != nil {
		x.xxx_hidden_Request = &dlmsIn_Decrypt{b.Decrypt}
	}
	if b.AuthVerify != nil {
		x.xxx_hidden_Request = &dlmsIn_AuthVerify{b.AuthVerify}
	}
	return m0
}

type case_DlmsIn_Request protoreflect.FieldNumber

func (x case_DlmsIn_Request) String() string {
	md := file_crypto_crypto_proto_msgTypes[0].Descriptor()
	if x == 0 {
		return "not set"
	}
	return protoimpl.X.MessageFieldStringOf(md, protoreflect.FieldNumber(x))
}

type isDlmsIn_Request interface {
	isDlmsIn_Request()
}

type dlmsIn_Init struct {
	Init *DlmsInit `protobuf:"bytes,2,opt,name=init,oneof"` // The initialization request. It can be called only once and only as the first request.
}

type dlmsIn_Setup struct {
	Setup *DlmsSetServerInfo `protobuf:"bytes,3,opt,name=setup,oneof"` // The setup server info request. This message shall be called when the data known.
}

type dlmsIn_Hash struct {
	Hash *DlmsHash `protobuf:"bytes,4,opt,name=hash,oneof"` // The hash request.
}

type dlmsIn_Encrypt struct {
	Encrypt *DlmsEncrypt `protobuf:"bytes,5,opt,name=encrypt,oneof"` // The encryption request.
}

type dlmsIn_Decrypt struct {
	Decrypt *DlmsDecrypt `protobuf:"bytes,6,opt,name=decrypt,oneof"` // The decryption request.
}

type dlmsIn_AuthVerify struct {
	AuthVerify *DlmsAuthVerify `protobuf:"bytes,7,opt,name=auth_verify,json=authVerify,oneof"` // The authentication verify.
}

func (*dlmsIn_Init) isDlmsIn_Request() {}

func (*dlmsIn_Setup) isDlmsIn_Request() {}

func (*dlmsIn_Hash) isDlmsIn_Request() {}

func (*dlmsIn_Encrypt) isDlmsIn_Request() {}

func (*dlmsIn_Decrypt) isDlmsIn_Request() {}

func (*dlmsIn_AuthVerify) isDlmsIn_Request() {}

// Defines a specification for initialization parameters for DLSM, typically sent as the first request.
type DlmsInit struct {
	state                   protoimpl.MessageState  `protogen:"opaque.v1"`
	xxx_hidden_Encryption   AuthenticatedEncryption `protobuf:"varint,1,opt,name=encryption,enum=io.clbs.openhes.models.crypto.AuthenticatedEncryption"`
	xxx_hidden_Signature    DigitalSignature        `protobuf:"varint,2,opt,name=signature,enum=io.clbs.openhes.models.crypto.DigitalSignature"`
	xxx_hidden_DriverId     *string                 `protobuf:"bytes,3,opt,name=driver_id,json=driverId"`
	xxx_hidden_SerialNumber *string                 `protobuf:"bytes,4,opt,name=serial_number,json=serialNumber"`
	xxx_hidden_AccessLevel  *string                 `protobuf:"bytes,5,opt,name=access_level,json=accessLevel"`
	xxx_hidden_SystemTitleC []byte                  `protobuf:"bytes,6,opt,name=system_title_c,json=systemTitleC"`
	xxx_hidden_SystemTitleS []byte                  `protobuf:"bytes,7,opt,name=system_title_s,json=systemTitleS"`
	xxx_hidden_CToS         []byte                  `protobuf:"bytes,8,opt,name=c_to_s,json=cToS"`
	XXX_raceDetectHookData  protoimpl.RaceDetectHookData
	XXX_presence            [1]uint32
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *DlmsInit) Reset() {
	*x = DlmsInit{}
	mi := &file_crypto_crypto_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DlmsInit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DlmsInit) ProtoMessage() {}

func (x *DlmsInit) ProtoReflect() protoreflect.Message {
	mi := &file_crypto_crypto_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *DlmsInit) GetEncryption() AuthenticatedEncryption {
	if x != nil {
		if protoimpl.X.Present(&(x.XXX_presence[0]), 0) {
			return x.xxx_hidden_Encryption
		}
	}
	return AuthenticatedEncryption_AE_UNSPECIFIED
}

func (x *DlmsInit) GetSignature() DigitalSignature {
	if x != nil {
		if protoimpl.X.Present(&(x.XXX_presence[0]), 1) {
			return x.xxx_hidden_Signature
		}
	}
	return DigitalSignature_DS_ECDSA_UNSPECIFIED
}

func (x *DlmsInit) GetDriverId() string {
	if x != nil {
		if x.xxx_hidden_DriverId != nil {
			return *x.xxx_hidden_DriverId
		}
		return ""
	}
	return ""
}

func (x *DlmsInit) GetSerialNumber() string {
	if x != nil {
		if x.xxx_hidden_SerialNumber != nil {
			return *x.xxx_hidden_SerialNumber
		}
		return ""
	}
	return ""
}

func (x *DlmsInit) GetAccessLevel() string {
	if x != nil {
		if x.xxx_hidden_AccessLevel != nil {
			return *x.xxx_hidden_AccessLevel
		}
		return ""
	}
	return ""
}

func (x *DlmsInit) GetSystemTitleC() []byte {
	if x != nil {
		return x.xxx_hidden_SystemTitleC
	}
	return nil
}

func (x *DlmsInit) GetSystemTitleS() []byte {
	if x != nil {
		return x.xxx_hidden_SystemTitleS
	}
	return nil
}

func (x *DlmsInit) GetCToS() []byte {
	if x != nil {
		return x.xxx_hidden_CToS
	}
	return nil
}

func (x *DlmsInit) SetEncryption(v AuthenticatedEncryption) {
	x.xxx_hidden_Encryption = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 0, 8)
}

func (x *DlmsInit) SetSignature(v DigitalSignature) {
	x.xxx_hidden_Signature = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 1, 8)
}

func (x *DlmsInit) SetDriverId(v string) {
	x.xxx_hidden_DriverId = &v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 2, 8)
}

func (x *DlmsInit) SetSerialNumber(v string) {
	x.xxx_hidden_SerialNumber = &v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 3, 8)
}

func (x *DlmsInit) SetAccessLevel(v string) {
	x.xxx_hidden_AccessLevel = &v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 4, 8)
}

func (x *DlmsInit) SetSystemTitleC(v []byte) {
	if v == nil {
		v = []byte{}
	}
	x.xxx_hidden_SystemTitleC = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 5, 8)
}

func (x *DlmsInit) SetSystemTitleS(v []byte) {
	if v == nil {
		v = []byte{}
	}
	x.xxx_hidden_SystemTitleS = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 6, 8)
}

func (x *DlmsInit) SetCToS(v []byte) {
	if v == nil {
		v = []byte{}
	}
	x.xxx_hidden_CToS = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 7, 8)
}

func (x *DlmsInit) HasEncryption() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 0)
}

func (x *DlmsInit) HasSignature() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 1)
}

func (x *DlmsInit) HasDriverId() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 2)
}

func (x *DlmsInit) HasSerialNumber() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 3)
}

func (x *DlmsInit) HasAccessLevel() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 4)
}

func (x *DlmsInit) HasSystemTitleC() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 5)
}

func (x *DlmsInit) HasSystemTitleS() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 6)
}

func (x *DlmsInit) HasCToS() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 7)
}

func (x *DlmsInit) ClearEncryption() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 0)
	x.xxx_hidden_Encryption = AuthenticatedEncryption_AE_UNSPECIFIED
}

func (x *DlmsInit) ClearSignature() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 1)
	x.xxx_hidden_Signature = DigitalSignature_DS_ECDSA_UNSPECIFIED
}

func (x *DlmsInit) ClearDriverId() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 2)
	x.xxx_hidden_DriverId = nil
}

func (x *DlmsInit) ClearSerialNumber() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 3)
	x.xxx_hidden_SerialNumber = nil
}

func (x *DlmsInit) ClearAccessLevel() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 4)
	x.xxx_hidden_AccessLevel = nil
}

func (x *DlmsInit) ClearSystemTitleC() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 5)
	x.xxx_hidden_SystemTitleC = nil
}

func (x *DlmsInit) ClearSystemTitleS() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 6)
	x.xxx_hidden_SystemTitleS = nil
}

func (x *DlmsInit) ClearCToS() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 7)
	x.xxx_hidden_CToS = nil
}

type DlmsInit_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	Encryption   *AuthenticatedEncryption
	Signature    *DigitalSignature
	DriverId     *string
	SerialNumber *string
	AccessLevel  *string
	SystemTitleC []byte
	SystemTitleS []byte
	CToS         []byte
}

func (b0 DlmsInit_builder) Build() *DlmsInit {
	m0 := &DlmsInit{}
	b, x := &b0, m0
	_, _ = b, x
	if b.Encryption != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 0, 8)
		x.xxx_hidden_Encryption = *b.Encryption
	}
	if b.Signature != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 1, 8)
		x.xxx_hidden_Signature = *b.Signature
	}
	if b.DriverId != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 2, 8)
		x.xxx_hidden_DriverId = b.DriverId
	}
	if b.SerialNumber != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 3, 8)
		x.xxx_hidden_SerialNumber = b.SerialNumber
	}
	if b.AccessLevel != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 4, 8)
		x.xxx_hidden_AccessLevel = b.AccessLevel
	}
	if b.SystemTitleC != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 5, 8)
		x.xxx_hidden_SystemTitleC = b.SystemTitleC
	}
	if b.SystemTitleS != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 6, 8)
		x.xxx_hidden_SystemTitleS = b.SystemTitleS
	}
	if b.CToS != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 7, 8)
		x.xxx_hidden_CToS = b.CToS
	}
	return m0
}

// Defines a specification for DLMS server information.
type DlmsSetServerInfo struct {
	state                   protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_SystemTitleS []byte                 `protobuf:"bytes,1,opt,name=system_title_s,json=systemTitleS"`
	xxx_hidden_SToC         []byte                 `protobuf:"bytes,2,opt,name=s_to_c,json=sToC"`
	XXX_raceDetectHookData  protoimpl.RaceDetectHookData
	XXX_presence            [1]uint32
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *DlmsSetServerInfo) Reset() {
	*x = DlmsSetServerInfo{}
	mi := &file_crypto_crypto_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DlmsSetServerInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DlmsSetServerInfo) ProtoMessage() {}

func (x *DlmsSetServerInfo) ProtoReflect() protoreflect.Message {
	mi := &file_crypto_crypto_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *DlmsSetServerInfo) GetSystemTitleS() []byte {
	if x != nil {
		return x.xxx_hidden_SystemTitleS
	}
	return nil
}

func (x *DlmsSetServerInfo) GetSToC() []byte {
	if x != nil {
		return x.xxx_hidden_SToC
	}
	return nil
}

func (x *DlmsSetServerInfo) SetSystemTitleS(v []byte) {
	if v == nil {
		v = []byte{}
	}
	x.xxx_hidden_SystemTitleS = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 0, 2)
}

func (x *DlmsSetServerInfo) SetSToC(v []byte) {
	if v == nil {
		v = []byte{}
	}
	x.xxx_hidden_SToC = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 1, 2)
}

func (x *DlmsSetServerInfo) HasSystemTitleS() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 0)
}

func (x *DlmsSetServerInfo) HasSToC() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 1)
}

func (x *DlmsSetServerInfo) ClearSystemTitleS() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 0)
	x.xxx_hidden_SystemTitleS = nil
}

func (x *DlmsSetServerInfo) ClearSToC() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 1)
	x.xxx_hidden_SToC = nil
}

type DlmsSetServerInfo_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	SystemTitleS []byte
	SToC         []byte
}

func (b0 DlmsSetServerInfo_builder) Build() *DlmsSetServerInfo {
	m0 := &DlmsSetServerInfo{}
	b, x := &b0, m0
	_, _ = b, x
	if b.SystemTitleS != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 0, 2)
		x.xxx_hidden_SystemTitleS = b.SystemTitleS
	}
	if b.SToC != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 1, 2)
		x.xxx_hidden_SToC = b.SToC
	}
	return m0
}

// Defines a specification for outgoing DLMS message.
type DlmsOut struct {
	state                  protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_Id          uint64                 `protobuf:"varint,1,opt,name=id"`
	xxx_hidden_Error       *ErrorMessage          `protobuf:"bytes,2,opt,name=error"`
	xxx_hidden_Data        []byte                 `protobuf:"bytes,3,opt,name=data"`
	XXX_raceDetectHookData protoimpl.RaceDetectHookData
	XXX_presence           [1]uint32
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *DlmsOut) Reset() {
	*x = DlmsOut{}
	mi := &file_crypto_crypto_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DlmsOut) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DlmsOut) ProtoMessage() {}

func (x *DlmsOut) ProtoReflect() protoreflect.Message {
	mi := &file_crypto_crypto_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *DlmsOut) GetId() uint64 {
	if x != nil {
		return x.xxx_hidden_Id
	}
	return 0
}

func (x *DlmsOut) GetError() *ErrorMessage {
	if x != nil {
		return x.xxx_hidden_Error
	}
	return nil
}

func (x *DlmsOut) GetData() []byte {
	if x != nil {
		return x.xxx_hidden_Data
	}
	return nil
}

func (x *DlmsOut) SetId(v uint64) {
	x.xxx_hidden_Id = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 0, 3)
}

func (x *DlmsOut) SetError(v *ErrorMessage) {
	x.xxx_hidden_Error = v
}

func (x *DlmsOut) SetData(v []byte) {
	if v == nil {
		v = []byte{}
	}
	x.xxx_hidden_Data = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 2, 3)
}

func (x *DlmsOut) HasId() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 0)
}

func (x *DlmsOut) HasError() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_Error != nil
}

func (x *DlmsOut) HasData() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 2)
}

func (x *DlmsOut) ClearId() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 0)
	x.xxx_hidden_Id = 0
}

func (x *DlmsOut) ClearError() {
	x.xxx_hidden_Error = nil
}

func (x *DlmsOut) ClearData() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 2)
	x.xxx_hidden_Data = nil
}

type DlmsOut_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	Id    *uint64
	Error *ErrorMessage
	Data  []byte
}

func (b0 DlmsOut_builder) Build() *DlmsOut {
	m0 := &DlmsOut{}
	b, x := &b0, m0
	_, _ = b, x
	if b.Id != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 0, 3)
		x.xxx_hidden_Id = *b.Id
	}
	x.xxx_hidden_Error = b.Error
	if b.Data != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 2, 3)
		x.xxx_hidden_Data = b.Data
	}
	return m0
}

// Defines a specification for DLMS encryption.
type DlmsEncrypt struct {
	state                      protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_FrameCounter    uint32                 `protobuf:"varint,1,opt,name=frame_counter,json=frameCounter"`
	xxx_hidden_SecurityControl uint32                 `protobuf:"varint,2,opt,name=security_control,json=securityControl"`
	xxx_hidden_Data            []byte                 `protobuf:"bytes,3,opt,name=data"`
	XXX_raceDetectHookData     protoimpl.RaceDetectHookData
	XXX_presence               [1]uint32
	unknownFields              protoimpl.UnknownFields
	sizeCache                  protoimpl.SizeCache
}

func (x *DlmsEncrypt) Reset() {
	*x = DlmsEncrypt{}
	mi := &file_crypto_crypto_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DlmsEncrypt) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DlmsEncrypt) ProtoMessage() {}

func (x *DlmsEncrypt) ProtoReflect() protoreflect.Message {
	mi := &file_crypto_crypto_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *DlmsEncrypt) GetFrameCounter() uint32 {
	if x != nil {
		return x.xxx_hidden_FrameCounter
	}
	return 0
}

func (x *DlmsEncrypt) GetSecurityControl() uint32 {
	if x != nil {
		return x.xxx_hidden_SecurityControl
	}
	return 0
}

func (x *DlmsEncrypt) GetData() []byte {
	if x != nil {
		return x.xxx_hidden_Data
	}
	return nil
}

func (x *DlmsEncrypt) SetFrameCounter(v uint32) {
	x.xxx_hidden_FrameCounter = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 0, 3)
}

func (x *DlmsEncrypt) SetSecurityControl(v uint32) {
	x.xxx_hidden_SecurityControl = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 1, 3)
}

func (x *DlmsEncrypt) SetData(v []byte) {
	if v == nil {
		v = []byte{}
	}
	x.xxx_hidden_Data = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 2, 3)
}

func (x *DlmsEncrypt) HasFrameCounter() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 0)
}

func (x *DlmsEncrypt) HasSecurityControl() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 1)
}

func (x *DlmsEncrypt) HasData() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 2)
}

func (x *DlmsEncrypt) ClearFrameCounter() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 0)
	x.xxx_hidden_FrameCounter = 0
}

func (x *DlmsEncrypt) ClearSecurityControl() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 1)
	x.xxx_hidden_SecurityControl = 0
}

func (x *DlmsEncrypt) ClearData() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 2)
	x.xxx_hidden_Data = nil
}

type DlmsEncrypt_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	FrameCounter    *uint32
	SecurityControl *uint32
	Data            []byte
}

func (b0 DlmsEncrypt_builder) Build() *DlmsEncrypt {
	m0 := &DlmsEncrypt{}
	b, x := &b0, m0
	_, _ = b, x
	if b.FrameCounter != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 0, 3)
		x.xxx_hidden_FrameCounter = *b.FrameCounter
	}
	if b.SecurityControl != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 1, 3)
		x.xxx_hidden_SecurityControl = *b.SecurityControl
	}
	if b.Data != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 2, 3)
		x.xxx_hidden_Data = b.Data
	}
	return m0
}

// Defines a specification for DLMS decryption.
type DlmsDecrypt struct {
	state                      protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_FrameCounter    uint32                 `protobuf:"varint,1,opt,name=frame_counter,json=frameCounter"`
	xxx_hidden_SecurityControl uint32                 `protobuf:"varint,2,opt,name=security_control,json=securityControl"`
	xxx_hidden_Data            []byte                 `protobuf:"bytes,3,opt,name=data"`
	XXX_raceDetectHookData     protoimpl.RaceDetectHookData
	XXX_presence               [1]uint32
	unknownFields              protoimpl.UnknownFields
	sizeCache                  protoimpl.SizeCache
}

func (x *DlmsDecrypt) Reset() {
	*x = DlmsDecrypt{}
	mi := &file_crypto_crypto_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DlmsDecrypt) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DlmsDecrypt) ProtoMessage() {}

func (x *DlmsDecrypt) ProtoReflect() protoreflect.Message {
	mi := &file_crypto_crypto_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *DlmsDecrypt) GetFrameCounter() uint32 {
	if x != nil {
		return x.xxx_hidden_FrameCounter
	}
	return 0
}

func (x *DlmsDecrypt) GetSecurityControl() uint32 {
	if x != nil {
		return x.xxx_hidden_SecurityControl
	}
	return 0
}

func (x *DlmsDecrypt) GetData() []byte {
	if x != nil {
		return x.xxx_hidden_Data
	}
	return nil
}

func (x *DlmsDecrypt) SetFrameCounter(v uint32) {
	x.xxx_hidden_FrameCounter = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 0, 3)
}

func (x *DlmsDecrypt) SetSecurityControl(v uint32) {
	x.xxx_hidden_SecurityControl = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 1, 3)
}

func (x *DlmsDecrypt) SetData(v []byte) {
	if v == nil {
		v = []byte{}
	}
	x.xxx_hidden_Data = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 2, 3)
}

func (x *DlmsDecrypt) HasFrameCounter() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 0)
}

func (x *DlmsDecrypt) HasSecurityControl() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 1)
}

func (x *DlmsDecrypt) HasData() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 2)
}

func (x *DlmsDecrypt) ClearFrameCounter() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 0)
	x.xxx_hidden_FrameCounter = 0
}

func (x *DlmsDecrypt) ClearSecurityControl() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 1)
	x.xxx_hidden_SecurityControl = 0
}

func (x *DlmsDecrypt) ClearData() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 2)
	x.xxx_hidden_Data = nil
}

type DlmsDecrypt_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	FrameCounter    *uint32
	SecurityControl *uint32
	Data            []byte
}

func (b0 DlmsDecrypt_builder) Build() *DlmsDecrypt {
	m0 := &DlmsDecrypt{}
	b, x := &b0, m0
	_, _ = b, x
	if b.FrameCounter != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 0, 3)
		x.xxx_hidden_FrameCounter = *b.FrameCounter
	}
	if b.SecurityControl != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 1, 3)
		x.xxx_hidden_SecurityControl = *b.SecurityControl
	}
	if b.Data != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 2, 3)
		x.xxx_hidden_Data = b.Data
	}
	return m0
}

// Defines a specification for DLMS hash requests.
type DlmsHash struct {
	state                      protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_Direction       HashDirection          `protobuf:"varint,1,opt,name=direction,enum=io.clbs.openhes.models.crypto.HashDirection"`
	xxx_hidden_Mode            Hash                   `protobuf:"varint,2,opt,name=mode,enum=io.clbs.openhes.models.crypto.Hash"`
	xxx_hidden_FrameCounter    uint32                 `protobuf:"varint,3,opt,name=frame_counter,json=frameCounter"`
	xxx_hidden_SecurityControl uint32                 `protobuf:"varint,4,opt,name=security_control,json=securityControl"`
	XXX_raceDetectHookData     protoimpl.RaceDetectHookData
	XXX_presence               [1]uint32
	unknownFields              protoimpl.UnknownFields
	sizeCache                  protoimpl.SizeCache
}

func (x *DlmsHash) Reset() {
	*x = DlmsHash{}
	mi := &file_crypto_crypto_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DlmsHash) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DlmsHash) ProtoMessage() {}

func (x *DlmsHash) ProtoReflect() protoreflect.Message {
	mi := &file_crypto_crypto_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *DlmsHash) GetDirection() HashDirection {
	if x != nil {
		if protoimpl.X.Present(&(x.XXX_presence[0]), 0) {
			return x.xxx_hidden_Direction
		}
	}
	return HashDirection_HASH_DIRECTION_UNSPECIFIED
}

func (x *DlmsHash) GetMode() Hash {
	if x != nil {
		if protoimpl.X.Present(&(x.XXX_presence[0]), 1) {
			return x.xxx_hidden_Mode
		}
	}
	return Hash_HASH_UNSPECIFIED
}

func (x *DlmsHash) GetFrameCounter() uint32 {
	if x != nil {
		return x.xxx_hidden_FrameCounter
	}
	return 0
}

func (x *DlmsHash) GetSecurityControl() uint32 {
	if x != nil {
		return x.xxx_hidden_SecurityControl
	}
	return 0
}

func (x *DlmsHash) SetDirection(v HashDirection) {
	x.xxx_hidden_Direction = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 0, 4)
}

func (x *DlmsHash) SetMode(v Hash) {
	x.xxx_hidden_Mode = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 1, 4)
}

func (x *DlmsHash) SetFrameCounter(v uint32) {
	x.xxx_hidden_FrameCounter = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 2, 4)
}

func (x *DlmsHash) SetSecurityControl(v uint32) {
	x.xxx_hidden_SecurityControl = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 3, 4)
}

func (x *DlmsHash) HasDirection() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 0)
}

func (x *DlmsHash) HasMode() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 1)
}

func (x *DlmsHash) HasFrameCounter() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 2)
}

func (x *DlmsHash) HasSecurityControl() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 3)
}

func (x *DlmsHash) ClearDirection() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 0)
	x.xxx_hidden_Direction = HashDirection_HASH_DIRECTION_UNSPECIFIED
}

func (x *DlmsHash) ClearMode() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 1)
	x.xxx_hidden_Mode = Hash_HASH_UNSPECIFIED
}

func (x *DlmsHash) ClearFrameCounter() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 2)
	x.xxx_hidden_FrameCounter = 0
}

func (x *DlmsHash) ClearSecurityControl() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 3)
	x.xxx_hidden_SecurityControl = 0
}

type DlmsHash_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	Direction       *HashDirection
	Mode            *Hash
	FrameCounter    *uint32
	SecurityControl *uint32
}

func (b0 DlmsHash_builder) Build() *DlmsHash {
	m0 := &DlmsHash{}
	b, x := &b0, m0
	_, _ = b, x
	if b.Direction != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 0, 4)
		x.xxx_hidden_Direction = *b.Direction
	}
	if b.Mode != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 1, 4)
		x.xxx_hidden_Mode = *b.Mode
	}
	if b.FrameCounter != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 2, 4)
		x.xxx_hidden_FrameCounter = *b.FrameCounter
	}
	if b.SecurityControl != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 3, 4)
		x.xxx_hidden_SecurityControl = *b.SecurityControl
	}
	return m0
}

// Defines a specification for DLMS authentication verifications.
type DlmsAuthVerify struct {
	state                      protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_Direction       HashDirection          `protobuf:"varint,1,opt,name=direction,enum=io.clbs.openhes.models.crypto.HashDirection"`
	xxx_hidden_Mode            Hash                   `protobuf:"varint,2,opt,name=mode,enum=io.clbs.openhes.models.crypto.Hash"`
	xxx_hidden_FrameCounter    uint32                 `protobuf:"varint,3,opt,name=frame_counter,json=frameCounter"`
	xxx_hidden_SecurityControl uint32                 `protobuf:"varint,4,opt,name=security_control,json=securityControl"`
	xxx_hidden_Data            []byte                 `protobuf:"bytes,5,opt,name=data"`
	XXX_raceDetectHookData     protoimpl.RaceDetectHookData
	XXX_presence               [1]uint32
	unknownFields              protoimpl.UnknownFields
	sizeCache                  protoimpl.SizeCache
}

func (x *DlmsAuthVerify) Reset() {
	*x = DlmsAuthVerify{}
	mi := &file_crypto_crypto_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DlmsAuthVerify) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DlmsAuthVerify) ProtoMessage() {}

func (x *DlmsAuthVerify) ProtoReflect() protoreflect.Message {
	mi := &file_crypto_crypto_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *DlmsAuthVerify) GetDirection() HashDirection {
	if x != nil {
		if protoimpl.X.Present(&(x.XXX_presence[0]), 0) {
			return x.xxx_hidden_Direction
		}
	}
	return HashDirection_HASH_DIRECTION_UNSPECIFIED
}

func (x *DlmsAuthVerify) GetMode() Hash {
	if x != nil {
		if protoimpl.X.Present(&(x.XXX_presence[0]), 1) {
			return x.xxx_hidden_Mode
		}
	}
	return Hash_HASH_UNSPECIFIED
}

func (x *DlmsAuthVerify) GetFrameCounter() uint32 {
	if x != nil {
		return x.xxx_hidden_FrameCounter
	}
	return 0
}

func (x *DlmsAuthVerify) GetSecurityControl() uint32 {
	if x != nil {
		return x.xxx_hidden_SecurityControl
	}
	return 0
}

func (x *DlmsAuthVerify) GetData() []byte {
	if x != nil {
		return x.xxx_hidden_Data
	}
	return nil
}

func (x *DlmsAuthVerify) SetDirection(v HashDirection) {
	x.xxx_hidden_Direction = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 0, 5)
}

func (x *DlmsAuthVerify) SetMode(v Hash) {
	x.xxx_hidden_Mode = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 1, 5)
}

func (x *DlmsAuthVerify) SetFrameCounter(v uint32) {
	x.xxx_hidden_FrameCounter = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 2, 5)
}

func (x *DlmsAuthVerify) SetSecurityControl(v uint32) {
	x.xxx_hidden_SecurityControl = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 3, 5)
}

func (x *DlmsAuthVerify) SetData(v []byte) {
	if v == nil {
		v = []byte{}
	}
	x.xxx_hidden_Data = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 4, 5)
}

func (x *DlmsAuthVerify) HasDirection() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 0)
}

func (x *DlmsAuthVerify) HasMode() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 1)
}

func (x *DlmsAuthVerify) HasFrameCounter() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 2)
}

func (x *DlmsAuthVerify) HasSecurityControl() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 3)
}

func (x *DlmsAuthVerify) HasData() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 4)
}

func (x *DlmsAuthVerify) ClearDirection() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 0)
	x.xxx_hidden_Direction = HashDirection_HASH_DIRECTION_UNSPECIFIED
}

func (x *DlmsAuthVerify) ClearMode() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 1)
	x.xxx_hidden_Mode = Hash_HASH_UNSPECIFIED
}

func (x *DlmsAuthVerify) ClearFrameCounter() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 2)
	x.xxx_hidden_FrameCounter = 0
}

func (x *DlmsAuthVerify) ClearSecurityControl() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 3)
	x.xxx_hidden_SecurityControl = 0
}

func (x *DlmsAuthVerify) ClearData() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 4)
	x.xxx_hidden_Data = nil
}

type DlmsAuthVerify_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	Direction       *HashDirection
	Mode            *Hash
	FrameCounter    *uint32
	SecurityControl *uint32
	Data            []byte
}

func (b0 DlmsAuthVerify_builder) Build() *DlmsAuthVerify {
	m0 := &DlmsAuthVerify{}
	b, x := &b0, m0
	_, _ = b, x
	if b.Direction != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 0, 5)
		x.xxx_hidden_Direction = *b.Direction
	}
	if b.Mode != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 1, 5)
		x.xxx_hidden_Mode = *b.Mode
	}
	if b.FrameCounter != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 2, 5)
		x.xxx_hidden_FrameCounter = *b.FrameCounter
	}
	if b.SecurityControl != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 3, 5)
		x.xxx_hidden_SecurityControl = *b.SecurityControl
	}
	if b.Data != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 4, 5)
		x.xxx_hidden_Data = b.Data
	}
	return m0
}

// Defines a specification for user-facing error message.
type ErrorMessage struct {
	state                  protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_Code        uint32                 `protobuf:"varint,1,opt,name=code"`
	xxx_hidden_Message     *string                `protobuf:"bytes,2,opt,name=message"`
	XXX_raceDetectHookData protoimpl.RaceDetectHookData
	XXX_presence           [1]uint32
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *ErrorMessage) Reset() {
	*x = ErrorMessage{}
	mi := &file_crypto_crypto_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ErrorMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ErrorMessage) ProtoMessage() {}

func (x *ErrorMessage) ProtoReflect() protoreflect.Message {
	mi := &file_crypto_crypto_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ErrorMessage) GetCode() uint32 {
	if x != nil {
		return x.xxx_hidden_Code
	}
	return 0
}

func (x *ErrorMessage) GetMessage() string {
	if x != nil {
		if x.xxx_hidden_Message != nil {
			return *x.xxx_hidden_Message
		}
		return ""
	}
	return ""
}

func (x *ErrorMessage) SetCode(v uint32) {
	x.xxx_hidden_Code = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 0, 2)
}

func (x *ErrorMessage) SetMessage(v string) {
	x.xxx_hidden_Message = &v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 1, 2)
}

func (x *ErrorMessage) HasCode() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 0)
}

func (x *ErrorMessage) HasMessage() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 1)
}

func (x *ErrorMessage) ClearCode() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 0)
	x.xxx_hidden_Code = 0
}

func (x *ErrorMessage) ClearMessage() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 1)
	x.xxx_hidden_Message = nil
}

type ErrorMessage_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The error code. Uses standard gRPC codes, see https://pkg.go.dev/google.golang.org/grpc/codes#pkg-constants.
	Code *uint32
	// The error message to be witten to the log.
	Message *string
}

func (b0 ErrorMessage_builder) Build() *ErrorMessage {
	m0 := &ErrorMessage{}
	b, x := &b0, m0
	_, _ = b, x
	if b.Code != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 0, 2)
		x.xxx_hidden_Code = *b.Code
	}
	if b.Message != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 1, 2)
		x.xxx_hidden_Message = b.Message
	}
	return m0
}

var File_crypto_crypto_proto protoreflect.FileDescriptor

const file_crypto_crypto_proto_rawDesc = "" +
	"\n" +
	"\x13crypto/crypto.proto\x12\x1dio.clbs.openhes.models.crypto\"\xcd\x03\n" +
	"\x06DlmsIn\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\x04R\x02id\x12=\n" +
	"\x04init\x18\x02 \x01(\v2'.io.clbs.openhes.models.crypto.DlmsInitH\x00R\x04init\x12H\n" +
	"\x05setup\x18\x03 \x01(\v20.io.clbs.openhes.models.crypto.DlmsSetServerInfoH\x00R\x05setup\x12=\n" +
	"\x04hash\x18\x04 \x01(\v2'.io.clbs.openhes.models.crypto.DlmsHashH\x00R\x04hash\x12F\n" +
	"\aencrypt\x18\x05 \x01(\v2*.io.clbs.openhes.models.crypto.DlmsEncryptH\x00R\aencrypt\x12F\n" +
	"\adecrypt\x18\x06 \x01(\v2*.io.clbs.openhes.models.crypto.DlmsDecryptH\x00R\adecrypt\x12P\n" +
	"\vauth_verify\x18\a \x01(\v2-.io.clbs.openhes.models.crypto.DlmsAuthVerifyH\x00R\n" +
	"authVerifyB\t\n" +
	"\arequest\"\xf8\x02\n" +
	"\bDlmsInit\x12V\n" +
	"\n" +
	"encryption\x18\x01 \x01(\x0e26.io.clbs.openhes.models.crypto.AuthenticatedEncryptionR\n" +
	"encryption\x12M\n" +
	"\tsignature\x18\x02 \x01(\x0e2/.io.clbs.openhes.models.crypto.DigitalSignatureR\tsignature\x12\x1b\n" +
	"\tdriver_id\x18\x03 \x01(\tR\bdriverId\x12#\n" +
	"\rserial_number\x18\x04 \x01(\tR\fserialNumber\x12!\n" +
	"\faccess_level\x18\x05 \x01(\tR\vaccessLevel\x12$\n" +
	"\x0esystem_title_c\x18\x06 \x01(\fR\fsystemTitleC\x12$\n" +
	"\x0esystem_title_s\x18\a \x01(\fR\fsystemTitleS\x12\x14\n" +
	"\x06c_to_s\x18\b \x01(\fR\x04cToS\"O\n" +
	"\x11DlmsSetServerInfo\x12$\n" +
	"\x0esystem_title_s\x18\x01 \x01(\fR\fsystemTitleS\x12\x14\n" +
	"\x06s_to_c\x18\x02 \x01(\fR\x04sToC\"p\n" +
	"\aDlmsOut\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\x04R\x02id\x12A\n" +
	"\x05error\x18\x02 \x01(\v2+.io.clbs.openhes.models.crypto.ErrorMessageR\x05error\x12\x12\n" +
	"\x04data\x18\x03 \x01(\fR\x04data\"q\n" +
	"\vDlmsEncrypt\x12#\n" +
	"\rframe_counter\x18\x01 \x01(\rR\fframeCounter\x12)\n" +
	"\x10security_control\x18\x02 \x01(\rR\x0fsecurityControl\x12\x12\n" +
	"\x04data\x18\x03 \x01(\fR\x04data\"q\n" +
	"\vDlmsDecrypt\x12#\n" +
	"\rframe_counter\x18\x01 \x01(\rR\fframeCounter\x12)\n" +
	"\x10security_control\x18\x02 \x01(\rR\x0fsecurityControl\x12\x12\n" +
	"\x04data\x18\x03 \x01(\fR\x04data\"\xdf\x01\n" +
	"\bDlmsHash\x12J\n" +
	"\tdirection\x18\x01 \x01(\x0e2,.io.clbs.openhes.models.crypto.HashDirectionR\tdirection\x127\n" +
	"\x04mode\x18\x02 \x01(\x0e2#.io.clbs.openhes.models.crypto.HashR\x04mode\x12#\n" +
	"\rframe_counter\x18\x03 \x01(\rR\fframeCounter\x12)\n" +
	"\x10security_control\x18\x04 \x01(\rR\x0fsecurityControl\"\xf9\x01\n" +
	"\x0eDlmsAuthVerify\x12J\n" +
	"\tdirection\x18\x01 \x01(\x0e2,.io.clbs.openhes.models.crypto.HashDirectionR\tdirection\x127\n" +
	"\x04mode\x18\x02 \x01(\x0e2#.io.clbs.openhes.models.crypto.HashR\x04mode\x12#\n" +
	"\rframe_counter\x18\x03 \x01(\rR\fframeCounter\x12)\n" +
	"\x10security_control\x18\x04 \x01(\rR\x0fsecurityControl\x12\x12\n" +
	"\x04data\x18\x05 \x01(\fR\x04data\"<\n" +
	"\fErrorMessage\x12\x12\n" +
	"\x04code\x18\x01 \x01(\rR\x04code\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage*U\n" +
	"\x17AuthenticatedEncryption\x12\x12\n" +
	"\x0eAE_UNSPECIFIED\x10\x00\x12\x12\n" +
	"\x0eAE_AES_GCM_128\x10\x01\x12\x12\n" +
	"\x0eAE_AES_GCM_256\x10\x02*T\n" +
	"\x10DigitalSignature\x12\x18\n" +
	"\x14DS_ECDSA_UNSPECIFIED\x10\x00\x12\x12\n" +
	"\x0eDS_ECDSA_P_256\x10\x01\x12\x12\n" +
	"\x0eDS_ECDSA_P_384\x10\x02*H\n" +
	"\fKeyAgreement\x12\x12\n" +
	"\x0eKA_UNSPECIFIED\x10\x00\x12\x11\n" +
	"\rKA_ECDH_P_256\x10\x01\x12\x11\n" +
	"\rKA_ECDH_P_384\x10\x02*k\n" +
	"\x04Hash\x12\x14\n" +
	"\x10HASH_UNSPECIFIED\x10\x00\x12\f\n" +
	"\bHASH_MD5\x10\x01\x12\x0e\n" +
	"\n" +
	"HASH_SHA_1\x10\x02\x12\r\n" +
	"\tHASH_GMAC\x10\x03\x12\x10\n" +
	"\fHASH_SHA_256\x10\x04\x12\x0e\n" +
	"\n" +
	"HASH_ECDSA\x10\x05*y\n" +
	"\rHashDirection\x12\x1e\n" +
	"\x1aHASH_DIRECTION_UNSPECIFIED\x10\x00\x12#\n" +
	"\x1fHASH_DIRECTION_CLIENT_TO_SERVER\x10\x01\x12#\n" +
	"\x1fHASH_DIRECTION_SERVER_TO_CLIENT\x10\x02B5Z3github.com/cybroslabs/ouro-api-shared/gen/go/cryptob\beditionsp\xe8\a"

var file_crypto_crypto_proto_enumTypes = make([]protoimpl.EnumInfo, 5)
var file_crypto_crypto_proto_msgTypes = make([]protoimpl.MessageInfo, 9)
var file_crypto_crypto_proto_goTypes = []any{
	(AuthenticatedEncryption)(0), // 0: io.clbs.openhes.models.crypto.AuthenticatedEncryption
	(DigitalSignature)(0),        // 1: io.clbs.openhes.models.crypto.DigitalSignature
	(KeyAgreement)(0),            // 2: io.clbs.openhes.models.crypto.KeyAgreement
	(Hash)(0),                    // 3: io.clbs.openhes.models.crypto.Hash
	(HashDirection)(0),           // 4: io.clbs.openhes.models.crypto.HashDirection
	(*DlmsIn)(nil),               // 5: io.clbs.openhes.models.crypto.DlmsIn
	(*DlmsInit)(nil),             // 6: io.clbs.openhes.models.crypto.DlmsInit
	(*DlmsSetServerInfo)(nil),    // 7: io.clbs.openhes.models.crypto.DlmsSetServerInfo
	(*DlmsOut)(nil),              // 8: io.clbs.openhes.models.crypto.DlmsOut
	(*DlmsEncrypt)(nil),          // 9: io.clbs.openhes.models.crypto.DlmsEncrypt
	(*DlmsDecrypt)(nil),          // 10: io.clbs.openhes.models.crypto.DlmsDecrypt
	(*DlmsHash)(nil),             // 11: io.clbs.openhes.models.crypto.DlmsHash
	(*DlmsAuthVerify)(nil),       // 12: io.clbs.openhes.models.crypto.DlmsAuthVerify
	(*ErrorMessage)(nil),         // 13: io.clbs.openhes.models.crypto.ErrorMessage
}
var file_crypto_crypto_proto_depIdxs = []int32{
	6,  // 0: io.clbs.openhes.models.crypto.DlmsIn.init:type_name -> io.clbs.openhes.models.crypto.DlmsInit
	7,  // 1: io.clbs.openhes.models.crypto.DlmsIn.setup:type_name -> io.clbs.openhes.models.crypto.DlmsSetServerInfo
	11, // 2: io.clbs.openhes.models.crypto.DlmsIn.hash:type_name -> io.clbs.openhes.models.crypto.DlmsHash
	9,  // 3: io.clbs.openhes.models.crypto.DlmsIn.encrypt:type_name -> io.clbs.openhes.models.crypto.DlmsEncrypt
	10, // 4: io.clbs.openhes.models.crypto.DlmsIn.decrypt:type_name -> io.clbs.openhes.models.crypto.DlmsDecrypt
	12, // 5: io.clbs.openhes.models.crypto.DlmsIn.auth_verify:type_name -> io.clbs.openhes.models.crypto.DlmsAuthVerify
	0,  // 6: io.clbs.openhes.models.crypto.DlmsInit.encryption:type_name -> io.clbs.openhes.models.crypto.AuthenticatedEncryption
	1,  // 7: io.clbs.openhes.models.crypto.DlmsInit.signature:type_name -> io.clbs.openhes.models.crypto.DigitalSignature
	13, // 8: io.clbs.openhes.models.crypto.DlmsOut.error:type_name -> io.clbs.openhes.models.crypto.ErrorMessage
	4,  // 9: io.clbs.openhes.models.crypto.DlmsHash.direction:type_name -> io.clbs.openhes.models.crypto.HashDirection
	3,  // 10: io.clbs.openhes.models.crypto.DlmsHash.mode:type_name -> io.clbs.openhes.models.crypto.Hash
	4,  // 11: io.clbs.openhes.models.crypto.DlmsAuthVerify.direction:type_name -> io.clbs.openhes.models.crypto.HashDirection
	3,  // 12: io.clbs.openhes.models.crypto.DlmsAuthVerify.mode:type_name -> io.clbs.openhes.models.crypto.Hash
	13, // [13:13] is the sub-list for method output_type
	13, // [13:13] is the sub-list for method input_type
	13, // [13:13] is the sub-list for extension type_name
	13, // [13:13] is the sub-list for extension extendee
	0,  // [0:13] is the sub-list for field type_name
}

func init() { file_crypto_crypto_proto_init() }
func file_crypto_crypto_proto_init() {
	if File_crypto_crypto_proto != nil {
		return
	}
	file_crypto_crypto_proto_msgTypes[0].OneofWrappers = []any{
		(*dlmsIn_Init)(nil),
		(*dlmsIn_Setup)(nil),
		(*dlmsIn_Hash)(nil),
		(*dlmsIn_Encrypt)(nil),
		(*dlmsIn_Decrypt)(nil),
		(*dlmsIn_AuthVerify)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_crypto_crypto_proto_rawDesc), len(file_crypto_crypto_proto_rawDesc)),
			NumEnums:      5,
			NumMessages:   9,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_crypto_crypto_proto_goTypes,
		DependencyIndexes: file_crypto_crypto_proto_depIdxs,
		EnumInfos:         file_crypto_crypto_proto_enumTypes,
		MessageInfos:      file_crypto_crypto_proto_msgTypes,
	}.Build()
	File_crypto_crypto_proto = out.File
	file_crypto_crypto_proto_goTypes = nil
	file_crypto_crypto_proto_depIdxs = nil
}
