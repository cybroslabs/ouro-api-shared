// @generated by protoc-gen-es v2.5.2 with parameter "target=ts,json_types=true"
// @generated from file acquisition/shared.proto (package io.clbs.openhes.models.acquisition, edition 2023)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { Duration, DurationJson, Empty, EmptyJson, Timestamp, TimestampJson } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_duration, file_google_protobuf_empty, file_google_protobuf_struct, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { FieldDescriptor, FieldDescriptorJson, FieldValue, FieldValueJson, FieldValues, FieldValuesJson } from "../common/fields_pb";
import { file_common_fields } from "../common/fields_pb";
import type { MetadataFields, MetadataFieldsJson } from "../common/metadata_pb";
import { file_common_metadata } from "../common/metadata_pb";
import type { ListOfString, ListOfStringJson } from "../common/types_pb";
import { file_common_types } from "../common/types_pb";
import type { TimeOfUseTableSpec, TimeOfUseTableSpecJson } from "./timeofuse/timeofuse_pb";
import { file_acquisition_timeofuse_timeofuse } from "./timeofuse/timeofuse_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file acquisition/shared.proto.
 */
export const file_acquisition_shared: GenFile = /*@__PURE__*/
  fileDesc("ChhhY3F1aXNpdGlvbi9zaGFyZWQucHJvdG8SImlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24iowIKC0pvYlNldHRpbmdzEi8KDG1heF9kdXJhdGlvbhgBIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhJBCghwcmlvcml0eRgCIAEoDjIvLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uSm9iUHJpb3JpdHkSEAoIYXR0ZW1wdHMYAyADKAUSLgoLcmV0cnlfZGVsYXkYBCABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SLgoLZGVmZXJfc3RhcnQYBSABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SLgoKZXhwaXJlc19hdBgGIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAiiAoKCUpvYkFjdGlvbhIRCglhY3Rpb25faWQYASABKAkSUQoKYXR0cmlidXRlcxgCIAMoCzI9LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uSm9iQWN0aW9uLkF0dHJpYnV0ZXNFbnRyeRJNCgxnZXRfcmVnaXN0ZXIYAyABKAsyNS5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFjdGlvbkdldFJlZ2lzdGVySAASYAoWZ2V0X3BlcmlvZGljYWxfcHJvZmlsZRgEIAEoCzI+LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQWN0aW9uR2V0UGVyaW9kaWNhbFByb2ZpbGVIABJeChVnZXRfaXJyZWd1bGFyX3Byb2ZpbGUYBSABKAsyPS5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFjdGlvbkdldElycmVndWxhclByb2ZpbGVIABJJCgpnZXRfZXZlbnRzGAYgASgLMjMuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5BY3Rpb25HZXRFdmVudHNIABJSCg9nZXRfZGV2aWNlX2luZm8YByABKAsyNy5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFjdGlvbkdldERldmljZUluZm9IABJJCgpzeW5jX2Nsb2NrGAggASgLMjMuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5BY3Rpb25TeW5jQ2xvY2tIABJSCg9zZXRfcmVsYXlfc3RhdGUYCiABKAsyNy5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFjdGlvblNldFJlbGF5U3RhdGVIABJgChZzZXRfZGlzY29ubmVjdG9yX3N0YXRlGAwgASgLMj4uaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5BY3Rpb25TZXREaXNjb25uZWN0b3JTdGF0ZUgAEkMKB2dldF90b3UYDSABKAsyMC5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFjdGlvbkdldFRvdUgAEkMKB3NldF90b3UYDiABKAsyMC5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFjdGlvblNldFRvdUgAEksKC3NldF9saW1pdGVyGBAgASgLMjQuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5BY3Rpb25TZXRMaW1pdGVySAASXAoUcmVzZXRfYmlsbGluZ19wZXJpb2QYESABKAsyPC5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFjdGlvblJlc2V0QmlsbGluZ1BlcmlvZEgAEkcKCWZ3X3VwZGF0ZRgSIAEoCzIyLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQWN0aW9uRndVcGRhdGVIABpcCg9BdHRyaWJ1dGVzRW50cnkSCwoDa2V5GAEgASgJEjgKBXZhbHVlGAIgASgLMikuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5jb21tb24uRmllbGRWYWx1ZToCOAFCCAoGYWN0aW9uItoICgxKb2JBY3Rpb25TZXQSEQoJdmFyaWFibGVzGAIgAygJEk0KDGdldF9yZWdpc3RlchgDIAEoCzI1LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQWN0aW9uR2V0UmVnaXN0ZXJIABJgChZnZXRfcGVyaW9kaWNhbF9wcm9maWxlGAQgASgLMj4uaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5BY3Rpb25HZXRQZXJpb2RpY2FsUHJvZmlsZUgAEl4KFWdldF9pcnJlZ3VsYXJfcHJvZmlsZRgFIAEoCzI9LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQWN0aW9uR2V0SXJyZWd1bGFyUHJvZmlsZUgAEkkKCmdldF9ldmVudHMYBiABKAsyMy5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFjdGlvbkdldEV2ZW50c0gAElIKD2dldF9kZXZpY2VfaW5mbxgHIAEoCzI3LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQWN0aW9uR2V0RGV2aWNlSW5mb0gAEkkKCnN5bmNfY2xvY2sYCCABKAsyMy5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFjdGlvblN5bmNDbG9ja0gAElIKD3NldF9yZWxheV9zdGF0ZRgKIAEoCzI3LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQWN0aW9uU2V0UmVsYXlTdGF0ZUgAEmAKFnNldF9kaXNjb25uZWN0b3Jfc3RhdGUYDCABKAsyPi5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFjdGlvblNldERpc2Nvbm5lY3RvclN0YXRlSAASQwoHZ2V0X3RvdRgNIAEoCzIwLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQWN0aW9uR2V0VG91SAASQwoHc2V0X3RvdRgOIAEoCzIwLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQWN0aW9uU2V0VG91SAASSwoLc2V0X2xpbWl0ZXIYECABKAsyNC5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFjdGlvblNldExpbWl0ZXJIABJcChRyZXNldF9iaWxsaW5nX3BlcmlvZBgRIAEoCzI8LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQWN0aW9uUmVzZXRCaWxsaW5nUGVyaW9kSAASRwoJZndfdXBkYXRlGBIgASgLMjIuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5BY3Rpb25Gd1VwZGF0ZUgAQggKBmFjdGlvbiJjCg9MaXN0T2ZKb2JEZXZpY2USOwoEbGlzdBgBIAMoCzItLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uSm9iRGV2aWNlEhMKC3RvdGFsX2NvdW50GAIgASgFImcKEUxpc3RPZkpvYkRldmljZUlkEj0KBGxpc3QYASADKAsyLy5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkpvYkRldmljZUlkEhMKC3RvdGFsX2NvdW50GAIgASgFIjAKC0pvYkRldmljZUlkEg4KBmpvYl9pZBgBIAEoCRIRCglkZXZpY2VfaWQYAiABKAkitQMKCUpvYkRldmljZRIOCgZqb2JfaWQYASABKAkSEQoJZGV2aWNlX2lkGAIgASgJEhMKC2V4dGVybmFsX2lkGAMgASgJEl4KEWRldmljZV9hdHRyaWJ1dGVzGAQgAygLMkMuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5Kb2JEZXZpY2UuRGV2aWNlQXR0cmlidXRlc0VudHJ5EksKD2Nvbm5lY3Rpb25faW5mbxgFIAMoCzIyLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQ29ubmVjdGlvbkluZm8STQoMYXBwX3Byb3RvY29sGAYgASgOMjcuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5BcHBsaWNhdGlvblByb3RvY29sEhAKCHRpbWV6b25lGAcgASgJGmIKFURldmljZUF0dHJpYnV0ZXNFbnRyeRILCgNrZXkYASABKAkSOAoFdmFsdWUYAiABKAsyKS5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmNvbW1vbi5GaWVsZFZhbHVlOgI4ASK3AwoJTW9kZW1JbmZvEhAKCG1vZGVtX2lkGAEgASgJEgwKBG5hbWUYAiABKAkSDwoHYXRfaW5pdBgDIAEoCRIPCgdhdF9kaWFsGAQgASgJEhEKCWF0X2hhbmd1cBgFIAEoCRIRCglhdF9lc2NhcGUYBiABKAkSMgoPY29ubmVjdF90aW1lb3V0GAcgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEjIKD2NvbW1hbmRfdGltZW91dBgIIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhJOCgV0Y3BpcBgJIAEoCzI9LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQ29ubmVjdGlvblR5cGVEaXJlY3RUY3BJcEgAElwKDnNlcmlhbF9vdmVyX2lwGAogASgLMkIuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5Db25uZWN0aW9uVHlwZUNvbnRyb2xsZWRTZXJpYWxIABIYChBzZXJpYWxfYmF1ZF9yYXRlGAsgASgNQhIKEG1vZGVtX2Nvbm5lY3Rpb24ivQIKDFNlcmlhbENvbmZpZxJLCgliYXVkX3JhdGUYASABKA4yOC5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLlNlcmlhbENvbmZpZ0JhdWRSYXRlEkYKBnBhcml0eRgCIAEoDjI2LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uU2VyaWFsQ29uZmlnUGFyaXR5EksKCWRhdGFfYml0cxgDIAEoDjI4LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uU2VyaWFsQ29uZmlnRGF0YUJpdHMSSwoJc3RvcF9iaXRzGAQgASgOMjguaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5TZXJpYWxDb25maWdTdG9wQml0cyLABAoOQ29ubmVjdGlvbkluZm8STgoFdGNwaXAYASABKAsyPS5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkNvbm5lY3Rpb25UeXBlRGlyZWN0VGNwSXBIABJRCgptb2RlbV9wb29sGAIgASgLMjsuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5Db25uZWN0aW9uVHlwZU1vZGVtUG9vbEgAElwKDnNlcmlhbF9vdmVyX2lwGAMgASgLMkIuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5Db25uZWN0aW9uVHlwZUNvbnRyb2xsZWRTZXJpYWxIABJLCg1saW5rX3Byb3RvY29sGAQgASgOMjQuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5EYXRhTGlua1Byb3RvY29sEhwKFGNvbW11bmljYXRpb25fYnVzX2lkGAUgASgJElYKCmF0dHJpYnV0ZXMYBiADKAsyQi5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkNvbm5lY3Rpb25JbmZvLkF0dHJpYnV0ZXNFbnRyeRpcCg9BdHRyaWJ1dGVzRW50cnkSCwoDa2V5GAEgASgJEjgKBXZhbHVlGAIgASgLMikuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5jb21tb24uRmllbGRWYWx1ZToCOAFCDAoKY29ubmVjdGlvbiJjChlDb25uZWN0aW9uVHlwZURpcmVjdFRjcElwEgwKBGhvc3QYASABKAkSDAoEcG9ydBgCIAEoDRIqCgd0aW1lb3V0GAMgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uIngKF0Nvbm5lY3Rpb25UeXBlTW9kZW1Qb29sEg4KBm51bWJlchgBIAEoCRIPCgdwb29sX2lkGAIgASgJEjwKBW1vZGVtGAQgASgLMi0uaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5Nb2RlbUluZm8iZAoaQ29ubmVjdGlvblR5cGVTZXJpYWxEaXJlY3QSDAoEaG9zdBgBIAEoCRIMCgRwb3J0GAIgASgNEioKB3RpbWVvdXQYAyABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24ifAoYQ29ubmVjdGlvblR5cGVTZXJpYWxNb3hhEgwKBGhvc3QYASABKAkSEAoIZGF0YVBvcnQYAiABKA0SFAoMY29tbWFuZF9wb3J0GAMgASgNEioKB3RpbWVvdXQYBCABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24iZQobQ29ubmVjdGlvblR5cGVTZXJpYWxSZmMyMjE3EgwKBGhvc3QYASABKAkSDAoEcG9ydBgCIAEoDRIqCgd0aW1lb3V0GAMgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uIqwBChtBcHBsaWNhdGlvblByb3RvY29sVGVtcGxhdGUSSQoIcHJvdG9jb2wYASABKA4yNy5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFwcGxpY2F0aW9uUHJvdG9jb2wSQgoKYXR0cmlidXRlcxgCIAMoCzIuLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuY29tbW9uLkZpZWxkRGVzY3JpcHRvciL3AQoQRGF0YUxpbmtUZW1wbGF0ZRJLCg1saW5rX3Byb3RvY29sGAEgASgOMjQuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5EYXRhTGlua1Byb3RvY29sElIKEWFwcF9wcm90b2NvbF9yZWZzGAIgAygOMjcuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5BcHBsaWNhdGlvblByb3RvY29sEkIKCmF0dHJpYnV0ZXMYAyADKAsyLi5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmNvbW1vbi5GaWVsZERlc2NyaXB0b3IipQEKFUNvbW11bmljYXRpb25UZW1wbGF0ZRJDCgR0eXBlGAEgASgOMjUuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5Db21tdW5pY2F0aW9uVHlwZRJHCglkYXRhbGlua3MYAiADKAsyNC5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkRhdGFMaW5rVGVtcGxhdGUiLwoTQWNjZXNzTGV2ZWxUZW1wbGF0ZRIKCgJpZBgBIAEoCRIMCgRuYW1lGAIgASgJIsEDCg9Ecml2ZXJUZW1wbGF0ZXMSWgoXY29tbXVuaWNhdGlvbl90ZW1wbGF0ZXMYASADKAsyOS5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkNvbW11bmljYXRpb25UZW1wbGF0ZRJWCg1hcHBfcHJvdG9jb2xzGAIgAygLMj8uaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5BcHBsaWNhdGlvblByb3RvY29sVGVtcGxhdGUSUgoRYWN0aW9uX2F0dHJpYnV0ZXMYAyADKAsyNy5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkpvYkFjdGlvbkF0dHJpYnV0ZXMSUQoQYWNjZXNzX3RlbXBsYXRlcxgEIAMoCzI3LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQWNjZXNzTGV2ZWxUZW1wbGF0ZRJTChJhY3Rpb25fY29uc3RyYWludHMYBSABKAsyNy5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkpvYkFjdGlvbkNvbnRyYWludHMiuwEKFEFjdGlvblByb2dyZXNzVXBkYXRlEg4KBmpvYl9pZBgBIAEoCRIRCglhY3Rpb25faWQYAiABKAkSQgoEY29kZRgDIAEoDjI0LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQWN0aW9uUmVzdWx0Q29kZRI8CgRkYXRhGAQgASgLMi4uaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5BY3Rpb25EYXRhIpABChFKb2JQcm9ncmVzc1VwZGF0ZRIOCgZqb2JfaWQYASABKAkSPgoEY29kZRgCIAEoDjIwLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uSm9iRXJyb3JDb2RlEisKCGR1cmF0aW9uGAMgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uIogECgpBY3Rpb25EYXRhEigKBm5vZGF0YRgBIAEoCzIWLmdvb2dsZS5wcm90b2J1Zi5FbXB0eUgAEkcKCXJlZ2lzdGVycxgCIAEoCzIyLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uUmVnaXN0ZXJWYWx1ZXNIABJECgdwcm9maWxlGAMgASgLMjEuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5Qcm9maWxlVmFsdWVzSAASVwoRaXJyZWd1bGFyX3Byb2ZpbGUYBCABKAsyOi5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLklycmVndWxhclByb2ZpbGVWYWx1ZXNIABJFCgtkZXZpY2VfaW5mbxgFIAEoCzIuLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uRGV2aWNlSW5mb0gAEkIKBmV2ZW50cxgGIAEoCzIwLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uRXZlbnRSZWNvcmRzSAASVQoJdG91X3RhYmxlGAcgASgLMkAuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi50aW1lb2Z1c2UuVGltZU9mVXNlVGFibGVTcGVjSABCBgoEZGF0YSJPCgxFdmVudFJlY29yZHMSPwoGdmFsdWVzGAEgAygLMi8uaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5FdmVudFJlY29yZCKMAQoLRXZlbnRSZWNvcmQSLQoJdGltZXN0YW1wGAEgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIQCghldmVudF9pZBgCIAEoAxISCgpldmVudF9jb2RlGAMgASgDEhQKDGV2ZW50X3NvdXJjZRgFIAEoCRISCgpldmVudF90ZXh0GAQgASgJIqoCCgpEZXZpY2VJbmZvEjIKDmluZm9fdGltZXN0YW1wGAEgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIiChptYW51ZmFjdHVyZXJfc2VyaWFsX251bWJlchgCIAEoCRIcChRkZXZpY2Vfc2VyaWFsX251bWJlchgDIAEoCRIYChBmaXJtd2FyZV92ZXJzaW9uGAQgASgJEi4KC2Nsb2NrX2RlbHRhGAUgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEhQKDGRldmljZV9tb2RlbBgGIAEoCRIWCg5lcnJvcl9yZWdpc3RlchgHIAEoBBIUCgxyZWxheV9zdGF0ZXMYCCADKAgSGAoQY29ubmVjdGlvbl9zdGF0ZRgJIAEoCCJvCg1Qcm9maWxlVmFsdWVzEg4KBnBlcmlvZBgBIAEoBRIMCgR1bml0GAIgASgJEkAKBmJsb2NrcxgDIAMoCzIwLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uUHJvZmlsZUJsb2NrImoKFklycmVndWxhclByb2ZpbGVWYWx1ZXMSDAoEdW5pdBgBIAEoCRJCCgZ2YWx1ZXMYAiADKAsyMi5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLklycmVndWxhclZhbHVlIoEBCg5JcnJlZ3VsYXJWYWx1ZRItCgl0aW1lc3RhbXAYASABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEkAKBXZhbHVlGAIgASgLMjEuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5NZWFzdXJlZFZhbHVlIoYBCgxQcm9maWxlQmxvY2sSMwoPc3RhcnRfdGltZXN0YW1wGAEgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBJBCgZ2YWx1ZXMYAiADKAsyMS5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLk1lYXN1cmVkVmFsdWUiUwoOUmVnaXN0ZXJWYWx1ZXMSQQoGdmFsdWVzGAEgAygLMjEuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5SZWdpc3RlclZhbHVlIo4BCg1SZWdpc3RlclZhbHVlEi0KCXRpbWVzdGFtcBgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASDAoEdW5pdBgCIAEoCRJACgV2YWx1ZRgDIAEoCzIxLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uTWVhc3VyZWRWYWx1ZSKrAgoNTWVhc3VyZWRWYWx1ZRIOCgZzdGF0dXMYASABKAMSEAoIZXhwb25lbnQYAiABKAUSFgoMZG91YmxlX3ZhbHVlGAMgASgBSAASFwoNaW50ZWdlcl92YWx1ZRgEIAEoA0gAEhYKDHN0cmluZ192YWx1ZRgFIAEoCUgAEjUKD3RpbWVzdGFtcF92YWx1ZRgGIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBIABIcChJ0aW1lc3RhbXBfdHpfdmFsdWUYByABKAlIABIUCgpib29sX3ZhbHVlGAggASgISAASDwoHbnN0YXR1cxgJIAEoBBIrCgdwZWFrX3RzGAogASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEIGCgRraW5kIpcBChNKb2JBY3Rpb25BdHRyaWJ1dGVzEjwKBHR5cGUYASABKA4yLi5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFjdGlvblR5cGUSQgoKYXR0cmlidXRlcxgCIAMoCzIuLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuY29tbW9uLkZpZWxkRGVzY3JpcHRvciKhAgoeQ29ubmVjdGlvblR5cGVDb250cm9sbGVkU2VyaWFsElAKBmRpcmVjdBgBIAEoCzI+LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQ29ubmVjdGlvblR5cGVTZXJpYWxEaXJlY3RIABJMCgRtb3hhGAIgASgLMjwuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5Db25uZWN0aW9uVHlwZVNlcmlhbE1veGFIABJSCgdyZmMyMjE3GAMgASgLMj8uaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5Db25uZWN0aW9uVHlwZVNlcmlhbFJmYzIyMTdIAEILCgljb252ZXJ0ZXIiEwoRQWN0aW9uR2V0UmVnaXN0ZXIibgoaQWN0aW9uR2V0UGVyaW9kaWNhbFByb2ZpbGUSKAoEZnJvbRgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASJgoCdG8YAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wIm0KGUFjdGlvbkdldElycmVndWxhclByb2ZpbGUSKAoEZnJvbRgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASJgoCdG8YAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wImMKD0FjdGlvbkdldEV2ZW50cxIoCgRmcm9tGAEgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBImCgJ0bxgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAiFQoTQWN0aW9uR2V0RGV2aWNlSW5mbyIRCg9BY3Rpb25TeW5jQ2xvY2siFQoTQWN0aW9uU2V0UmVsYXlTdGF0ZSIcChpBY3Rpb25TZXREaXNjb25uZWN0b3JTdGF0ZSIfCgxBY3Rpb25HZXRUb3USDwoHcGFzc2l2ZRgBIAEoCCJfCgxBY3Rpb25TZXRUb3USTwoFdGFibGUYASABKAsyQC5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLnRpbWVvZnVzZS5UaW1lT2ZVc2VUYWJsZVNwZWMiEgoQQWN0aW9uU2V0TGltaXRlciIaChhBY3Rpb25SZXNldEJpbGxpbmdQZXJpb2QiEAoOQWN0aW9uRndVcGRhdGUisAMKE0pvYkFjdGlvbkNvbnRyYWludHMScAoWZ2V0X3JlZ2lzdGVyX3R5cGVfbmFtZRgBIAMoCzJQLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uSm9iQWN0aW9uQ29udHJhaW50cy5HZXRSZWdpc3RlclR5cGVOYW1lRW50cnkSfAocZ2V0X3JlZ2lzdGVyX3R5cGVfYXR0cmlidXRlcxgCIAMoCzJWLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uSm9iQWN0aW9uQ29udHJhaW50cy5HZXRSZWdpc3RlclR5cGVBdHRyaWJ1dGVzRW50cnkaOgoYR2V0UmVnaXN0ZXJUeXBlTmFtZUVudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEabQoeR2V0UmVnaXN0ZXJUeXBlQXR0cmlidXRlc0VudHJ5EgsKA2tleRgBIAEoCRI6CgV2YWx1ZRgCIAEoCzIrLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuY29tbW9uLkxpc3RPZlN0cmluZzoCOAEioAMKCUpvYlN0YXR1cxJBCgZzdGF0dXMYASABKA4yMS5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkpvYlN0YXR1c0NvZGUSPgoEY29kZRgCIAEoDjIwLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uSm9iRXJyb3JDb2RlEkEKB3Jlc3VsdHMYAyADKAsyMC5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFjdGlvblJlc3VsdBIuCgpzdGFydGVkX2F0GAQgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIvCgtmaW5pc2hlZF9hdBgFIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASFQoNYXR0ZW1wdHNfZG9uZRgGIAEoBRJDCgtkZXZpY2VfaW5mbxgHIAEoCzIuLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uRGV2aWNlSW5mbxIQCghxdWV1ZV9pZBgIIAEoAyLRAwoMU3RhcnRKb2JEYXRhEmEKEWRldmljZV9hdHRyaWJ1dGVzGAEgAygLMkYuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5TdGFydEpvYkRhdGEuRGV2aWNlQXR0cmlidXRlc0VudHJ5Eg4KBmpvYl9pZBgCIAEoCRJFCgxqb2Jfc2V0dGluZ3MYAyABKAsyLy5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkpvYlNldHRpbmdzEkIKC2pvYl9hY3Rpb25zGAQgAygLMi0uaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5Kb2JBY3Rpb24STQoMYXBwX3Byb3RvY29sGAUgASgOMjcuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5BcHBsaWNhdGlvblByb3RvY29sEhAKCHRpbWV6b25lGAYgASgJGmIKFURldmljZUF0dHJpYnV0ZXNFbnRyeRILCgNrZXkYASABKAkSOAoFdmFsdWUYAiABKAsyKS5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmNvbW1vbi5GaWVsZFZhbHVlOgI4ASIiChBDYW5jZWxKb2JSZXF1ZXN0Eg4KBmpvYl9pZBgBIAEoCSLGAgofRGV2aWNlQ29uZmlndXJhdGlvblJlZ2lzdGVyU3BlYxITCgtkcml2ZXJfdHlwZRgBIAEoCRJHCg1yZWdpc3Rlcl90eXBlGAIgASgOMjAuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5SZWdpc3RlclR5cGUSZwoKYXR0cmlidXRlcxgDIAMoCzJTLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uRGV2aWNlQ29uZmlndXJhdGlvblJlZ2lzdGVyU3BlYy5BdHRyaWJ1dGVzRW50cnkaXAoPQXR0cmlidXRlc0VudHJ5EgsKA2tleRgBIAEoCRI4CgV2YWx1ZRgCIAEoCzIpLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuY29tbW9uLkZpZWxkVmFsdWU6AjgBIqsBCg5EZXZpY2VSZWdpc3RlchITCgtyZWdpc3Rlcl9pZBgBIAEoAxIaChJwdWJsaWNfcmVnaXN0ZXJfaWQYAiABKAkSUQoEc3BlYxgDIAEoCzJDLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uRGV2aWNlQ29uZmlndXJhdGlvblJlZ2lzdGVyU3BlYxIVCg12YXJpYWJsZV9uYW1lGAQgAygJIooEChREZXZpY2VDb25uZWN0aW9uSW5mbxJOChJjb21tdW5pY2F0aW9uX3VuaXQYASABKAsyMi5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkNvbm5lY3Rpb25JbmZvEk0KDGFwcF9wcm90b2NvbBgCIAEoDjI3LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQXBwbGljYXRpb25Qcm90b2NvbBJpChFkZXZpY2VfYXR0cmlidXRlcxgDIAMoCzJOLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uRGV2aWNlQ29ubmVjdGlvbkluZm8uRGV2aWNlQXR0cmlidXRlc0VudHJ5EhAKCHRpbWV6b25lGAQgASgJEhMKC2RyaXZlcl90eXBlGAUgASgJEhYKDmRyaXZlcl92ZXJzaW9uGAcgASgJEkUKCXJlZ2lzdGVycxgIIAMoCzIyLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uRGV2aWNlUmVnaXN0ZXIaYgoVRGV2aWNlQXR0cmlidXRlc0VudHJ5EgsKA2tleRgBIAEoCRI4CgV2YWx1ZRgCIAEoCzIpLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuY29tbW9uLkZpZWxkVmFsdWU6AjgBImQKD0xpc3RPZk1vZGVtSW5mbxI8CgVpdGVtcxgBIAMoCzItLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uTW9kZW1JbmZvEhMKC3RvdGFsX2NvdW50GAIgASgFInQKFExpc3RPZkNvbm5lY3Rpb25JbmZvEkcKBWl0ZW1zGAEgAygLMjguaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5EZXZpY2VDb25uZWN0aW9uSW5mbxITCgt0b3RhbF9jb3VudBgCIAEoBSJMCg9GaWVsZFZhbHVlc0xpc3QSOQoFaXRlbXMYASADKAsyKi5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmNvbW1vbi5GaWVsZFZhbHVlcyJZChdPYmplY3RBdHRyaWJ1dGVTZWxlY3RvchI+CgphdHRyaWJ1dGVzGAEgASgLMiouaW8uY2xicy5vcGVuaGVzLm1vZGVscy5jb21tb24uRmllbGRWYWx1ZXMi0QEKDEFjdGlvblJlc3VsdBIRCglhY3Rpb25faWQYASABKAkSRAoGc3RhdHVzGAIgASgOMjQuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5BY3Rpb25SZXN1bHRDb2RlEjwKBGRhdGEYAyABKAsyLi5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFjdGlvbkRhdGESEwoLcmVnaXN0ZXJfaWQYBCABKAkSFQoNdmFyaWFibGVfbmFtZRgFIAMoCSIeCgxKb2JFdmVudERhdGESDgoGam9iX2lkGAEgASgMIqEBCgpEZXZpY2VTcGVjEg4KBmRjdF9pZBgBIAEoCRITCgtleHRlcm5hbF9pZBgCIAEoCRJcChdjb21tdW5pY2F0aW9uX3VuaXRfbGluaxgDIAMoCzI7LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uRGV2aWNlQ29tbXVuaWNhdGlvblVuaXQSEAoIdGltZXpvbmUYBCABKAkiYQoMRGV2aWNlU3RhdHVzEjwKBGluZm8YASABKAsyLi5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkRldmljZUluZm8SEwoLZHJpdmVyX3R5cGUYAiABKAkixgIKF0RldmljZUNvbW11bmljYXRpb25Vbml0Eh0KFWNvbW11bmljYXRpb25fdW5pdF9pZBgBIAEoCRJNCgxhcHBfcHJvdG9jb2wYAiABKA4yNy5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFwcGxpY2F0aW9uUHJvdG9jb2wSXwoKYXR0cmlidXRlcxgDIAMoCzJLLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uRGV2aWNlQ29tbXVuaWNhdGlvblVuaXQuQXR0cmlidXRlc0VudHJ5GlwKD0F0dHJpYnV0ZXNFbnRyeRILCgNrZXkYASABKAkSOAoFdmFsdWUYAiABKAsyKS5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmNvbW1vbi5GaWVsZFZhbHVlOgI4ASK5AgoHSm9iU3BlYxI9CgZkZXZpY2UYAiABKAsyLS5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkpvYkRldmljZRJFCgxqb2Jfc2V0dGluZ3MYAyABKAsyLy5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkpvYlNldHRpbmdzEhMKC2RyaXZlcl90eXBlGAQgASgJEkIKC2pvYl9hY3Rpb25zGAUgAygLMi0uaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5Kb2JBY3Rpb24STwoPam9iX2FjdGlvbl9pbmZvGAYgAygLMjYuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5Kb2JBY3Rpb25NYXBSZWNvcmQicgoSSm9iQWN0aW9uTWFwUmVjb3JkEhQKDGFjdGlvbl9pbmRleBgBIAEoBRITCgtyZWdpc3Rlcl9pZBgDIAEoAxIaChJwdWJsaWNfcmVnaXN0ZXJfaWQYAiABKAkSFQoNdmFyaWFibGVfbmFtZRgEIAMoCSKPAQoTSm9iRG9uZU5vdGlmaWNhdGlvbhI5CgRzcGVjGAEgASgLMisuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5Kb2JTcGVjEj0KBnN0YXR1cxgCIAEoCzItLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uSm9iU3RhdHVzIjIKCkRyaXZlckluZm8SEwoLZHJpdmVyX3R5cGUYASABKAkSDwoHdmVyc2lvbhgCIAEoCSKjAQoRQ29tbXVuaWNhdGlvblVuaXQSRwoEc3BlYxgBIAEoCzI5LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQ29tbXVuaWNhdGlvblVuaXRTcGVjEj8KCG1ldGFkYXRhGAMgASgLMi0uaW8uY2xicy5vcGVuaGVzLm1vZGVscy5jb21tb24uTWV0YWRhdGFGaWVsZHNKBAgCEAMieQoVQ29tbXVuaWNhdGlvblVuaXRTcGVjEhMKC2V4dGVybmFsX2lkGAEgASgJEksKD2Nvbm5lY3Rpb25faW5mbxgCIAEoCzIyLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQ29ubmVjdGlvbkluZm8ipQEKEENvbW11bmljYXRpb25CdXMSSgoGc3RhdHVzGAIgASgLMjouaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5Db21tdW5pY2F0aW9uQnVzU3RhdHVzEj8KCG1ldGFkYXRhGAMgASgLMi0uaW8uY2xicy5vcGVuaGVzLm1vZGVscy5jb21tb24uTWV0YWRhdGFGaWVsZHNKBAgBEAIiNwoWQ29tbXVuaWNhdGlvbkJ1c1N0YXR1cxIdChVjb21tdW5pY2F0aW9uX3VuaXRfaWQYASADKAkqwQEKC0pvYlByaW9yaXR5EhIKDkpPQl9QUklPUklUWV8wEAASEgoOSk9CX1BSSU9SSVRZXzEQARISCg5KT0JfUFJJT1JJVFlfMhACEhIKDkpPQl9QUklPUklUWV8zEAMSEgoOSk9CX1BSSU9SSVRZXzQQBBISCg5KT0JfUFJJT1JJVFlfNRAFEhIKDkpPQl9QUklPUklUWV82EAYSEgoOSk9CX1BSSU9SSVRZXzcQBxISCg5KT0JfUFJJT1JJVFlfOBAIKmkKElNlcmlhbENvbmZpZ1Bhcml0eRIPCgtQQVJJVFlfTk9ORRAAEg8KC1BBUklUWV9FVkVOEAESDgoKUEFSSVRZX09ERBACEg8KC1BBUklUWV9NQVJLEAMSEAoMUEFSSVRZX1NQQUNFEAQqywIKFFNlcmlhbENvbmZpZ0JhdWRSYXRlEhEKDUJBVURfUkFURV8xMTAQABIRCg1CQVVEX1JBVEVfMzAwEAESEQoNQkFVRF9SQVRFXzYwMBACEhIKDkJBVURfUkFURV8xMjAwEAMSEgoOQkFVRF9SQVRFXzI0MDAQBBISCg5CQVVEX1JBVEVfNDgwMBAFEhIKDkJBVURfUkFURV85NjAwEAYSEwoPQkFVRF9SQVRFXzE0NDAwEAcSEwoPQkFVRF9SQVRFXzE5MjAwEAgSEwoPQkFVRF9SQVRFXzM4NDAwEAkSEwoPQkFVRF9SQVRFXzU3NjAwEAoSFAoQQkFVRF9SQVRFXzExNTIwMBALEhQKEEJBVURfUkFURV8yMzA0MDAQDBIUChBCQVVEX1JBVEVfNDYwODAwEA0SFAoQQkFVRF9SQVRFXzkyMTYwMBAOKloKFFNlcmlhbENvbmZpZ0RhdGFCaXRzEg8KC0RBVEFfQklUU181EAASDwoLREFUQV9CSVRTXzYQARIPCgtEQVRBX0JJVFNfNxACEg8KC0RBVEFfQklUU184EAMqSwoUU2VyaWFsQ29uZmlnU3RvcEJpdHMSDwoLU1RPUF9CSVRTXzEQABIRCg1TVE9QX0JJVFNfMV81EAESDwoLU1RPUF9CSVRTXzIQAirKAQoRQ29tbXVuaWNhdGlvblR5cGUSHAoYQ09NTVVOSUNBVElPTl9UWVBFX1RDUElQEAASIQodQ09NTVVOSUNBVElPTl9UWVBFX01PREVNX1BPT0wQARIpCiVDT01NVU5JQ0FUSU9OX1RZUEVfU0VSSUFMX0xJTkVfRElSRUNUEAISJwojQ09NTVVOSUNBVElPTl9UWVBFX1NFUklBTF9MSU5FX01PWEEQAxIgChxDT01NVU5JQ0FUSU9OX1RZUEVfTElTVEVOSU5HEGMqvQEKEERhdGFMaW5rUHJvdG9jb2wSGgoWTElOS1BST1RPX0lFQ182MjA1Nl8yMRAAEhIKDkxJTktQUk9UT19IRExDEAESGwoXTElOS1BST1RPX0NPU0VNX1dSQVBQRVIQAhIUChBMSU5LUFJPVE9fTU9EQlVTEAMSEgoOTElOS1BST1RPX01CVVMQBBIUChBMSU5LUFJPVE9fVklLVE9SEAUSHAoYTElOS1BST1RPX05PVF9BUFBMSUNBQkxFEGMqrgEKE0FwcGxpY2F0aW9uUHJvdG9jb2wSGQoVQVBQUFJPVE9fSUVDXzYyMDU2XzIxEAASFAoQQVBQUFJPVE9fRExNU19TThABEhQKEEFQUFBST1RPX0RMTVNfTE4QAhIRCg1BUFBQUk9UT19TQ1RNEAMSEwoPQVBQUFJPVE9fTElTMjAwEAQSFQoRQVBQUFJPVE9fQU5TSV9DMTIQBRIRCg1BUFBQUk9UT19NUVRUEAYq0wMKCkFjdGlvblR5cGUSHAoYQUNUSU9OX1RZUEVfR0VUX1JFR0lTVEVSEAASJgoiQUNUSU9OX1RZUEVfR0VUX1BFUklPRElDQUxfUFJPRklMRRABEiUKIUFDVElPTl9UWVBFX0dFVF9JUlJFR1VMQVJfUFJPRklMRRACEhoKFkFDVElPTl9UWVBFX0dFVF9FVkVOVFMQAxIfChtBQ1RJT05fVFlQRV9HRVRfREVWSUNFX0lORk8QChIaChZBQ1RJT05fVFlQRV9TWU5DX0NMT0NLEAsSHwobQUNUSU9OX1RZUEVfU0VUX1JFTEFZX1NUQVRFEBUSJgoiQUNUSU9OX1RZUEVfR0VUX0RJU0NPTk5FQ1RPUl9TVEFURRAWEiYKIkFDVElPTl9UWVBFX1NFVF9ESVNDT05ORUNUT1JfU1RBVEUQFxIXChNBQ1RJT05fVFlQRV9HRVRfVE9VEBgSFwoTQUNUSU9OX1RZUEVfU0VUX1RPVRAZEhsKF0FDVElPTl9UWVBFX1NFVF9MSU1JVEVSEBsSJAogQUNUSU9OX1RZUEVfUkVTRVRfQklMTElOR19QRVJJT0QQKBIZChVBQ1RJT05fVFlQRV9GV19VUERBVEUQMiqLAQoQQWN0aW9uUmVzdWx0Q29kZRIYChRFUlJPUl9DT0RFX0FDVElPTl9PSxAAEiEKHUVSUk9SX0NPREVfQUNUSU9OX1VOU1VQUE9SVEVEEAESHQoZRVJST1JfQ09ERV9BQ1RJT05fUEVORElORxADEhsKF0VSUk9SX0NPREVfQUNUSU9OX0VSUk9SEAUqlwEKDEpvYkVycm9yQ29kZRIXChNKT0JfRVJST1JfQ09ERV9OT05FEAASFwoTSk9CX0VSUk9SX0NPREVfQlVTWRABEhgKFEpPQl9FUlJPUl9DT0RFX0VSUk9SEAUSIQodSk9CX0VSUk9SX0NPREVfQUxSRUFEWV9FWElTVFMQCBIYChRKT0JfRVJST1JfQ09ERV9GQVRBTBAJKpABCg5CdWxrU3RhdHVzQ29kZRIWChJCVUxLX1NUQVRVU19RVUVVRUQQABIXChNCVUxLX1NUQVRVU19SVU5OSU5HEAESGQoVQlVMS19TVEFUVVNfQ09NUExFVEVEEAISGQoVQlVMS19TVEFUVVNfQ0FOQ0VMTEVEEAMSFwoTQlVMS19TVEFUVVNfRVhQSVJFRBAEKlgKDFJlZ2lzdGVyVHlwZRIMCghSZWdpc3RlchAAEhUKEVBlcmlvZGljYWxQcm9maWxlEAESFAoQSXJyZWd1bGFyUHJvZmlsZRACEg0KCVN5bnRoZXRpYxBjKsEBCg1Kb2JTdGF0dXNDb2RlEhUKEUpPQl9TVEFUVVNfUVVFVUVEEAASFgoSSk9CX1NUQVRVU19SVU5OSU5HEAESHgoaSk9CX1NUQVRVU19QUk9DRVNTSU5HX0RBVEEQAhIYChRKT0JfU1RBVFVTX0NPTVBMRVRFRBADEhUKEUpPQl9TVEFUVVNfRkFJTEVEEAQSGAoUSk9CX1NUQVRVU19DQU5DRUxMRUQQBRIWChJKT0JfU1RBVFVTX0VYUElSRUQQBkI6WjhnaXRodWIuY29tL2N5YnJvc2xhYnMvb3Vyby1hcGktc2hhcmVkL2dlbi9nby9hY3F1aXNpdGlvbmIIZWRpdGlvbnNw6Ac", [file_google_protobuf_empty, file_google_protobuf_struct, file_google_protobuf_timestamp, file_google_protobuf_duration, file_common_fields, file_common_metadata, file_common_types, file_acquisition_timeofuse_timeofuse]);

/**
 * Sub-message containing job parameters
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobSettings
 */
export type JobSettings = Message<"io.clbs.openhes.models.acquisition.JobSettings"> & {
  /**
   * Maximum duration of the job attempt. This is related to the real time for the driver.
   *
   * @generated from field: google.protobuf.Duration max_duration = 1;
   */
  maxDuration?: Duration;

  /**
   * Priority of the job.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobPriority priority = 2;
   */
  priority: JobPriority;

  /**
   * Maximum number of attempts, 1 is the minimum.
   *
   * @generated from field: repeated int32 attempts = 3;
   */
  attempts: number[];

  /**
   * Delay between two attempts.
   *
   * @generated from field: google.protobuf.Duration retry_delay = 4;
   */
  retryDelay?: Duration;

  /**
   * Time to wait before starting the job.
   *
   * @generated from field: google.protobuf.Duration defer_start = 5;
   */
  deferStart?: Duration;

  /**
   * The timestamp when the job expires.
   *
   * @generated from field: google.protobuf.Timestamp expires_at = 6;
   */
  expiresAt?: Timestamp;
};

/**
 * Sub-message containing job parameters
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobSettings
 */
export type JobSettingsJson = {
  /**
   * Maximum duration of the job attempt. This is related to the real time for the driver.
   *
   * @generated from field: google.protobuf.Duration max_duration = 1;
   */
  maxDuration?: DurationJson;

  /**
   * Priority of the job.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobPriority priority = 2;
   */
  priority?: JobPriorityJson;

  /**
   * Maximum number of attempts, 1 is the minimum.
   *
   * @generated from field: repeated int32 attempts = 3;
   */
  attempts?: number[];

  /**
   * Delay between two attempts.
   *
   * @generated from field: google.protobuf.Duration retry_delay = 4;
   */
  retryDelay?: DurationJson;

  /**
   * Time to wait before starting the job.
   *
   * @generated from field: google.protobuf.Duration defer_start = 5;
   */
  deferStart?: DurationJson;

  /**
   * The timestamp when the job expires.
   *
   * @generated from field: google.protobuf.Timestamp expires_at = 6;
   */
  expiresAt?: TimestampJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.JobSettings.
 * Use `create(JobSettingsSchema)` to create a new message.
 */
export const JobSettingsSchema: GenMessage<JobSettings, {jsonType: JobSettingsJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 0);

/**
 * Sub-message containing job action specification.
 * The JobAction is used to define a single action to be performed on a single device.
 * For example, if the JobAction is of the ActionGetRegister type then it specifies single register to be read from the devices.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobAction
 */
export type JobAction = Message<"io.clbs.openhes.models.acquisition.JobAction"> & {
  /**
   * The action identifier.
   *
   * @generated from field: string action_id = 1;
   */
  actionId: string;

  /**
   * The action attributes.
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.FieldValue> attributes = 2;
   */
  attributes: { [key: string]: FieldValue };

  /**
   * @generated from oneof io.clbs.openhes.models.acquisition.JobAction.action
   */
  action: {
    /**
     * The get register action specification.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionGetRegister get_register = 3;
     */
    value: ActionGetRegister;
    case: "getRegister";
  } | {
    /**
     * The get periodical profile action specification.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionGetPeriodicalProfile get_periodical_profile = 4;
     */
    value: ActionGetPeriodicalProfile;
    case: "getPeriodicalProfile";
  } | {
    /**
     * The get irregular profile action specification.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionGetIrregularProfile get_irregular_profile = 5;
     */
    value: ActionGetIrregularProfile;
    case: "getIrregularProfile";
  } | {
    /**
     * The get events action specification.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionGetEvents get_events = 6;
     */
    value: ActionGetEvents;
    case: "getEvents";
  } | {
    /**
     * The get device info action specification.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionGetDeviceInfo get_device_info = 7;
     */
    value: ActionGetDeviceInfo;
    case: "getDeviceInfo";
  } | {
    /**
     * The sync clock action specification.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionSyncClock sync_clock = 8;
     */
    value: ActionSyncClock;
    case: "syncClock";
  } | {
    /**
     * The set relay state action specification.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionSetRelayState set_relay_state = 10;
     */
    value: ActionSetRelayState;
    case: "setRelayState";
  } | {
    /**
     * The set disconnector state action specification.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionSetDisconnectorState set_disconnector_state = 12;
     */
    value: ActionSetDisconnectorState;
    case: "setDisconnectorState";
  } | {
    /**
     * The get tou action specification.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionGetTou get_tou = 13;
     */
    value: ActionGetTou;
    case: "getTou";
  } | {
    /**
     * The set tou action specification.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionSetTou set_tou = 14;
     */
    value: ActionSetTou;
    case: "setTou";
  } | {
    /**
     * The set limiter action specification.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionSetLimiter set_limiter = 16;
     */
    value: ActionSetLimiter;
    case: "setLimiter";
  } | {
    /**
     * The reset billing period action specification.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionResetBillingPeriod reset_billing_period = 17;
     */
    value: ActionResetBillingPeriod;
    case: "resetBillingPeriod";
  } | {
    /**
     * The firmware update action specification.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionFwUpdate fw_update = 18;
     */
    value: ActionFwUpdate;
    case: "fwUpdate";
  } | { case: undefined; value?: undefined };
};

/**
 * Sub-message containing job action specification.
 * The JobAction is used to define a single action to be performed on a single device.
 * For example, if the JobAction is of the ActionGetRegister type then it specifies single register to be read from the devices.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobAction
 */
export type JobActionJson = {
  /**
   * The action identifier.
   *
   * @generated from field: string action_id = 1;
   */
  actionId?: string;

  /**
   * The action attributes.
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.FieldValue> attributes = 2;
   */
  attributes?: { [key: string]: FieldValueJson };

  /**
   * The get register action specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionGetRegister get_register = 3;
   */
  getRegister?: ActionGetRegisterJson;

  /**
   * The get periodical profile action specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionGetPeriodicalProfile get_periodical_profile = 4;
   */
  getPeriodicalProfile?: ActionGetPeriodicalProfileJson;

  /**
   * The get irregular profile action specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionGetIrregularProfile get_irregular_profile = 5;
   */
  getIrregularProfile?: ActionGetIrregularProfileJson;

  /**
   * The get events action specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionGetEvents get_events = 6;
   */
  getEvents?: ActionGetEventsJson;

  /**
   * The get device info action specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionGetDeviceInfo get_device_info = 7;
   */
  getDeviceInfo?: ActionGetDeviceInfoJson;

  /**
   * The sync clock action specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionSyncClock sync_clock = 8;
   */
  syncClock?: ActionSyncClockJson;

  /**
   * The set relay state action specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionSetRelayState set_relay_state = 10;
   */
  setRelayState?: ActionSetRelayStateJson;

  /**
   * The set disconnector state action specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionSetDisconnectorState set_disconnector_state = 12;
   */
  setDisconnectorState?: ActionSetDisconnectorStateJson;

  /**
   * The get tou action specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionGetTou get_tou = 13;
   */
  getTou?: ActionGetTouJson;

  /**
   * The set tou action specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionSetTou set_tou = 14;
   */
  setTou?: ActionSetTouJson;

  /**
   * The set limiter action specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionSetLimiter set_limiter = 16;
   */
  setLimiter?: ActionSetLimiterJson;

  /**
   * The reset billing period action specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionResetBillingPeriod reset_billing_period = 17;
   */
  resetBillingPeriod?: ActionResetBillingPeriodJson;

  /**
   * The firmware update action specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionFwUpdate fw_update = 18;
   */
  fwUpdate?: ActionFwUpdateJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.JobAction.
 * Use `create(JobActionSchema)` to create a new message.
 */
export const JobActionSchema: GenMessage<JobAction, {jsonType: JobActionJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 1);

/**
 * Sub-message containing job action set specification.
 * In comparison the JobAction shall be used only once per bulk but internally it may cover multiple JobActions.
 * For example, if the JobActionSet is of the ActionGetRegister type and no variables filter is set
 * then then system gets all registers defined for active device configuration template and reads them all.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobActionSet
 */
export type JobActionSet = Message<"io.clbs.openhes.models.acquisition.JobActionSet"> & {
  /**
   * The filter, meaning depends on the action.
   * - GetRegister, GetPeriodicalProfile and GetIrregularProfile: It's the list of variable identifiers, e.g. "A+" defined in the system. If not set then all variables are read.
   * - Others: Not applicable, ignored.
   *
   * @generated from field: repeated string variables = 2;
   */
  variables: string[];

  /**
   * @generated from oneof io.clbs.openhes.models.acquisition.JobActionSet.action
   */
  action: {
    /**
     * The get register action specification.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionGetRegister get_register = 3;
     */
    value: ActionGetRegister;
    case: "getRegister";
  } | {
    /**
     * The get periodical profile action specification.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionGetPeriodicalProfile get_periodical_profile = 4;
     */
    value: ActionGetPeriodicalProfile;
    case: "getPeriodicalProfile";
  } | {
    /**
     * The get irregular profile action specification.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionGetIrregularProfile get_irregular_profile = 5;
     */
    value: ActionGetIrregularProfile;
    case: "getIrregularProfile";
  } | {
    /**
     * The get events action specification.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionGetEvents get_events = 6;
     */
    value: ActionGetEvents;
    case: "getEvents";
  } | {
    /**
     * The get device info action specification.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionGetDeviceInfo get_device_info = 7;
     */
    value: ActionGetDeviceInfo;
    case: "getDeviceInfo";
  } | {
    /**
     * The sync clock action specification.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionSyncClock sync_clock = 8;
     */
    value: ActionSyncClock;
    case: "syncClock";
  } | {
    /**
     * The set relay state action specification.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionSetRelayState set_relay_state = 10;
     */
    value: ActionSetRelayState;
    case: "setRelayState";
  } | {
    /**
     * The set disconnector state action specification.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionSetDisconnectorState set_disconnector_state = 12;
     */
    value: ActionSetDisconnectorState;
    case: "setDisconnectorState";
  } | {
    /**
     * The get tou action specification.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionGetTou get_tou = 13;
     */
    value: ActionGetTou;
    case: "getTou";
  } | {
    /**
     * The set tou action specification.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionSetTou set_tou = 14;
     */
    value: ActionSetTou;
    case: "setTou";
  } | {
    /**
     * The set limiter action specification.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionSetLimiter set_limiter = 16;
     */
    value: ActionSetLimiter;
    case: "setLimiter";
  } | {
    /**
     * The reset billing period action specification.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionResetBillingPeriod reset_billing_period = 17;
     */
    value: ActionResetBillingPeriod;
    case: "resetBillingPeriod";
  } | {
    /**
     * The firmware update action specification.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionFwUpdate fw_update = 18;
     */
    value: ActionFwUpdate;
    case: "fwUpdate";
  } | { case: undefined; value?: undefined };
};

/**
 * Sub-message containing job action set specification.
 * In comparison the JobAction shall be used only once per bulk but internally it may cover multiple JobActions.
 * For example, if the JobActionSet is of the ActionGetRegister type and no variables filter is set
 * then then system gets all registers defined for active device configuration template and reads them all.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobActionSet
 */
export type JobActionSetJson = {
  /**
   * The filter, meaning depends on the action.
   * - GetRegister, GetPeriodicalProfile and GetIrregularProfile: It's the list of variable identifiers, e.g. "A+" defined in the system. If not set then all variables are read.
   * - Others: Not applicable, ignored.
   *
   * @generated from field: repeated string variables = 2;
   */
  variables?: string[];

  /**
   * The get register action specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionGetRegister get_register = 3;
   */
  getRegister?: ActionGetRegisterJson;

  /**
   * The get periodical profile action specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionGetPeriodicalProfile get_periodical_profile = 4;
   */
  getPeriodicalProfile?: ActionGetPeriodicalProfileJson;

  /**
   * The get irregular profile action specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionGetIrregularProfile get_irregular_profile = 5;
   */
  getIrregularProfile?: ActionGetIrregularProfileJson;

  /**
   * The get events action specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionGetEvents get_events = 6;
   */
  getEvents?: ActionGetEventsJson;

  /**
   * The get device info action specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionGetDeviceInfo get_device_info = 7;
   */
  getDeviceInfo?: ActionGetDeviceInfoJson;

  /**
   * The sync clock action specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionSyncClock sync_clock = 8;
   */
  syncClock?: ActionSyncClockJson;

  /**
   * The set relay state action specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionSetRelayState set_relay_state = 10;
   */
  setRelayState?: ActionSetRelayStateJson;

  /**
   * The set disconnector state action specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionSetDisconnectorState set_disconnector_state = 12;
   */
  setDisconnectorState?: ActionSetDisconnectorStateJson;

  /**
   * The get tou action specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionGetTou get_tou = 13;
   */
  getTou?: ActionGetTouJson;

  /**
   * The set tou action specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionSetTou set_tou = 14;
   */
  setTou?: ActionSetTouJson;

  /**
   * The set limiter action specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionSetLimiter set_limiter = 16;
   */
  setLimiter?: ActionSetLimiterJson;

  /**
   * The reset billing period action specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionResetBillingPeriod reset_billing_period = 17;
   */
  resetBillingPeriod?: ActionResetBillingPeriodJson;

  /**
   * The firmware update action specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionFwUpdate fw_update = 18;
   */
  fwUpdate?: ActionFwUpdateJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.JobActionSet.
 * Use `create(JobActionSetSchema)` to create a new message.
 */
export const JobActionSetSchema: GenMessage<JobActionSet, {jsonType: JobActionSetJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 2);

/**
 * @generated from message io.clbs.openhes.models.acquisition.ListOfJobDevice
 */
export type ListOfJobDevice = Message<"io.clbs.openhes.models.acquisition.ListOfJobDevice"> & {
  /**
   * The list of devices in the bulk.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.JobDevice list = 1;
   */
  list: JobDevice[];

  /**
   * The total number of items.
   *
   * @generated from field: int32 total_count = 2;
   */
  totalCount: number;
};

/**
 * @generated from message io.clbs.openhes.models.acquisition.ListOfJobDevice
 */
export type ListOfJobDeviceJson = {
  /**
   * The list of devices in the bulk.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.JobDevice list = 1;
   */
  list?: JobDeviceJson[];

  /**
   * The total number of items.
   *
   * @generated from field: int32 total_count = 2;
   */
  totalCount?: number;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ListOfJobDevice.
 * Use `create(ListOfJobDeviceSchema)` to create a new message.
 */
export const ListOfJobDeviceSchema: GenMessage<ListOfJobDevice, {jsonType: ListOfJobDeviceJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 3);

/**
 * @generated from message io.clbs.openhes.models.acquisition.ListOfJobDeviceId
 */
export type ListOfJobDeviceId = Message<"io.clbs.openhes.models.acquisition.ListOfJobDeviceId"> & {
  /**
   * The list of devices in the bulk.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.JobDeviceId list = 1;
   */
  list: JobDeviceId[];

  /**
   * The total number of items.
   *
   * @generated from field: int32 total_count = 2;
   */
  totalCount: number;
};

/**
 * @generated from message io.clbs.openhes.models.acquisition.ListOfJobDeviceId
 */
export type ListOfJobDeviceIdJson = {
  /**
   * The list of devices in the bulk.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.JobDeviceId list = 1;
   */
  list?: JobDeviceIdJson[];

  /**
   * The total number of items.
   *
   * @generated from field: int32 total_count = 2;
   */
  totalCount?: number;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ListOfJobDeviceId.
 * Use `create(ListOfJobDeviceIdSchema)` to create a new message.
 */
export const ListOfJobDeviceIdSchema: GenMessage<ListOfJobDeviceId, {jsonType: ListOfJobDeviceIdJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 4);

/**
 * @generated from message io.clbs.openhes.models.acquisition.JobDeviceId
 */
export type JobDeviceId = Message<"io.clbs.openhes.models.acquisition.JobDeviceId"> & {
  /**
   * The device's job identifier within the parent bulk.
   *
   * @generated from field: string job_id = 1;
   */
  jobId: string;

  /**
   * The device identifier.
   *
   * @generated from field: string device_id = 2;
   */
  deviceId: string;
};

/**
 * @generated from message io.clbs.openhes.models.acquisition.JobDeviceId
 */
export type JobDeviceIdJson = {
  /**
   * The device's job identifier within the parent bulk.
   *
   * @generated from field: string job_id = 1;
   */
  jobId?: string;

  /**
   * The device identifier.
   *
   * @generated from field: string device_id = 2;
   */
  deviceId?: string;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.JobDeviceId.
 * Use `create(JobDeviceIdSchema)` to create a new message.
 */
export const JobDeviceIdSchema: GenMessage<JobDeviceId, {jsonType: JobDeviceIdJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 5);

/**
 * Sub-message representing a single job-device info.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobDevice
 */
export type JobDevice = Message<"io.clbs.openhes.models.acquisition.JobDevice"> & {
  /**
   * The device's job identifier within the parent bulk.
   *
   * @generated from field: string job_id = 1;
   */
  jobId: string;

  /**
   * The device identifier. If set then all below is loaded from the device registry.
   *
   * @generated from field: string device_id = 2;
   */
  deviceId: string;

  /**
   * The external identifier.
   *
   * @generated from field: string external_id = 3;
   */
  externalId: string;

  /**
   * The connection attributes to the device, see options in the ApplicationProtocolTemplate for given application protocol (see app_protocol property).
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.FieldValue> device_attributes = 4;
   */
  deviceAttributes: { [key: string]: FieldValue };

  /**
   * The connection (device) parameters.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.ConnectionInfo connection_info = 5;
   */
  connectionInfo: ConnectionInfo[];

  /**
   * The application protocol.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ApplicationProtocol app_protocol = 6;
   */
  appProtocol: ApplicationProtocol;

  /**
   * The timezone related to the device, e.g. "America/New_York", "Europe/Prague", "CET", "GMT", "Etc/GMT+2".
   *
   * @generated from field: string timezone = 7;
   */
  timezone: string;
};

/**
 * Sub-message representing a single job-device info.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobDevice
 */
export type JobDeviceJson = {
  /**
   * The device's job identifier within the parent bulk.
   *
   * @generated from field: string job_id = 1;
   */
  jobId?: string;

  /**
   * The device identifier. If set then all below is loaded from the device registry.
   *
   * @generated from field: string device_id = 2;
   */
  deviceId?: string;

  /**
   * The external identifier.
   *
   * @generated from field: string external_id = 3;
   */
  externalId?: string;

  /**
   * The connection attributes to the device, see options in the ApplicationProtocolTemplate for given application protocol (see app_protocol property).
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.FieldValue> device_attributes = 4;
   */
  deviceAttributes?: { [key: string]: FieldValueJson };

  /**
   * The connection (device) parameters.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.ConnectionInfo connection_info = 5;
   */
  connectionInfo?: ConnectionInfoJson[];

  /**
   * The application protocol.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ApplicationProtocol app_protocol = 6;
   */
  appProtocol?: ApplicationProtocolJson;

  /**
   * The timezone related to the device, e.g. "America/New_York", "Europe/Prague", "CET", "GMT", "Etc/GMT+2".
   *
   * @generated from field: string timezone = 7;
   */
  timezone?: string;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.JobDevice.
 * Use `create(JobDeviceSchema)` to create a new message.
 */
export const JobDeviceSchema: GenMessage<JobDevice, {jsonType: JobDeviceJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 6);

/**
 * Sub-message containing modem connection info
 *
 * @generated from message io.clbs.openhes.models.acquisition.ModemInfo
 */
export type ModemInfo = Message<"io.clbs.openhes.models.acquisition.ModemInfo"> & {
  /**
   * The modem identifier. It is automatically generated during creation.
   *
   * @generated from field: string modem_id = 1;
   */
  modemId: string;

  /**
   * The name of the modem.
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * The modem initialization command, e.g. AT&FE0X3
   *
   * @generated from field: string at_init = 3;
   */
  atInit: string;

  /**
   * The modem dial command, e.g. ATD.
   *
   * @generated from field: string at_dial = 4;
   */
  atDial: string;

  /**
   * The modem hangup command, e.g. ATH.
   *
   * @generated from field: string at_hangup = 5;
   */
  atHangup: string;

  /**
   * The modem escape command, e.g. +++.
   *
   * @generated from field: string at_escape = 6;
   */
  atEscape: string;

  /**
   * The modem connection timeout, if applicable given by the modem_connection field.
   *
   * @generated from field: google.protobuf.Duration connect_timeout = 7;
   */
  connectTimeout?: Duration;

  /**
   * The modem command timeout, if applicable given by the modem_connection field.
   *
   * @generated from field: google.protobuf.Duration command_timeout = 8;
   */
  commandTimeout?: Duration;

  /**
   * The modem connection description.
   *
   * @generated from oneof io.clbs.openhes.models.acquisition.ModemInfo.modem_connection
   */
  modemConnection: {
    /**
     * The TCP connection type. The modem has either TCP or there is a IP-to-serial converter which handles the serial configuration so no additional serial configuration is needed.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ConnectionTypeDirectTcpIp tcpip = 9;
     */
    value: ConnectionTypeDirectTcpIp;
    case: "tcpip";
  } | {
    /**
     * The serial over IP connection type. The modem is connected behind an IP-to-serial converter and needs connection specific handling.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ConnectionTypeControlledSerial serial_over_ip = 10;
     */
    value: ConnectionTypeControlledSerial;
    case: "serialOverIp";
  } | { case: undefined; value?: undefined };

  /**
   * The serial baud rate, if applicable given by the modem_connection field.
   *
   * @generated from field: uint32 serial_baud_rate = 11;
   */
  serialBaudRate: number;
};

/**
 * Sub-message containing modem connection info
 *
 * @generated from message io.clbs.openhes.models.acquisition.ModemInfo
 */
export type ModemInfoJson = {
  /**
   * The modem identifier. It is automatically generated during creation.
   *
   * @generated from field: string modem_id = 1;
   */
  modemId?: string;

  /**
   * The name of the modem.
   *
   * @generated from field: string name = 2;
   */
  name?: string;

  /**
   * The modem initialization command, e.g. AT&FE0X3
   *
   * @generated from field: string at_init = 3;
   */
  atInit?: string;

  /**
   * The modem dial command, e.g. ATD.
   *
   * @generated from field: string at_dial = 4;
   */
  atDial?: string;

  /**
   * The modem hangup command, e.g. ATH.
   *
   * @generated from field: string at_hangup = 5;
   */
  atHangup?: string;

  /**
   * The modem escape command, e.g. +++.
   *
   * @generated from field: string at_escape = 6;
   */
  atEscape?: string;

  /**
   * The modem connection timeout, if applicable given by the modem_connection field.
   *
   * @generated from field: google.protobuf.Duration connect_timeout = 7;
   */
  connectTimeout?: DurationJson;

  /**
   * The modem command timeout, if applicable given by the modem_connection field.
   *
   * @generated from field: google.protobuf.Duration command_timeout = 8;
   */
  commandTimeout?: DurationJson;

  /**
   * The TCP connection type. The modem has either TCP or there is a IP-to-serial converter which handles the serial configuration so no additional serial configuration is needed.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ConnectionTypeDirectTcpIp tcpip = 9;
   */
  tcpip?: ConnectionTypeDirectTcpIpJson;

  /**
   * The serial over IP connection type. The modem is connected behind an IP-to-serial converter and needs connection specific handling.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ConnectionTypeControlledSerial serial_over_ip = 10;
   */
  serialOverIp?: ConnectionTypeControlledSerialJson;

  /**
   * The serial baud rate, if applicable given by the modem_connection field.
   *
   * @generated from field: uint32 serial_baud_rate = 11;
   */
  serialBaudRate?: number;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ModemInfo.
 * Use `create(ModemInfoSchema)` to create a new message.
 */
export const ModemInfoSchema: GenMessage<ModemInfo, {jsonType: ModemInfoJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 7);

/**
 * Sub-message containing serial port configuration
 *
 * @generated from message io.clbs.openhes.models.acquisition.SerialConfig
 */
export type SerialConfig = Message<"io.clbs.openhes.models.acquisition.SerialConfig"> & {
  /**
   * The baud rate.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.SerialConfigBaudRate baud_rate = 1;
   */
  baudRate: SerialConfigBaudRate;

  /**
   * The parity.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.SerialConfigParity parity = 2;
   */
  parity: SerialConfigParity;

  /**
   * The data bits.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.SerialConfigDataBits data_bits = 3;
   */
  dataBits: SerialConfigDataBits;

  /**
   * The stop bits.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.SerialConfigStopBits stop_bits = 4;
   */
  stopBits: SerialConfigStopBits;
};

/**
 * Sub-message containing serial port configuration
 *
 * @generated from message io.clbs.openhes.models.acquisition.SerialConfig
 */
export type SerialConfigJson = {
  /**
   * The baud rate.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.SerialConfigBaudRate baud_rate = 1;
   */
  baudRate?: SerialConfigBaudRateJson;

  /**
   * The parity.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.SerialConfigParity parity = 2;
   */
  parity?: SerialConfigParityJson;

  /**
   * The data bits.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.SerialConfigDataBits data_bits = 3;
   */
  dataBits?: SerialConfigDataBitsJson;

  /**
   * The stop bits.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.SerialConfigStopBits stop_bits = 4;
   */
  stopBits?: SerialConfigStopBitsJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.SerialConfig.
 * Use `create(SerialConfigSchema)` to create a new message.
 */
export const SerialConfigSchema: GenMessage<SerialConfig, {jsonType: SerialConfigJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 8);

/**
 * Sub-message containing connection info
 *
 * @generated from message io.clbs.openhes.models.acquisition.ConnectionInfo
 */
export type ConnectionInfo = Message<"io.clbs.openhes.models.acquisition.ConnectionInfo"> & {
  /**
   * The entrypoint connection description. It can be either direct TCP, a modem from a pool or a direct serial line over IP (using IP-to-serial converter).
   *
   * @generated from oneof io.clbs.openhes.models.acquisition.ConnectionInfo.connection
   */
  connection: {
    /**
     * The TCP connection type.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ConnectionTypeDirectTcpIp tcpip = 1;
     */
    value: ConnectionTypeDirectTcpIp;
    case: "tcpip";
  } | {
    /**
     * The phone connection type.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ConnectionTypeModemPool modem_pool = 2;
     */
    value: ConnectionTypeModemPool;
    case: "modemPool";
  } | {
    /**
     * The serial over IP connection type.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ConnectionTypeControlledSerial serial_over_ip = 3;
     */
    value: ConnectionTypeControlledSerial;
    case: "serialOverIp";
  } | { case: undefined; value?: undefined };

  /**
   * The data link protocol.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.DataLinkProtocol link_protocol = 4;
   */
  linkProtocol: DataLinkProtocol;

  /**
   * The communication bus identifier. It behaves as a custom grouping key to link jobs together across multiple communication units. It shall be used in a situation when multiple entry points share single communication bus, e.g. multi-master RS-485 (primary and backup master). If not set then jobs are grouped by group-key defined based on the connection type.
   *
   * @generated from field: string communication_bus_id = 5;
   */
  communicationBusId: string;

  /**
   * The connection attributes, see GetDataLinkFields in the acquisition package.
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.FieldValue> attributes = 6;
   */
  attributes: { [key: string]: FieldValue };
};

/**
 * Sub-message containing connection info
 *
 * @generated from message io.clbs.openhes.models.acquisition.ConnectionInfo
 */
export type ConnectionInfoJson = {
  /**
   * The TCP connection type.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ConnectionTypeDirectTcpIp tcpip = 1;
   */
  tcpip?: ConnectionTypeDirectTcpIpJson;

  /**
   * The phone connection type.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ConnectionTypeModemPool modem_pool = 2;
   */
  modemPool?: ConnectionTypeModemPoolJson;

  /**
   * The serial over IP connection type.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ConnectionTypeControlledSerial serial_over_ip = 3;
   */
  serialOverIp?: ConnectionTypeControlledSerialJson;

  /**
   * The data link protocol.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.DataLinkProtocol link_protocol = 4;
   */
  linkProtocol?: DataLinkProtocolJson;

  /**
   * The communication bus identifier. It behaves as a custom grouping key to link jobs together across multiple communication units. It shall be used in a situation when multiple entry points share single communication bus, e.g. multi-master RS-485 (primary and backup master). If not set then jobs are grouped by group-key defined based on the connection type.
   *
   * @generated from field: string communication_bus_id = 5;
   */
  communicationBusId?: string;

  /**
   * The connection attributes, see GetDataLinkFields in the acquisition package.
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.FieldValue> attributes = 6;
   */
  attributes?: { [key: string]: FieldValueJson };
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ConnectionInfo.
 * Use `create(ConnectionInfoSchema)` to create a new message.
 */
export const ConnectionInfoSchema: GenMessage<ConnectionInfo, {jsonType: ConnectionInfoJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 9);

/**
 * Sub-message containing connection info for TCP connection type
 *
 * @generated from message io.clbs.openhes.models.acquisition.ConnectionTypeDirectTcpIp
 */
export type ConnectionTypeDirectTcpIp = Message<"io.clbs.openhes.models.acquisition.ConnectionTypeDirectTcpIp"> & {
  /**
   * The host name or IP address of the device to connect to.
   *
   * @generated from field: string host = 1;
   */
  host: string;

  /**
   * The TCP port number of the device to connect to.
   *
   * @generated from field: uint32 port = 2;
   */
  port: number;

  /**
   * The timeout for TCP/IP connection.
   *
   * @generated from field: google.protobuf.Duration timeout = 3;
   */
  timeout?: Duration;
};

/**
 * Sub-message containing connection info for TCP connection type
 *
 * @generated from message io.clbs.openhes.models.acquisition.ConnectionTypeDirectTcpIp
 */
export type ConnectionTypeDirectTcpIpJson = {
  /**
   * The host name or IP address of the device to connect to.
   *
   * @generated from field: string host = 1;
   */
  host?: string;

  /**
   * The TCP port number of the device to connect to.
   *
   * @generated from field: uint32 port = 2;
   */
  port?: number;

  /**
   * The timeout for TCP/IP connection.
   *
   * @generated from field: google.protobuf.Duration timeout = 3;
   */
  timeout?: DurationJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ConnectionTypeDirectTcpIp.
 * Use `create(ConnectionTypeDirectTcpIpSchema)` to create a new message.
 */
export const ConnectionTypeDirectTcpIpSchema: GenMessage<ConnectionTypeDirectTcpIp, {jsonType: ConnectionTypeDirectTcpIpJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 10);

/**
 * Sub-message containing connection info for phone line (modem) connection type
 *
 * @generated from message io.clbs.openhes.models.acquisition.ConnectionTypeModemPool
 */
export type ConnectionTypeModemPool = Message<"io.clbs.openhes.models.acquisition.ConnectionTypeModemPool"> & {
  /**
   * The phone number of the device to connect to.
   *
   * @generated from field: string number = 1;
   */
  number: string;

  /**
   * The modem pool identifier. The pool is a group of modems that can be used to connect to the device. Final modem is selected by the Taskmaster at the time of the job start.
   *
   * @generated from field: string pool_id = 2;
   */
  poolId: string;

  /**
   * The modem device assigned to the job. This is filled only and only when the connection type is modem. The value is assigned by the Taskmaster when to job is being started. Driver is required to use this modem device to connect to the meter only and only for the time of this job!
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ModemInfo modem = 4;
   */
  modem?: ModemInfo;
};

/**
 * Sub-message containing connection info for phone line (modem) connection type
 *
 * @generated from message io.clbs.openhes.models.acquisition.ConnectionTypeModemPool
 */
export type ConnectionTypeModemPoolJson = {
  /**
   * The phone number of the device to connect to.
   *
   * @generated from field: string number = 1;
   */
  number?: string;

  /**
   * The modem pool identifier. The pool is a group of modems that can be used to connect to the device. Final modem is selected by the Taskmaster at the time of the job start.
   *
   * @generated from field: string pool_id = 2;
   */
  poolId?: string;

  /**
   * The modem device assigned to the job. This is filled only and only when the connection type is modem. The value is assigned by the Taskmaster when to job is being started. Driver is required to use this modem device to connect to the meter only and only for the time of this job!
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ModemInfo modem = 4;
   */
  modem?: ModemInfoJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ConnectionTypeModemPool.
 * Use `create(ConnectionTypeModemPoolSchema)` to create a new message.
 */
export const ConnectionTypeModemPoolSchema: GenMessage<ConnectionTypeModemPool, {jsonType: ConnectionTypeModemPoolJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 11);

/**
 * @generated from message io.clbs.openhes.models.acquisition.ConnectionTypeSerialDirect
 */
export type ConnectionTypeSerialDirect = Message<"io.clbs.openhes.models.acquisition.ConnectionTypeSerialDirect"> & {
  /**
   * The host name or IP address of the device to connect to.
   *
   * @generated from field: string host = 1;
   */
  host: string;

  /**
   * The TCP port number of the device to connect to.
   *
   * @generated from field: uint32 port = 2;
   */
  port: number;

  /**
   * The timeout for direct serial port connection.
   *
   * @generated from field: google.protobuf.Duration timeout = 3;
   */
  timeout?: Duration;
};

/**
 * @generated from message io.clbs.openhes.models.acquisition.ConnectionTypeSerialDirect
 */
export type ConnectionTypeSerialDirectJson = {
  /**
   * The host name or IP address of the device to connect to.
   *
   * @generated from field: string host = 1;
   */
  host?: string;

  /**
   * The TCP port number of the device to connect to.
   *
   * @generated from field: uint32 port = 2;
   */
  port?: number;

  /**
   * The timeout for direct serial port connection.
   *
   * @generated from field: google.protobuf.Duration timeout = 3;
   */
  timeout?: DurationJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ConnectionTypeSerialDirect.
 * Use `create(ConnectionTypeSerialDirectSchema)` to create a new message.
 */
export const ConnectionTypeSerialDirectSchema: GenMessage<ConnectionTypeSerialDirect, {jsonType: ConnectionTypeSerialDirectJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 12);

/**
 * Sub-message containing connection info for controlled-serial line (Moxa) connection type
 *
 * @generated from message io.clbs.openhes.models.acquisition.ConnectionTypeSerialMoxa
 */
export type ConnectionTypeSerialMoxa = Message<"io.clbs.openhes.models.acquisition.ConnectionTypeSerialMoxa"> & {
  /**
   * The host name or IP address of the device to connect to.
   *
   * @generated from field: string host = 1;
   */
  host: string;

  /**
   * The TCP port number of the device to connect to - data port.
   *
   * @generated from field: uint32 dataPort = 2;
   */
  dataPort: number;

  /**
   * The TCP port number of the device to connect to - command port.
   *
   * @generated from field: uint32 command_port = 3;
   */
  commandPort: number;

  /**
   * The timeout for serial port connection that implements the Moxa protocol.
   *
   * @generated from field: google.protobuf.Duration timeout = 4;
   */
  timeout?: Duration;
};

/**
 * Sub-message containing connection info for controlled-serial line (Moxa) connection type
 *
 * @generated from message io.clbs.openhes.models.acquisition.ConnectionTypeSerialMoxa
 */
export type ConnectionTypeSerialMoxaJson = {
  /**
   * The host name or IP address of the device to connect to.
   *
   * @generated from field: string host = 1;
   */
  host?: string;

  /**
   * The TCP port number of the device to connect to - data port.
   *
   * @generated from field: uint32 dataPort = 2;
   */
  dataPort?: number;

  /**
   * The TCP port number of the device to connect to - command port.
   *
   * @generated from field: uint32 command_port = 3;
   */
  commandPort?: number;

  /**
   * The timeout for serial port connection that implements the Moxa protocol.
   *
   * @generated from field: google.protobuf.Duration timeout = 4;
   */
  timeout?: DurationJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ConnectionTypeSerialMoxa.
 * Use `create(ConnectionTypeSerialMoxaSchema)` to create a new message.
 */
export const ConnectionTypeSerialMoxaSchema: GenMessage<ConnectionTypeSerialMoxa, {jsonType: ConnectionTypeSerialMoxaJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 13);

/**
 * Sub-message containing connection info for controlled-serial line (RFC 2217) connection type
 *
 * @generated from message io.clbs.openhes.models.acquisition.ConnectionTypeSerialRfc2217
 */
export type ConnectionTypeSerialRfc2217 = Message<"io.clbs.openhes.models.acquisition.ConnectionTypeSerialRfc2217"> & {
  /**
   * The host name or IP address of the device to connect to.
   *
   * @generated from field: string host = 1;
   */
  host: string;

  /**
   * The TCP port number of the device to connect to.
   *
   * @generated from field: uint32 port = 2;
   */
  port: number;

  /**
   * The timeout for serial port connection that implements the RFC 2217 protocol.
   *
   * @generated from field: google.protobuf.Duration timeout = 3;
   */
  timeout?: Duration;
};

/**
 * Sub-message containing connection info for controlled-serial line (RFC 2217) connection type
 *
 * @generated from message io.clbs.openhes.models.acquisition.ConnectionTypeSerialRfc2217
 */
export type ConnectionTypeSerialRfc2217Json = {
  /**
   * The host name or IP address of the device to connect to.
   *
   * @generated from field: string host = 1;
   */
  host?: string;

  /**
   * The TCP port number of the device to connect to.
   *
   * @generated from field: uint32 port = 2;
   */
  port?: number;

  /**
   * The timeout for serial port connection that implements the RFC 2217 protocol.
   *
   * @generated from field: google.protobuf.Duration timeout = 3;
   */
  timeout?: DurationJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ConnectionTypeSerialRfc2217.
 * Use `create(ConnectionTypeSerialRfc2217Schema)` to create a new message.
 */
export const ConnectionTypeSerialRfc2217Schema: GenMessage<ConnectionTypeSerialRfc2217, {jsonType: ConnectionTypeSerialRfc2217Json}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 14);

/**
 * Sub-message containing destription for one application protocol, e.g. DLMS_SN.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ApplicationProtocolTemplate
 */
export type ApplicationProtocolTemplate = Message<"io.clbs.openhes.models.acquisition.ApplicationProtocolTemplate"> & {
  /**
   * The application protocol.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ApplicationProtocol protocol = 1;
   */
  protocol: ApplicationProtocol;

  /**
   * The list of attribute definitions for the application protocol and those will be instantiated for each device & communication unit pair.
   *
   * @generated from field: repeated io.clbs.openhes.models.common.FieldDescriptor attributes = 2;
   */
  attributes: FieldDescriptor[];
};

/**
 * Sub-message containing destription for one application protocol, e.g. DLMS_SN.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ApplicationProtocolTemplate
 */
export type ApplicationProtocolTemplateJson = {
  /**
   * The application protocol.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ApplicationProtocol protocol = 1;
   */
  protocol?: ApplicationProtocolJson;

  /**
   * The list of attribute definitions for the application protocol and those will be instantiated for each device & communication unit pair.
   *
   * @generated from field: repeated io.clbs.openhes.models.common.FieldDescriptor attributes = 2;
   */
  attributes?: FieldDescriptorJson[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ApplicationProtocolTemplate.
 * Use `create(ApplicationProtocolTemplateSchema)` to create a new message.
 */
export const ApplicationProtocolTemplateSchema: GenMessage<ApplicationProtocolTemplate, {jsonType: ApplicationProtocolTemplateJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 15);

/**
 * Sub-message containing destription for one data link protocol, e.g. HDLC.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DataLinkTemplate
 */
export type DataLinkTemplate = Message<"io.clbs.openhes.models.acquisition.DataLinkTemplate"> & {
  /**
   * The data link protocol.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.DataLinkProtocol link_protocol = 1;
   */
  linkProtocol: DataLinkProtocol;

  /**
   * The list of application protocol identifiers supported by the driver.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.ApplicationProtocol app_protocol_refs = 2;
   */
  appProtocolRefs: ApplicationProtocol[];

  /**
   * The list of attribute definitions related to given data link type (see link_protocol property). The field definitions are taken from the system, drivers must leave this empty.
   *
   * @generated from field: repeated io.clbs.openhes.models.common.FieldDescriptor attributes = 3;
   */
  attributes: FieldDescriptor[];
};

/**
 * Sub-message containing destription for one data link protocol, e.g. HDLC.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DataLinkTemplate
 */
export type DataLinkTemplateJson = {
  /**
   * The data link protocol.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.DataLinkProtocol link_protocol = 1;
   */
  linkProtocol?: DataLinkProtocolJson;

  /**
   * The list of application protocol identifiers supported by the driver.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.ApplicationProtocol app_protocol_refs = 2;
   */
  appProtocolRefs?: ApplicationProtocolJson[];

  /**
   * The list of attribute definitions related to given data link type (see link_protocol property). The field definitions are taken from the system, drivers must leave this empty.
   *
   * @generated from field: repeated io.clbs.openhes.models.common.FieldDescriptor attributes = 3;
   */
  attributes?: FieldDescriptorJson[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.DataLinkTemplate.
 * Use `create(DataLinkTemplateSchema)` to create a new message.
 */
export const DataLinkTemplateSchema: GenMessage<DataLinkTemplate, {jsonType: DataLinkTemplateJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 16);

/**
 * Sub-message containing destription for one communication type, e.g. TCP/IP.
 *
 * @generated from message io.clbs.openhes.models.acquisition.CommunicationTemplate
 */
export type CommunicationTemplate = Message<"io.clbs.openhes.models.acquisition.CommunicationTemplate"> & {
  /**
   * The type of the communication.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.CommunicationType type = 1;
   */
  type: CommunicationType;

  /**
   * The list of data link protocols and their app protocols supported by the driver.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.DataLinkTemplate datalinks = 2;
   */
  datalinks: DataLinkTemplate[];
};

/**
 * Sub-message containing destription for one communication type, e.g. TCP/IP.
 *
 * @generated from message io.clbs.openhes.models.acquisition.CommunicationTemplate
 */
export type CommunicationTemplateJson = {
  /**
   * The type of the communication.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.CommunicationType type = 1;
   */
  type?: CommunicationTypeJson;

  /**
   * The list of data link protocols and their app protocols supported by the driver.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.DataLinkTemplate datalinks = 2;
   */
  datalinks?: DataLinkTemplateJson[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.CommunicationTemplate.
 * Use `create(CommunicationTemplateSchema)` to create a new message.
 */
export const CommunicationTemplateSchema: GenMessage<CommunicationTemplate, {jsonType: CommunicationTemplateJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 17);

/**
 * Sub-message containing access level definition
 *
 * @generated from message io.clbs.openhes.models.acquisition.AccessLevelTemplate
 */
export type AccessLevelTemplate = Message<"io.clbs.openhes.models.acquisition.AccessLevelTemplate"> & {
  /**
   * The access level identifier, such as "1", "G", "16" or similar.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The access level name. Should be in English and unique for given driver, e.g. "Management", "Public".
   *
   * @generated from field: string name = 2;
   */
  name: string;
};

/**
 * Sub-message containing access level definition
 *
 * @generated from message io.clbs.openhes.models.acquisition.AccessLevelTemplate
 */
export type AccessLevelTemplateJson = {
  /**
   * The access level identifier, such as "1", "G", "16" or similar.
   *
   * @generated from field: string id = 1;
   */
  id?: string;

  /**
   * The access level name. Should be in English and unique for given driver, e.g. "Management", "Public".
   *
   * @generated from field: string name = 2;
   */
  name?: string;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.AccessLevelTemplate.
 * Use `create(AccessLevelTemplateSchema)` to create a new message.
 */
export const AccessLevelTemplateSchema: GenMessage<AccessLevelTemplate, {jsonType: AccessLevelTemplateJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 18);

/**
 * Sub-message in driver negotiation request
 *
 * @generated from message io.clbs.openhes.models.acquisition.DriverTemplates
 */
export type DriverTemplates = Message<"io.clbs.openhes.models.acquisition.DriverTemplates"> & {
  /**
   * The templates of the communication options. Every template represents an option how the drivers allows to communicate. The driver can support multiple communication templates.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.CommunicationTemplate communication_templates = 1;
   */
  communicationTemplates: CommunicationTemplate[];

  /**
   * The templates of the application protocols supported by the driver.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.ApplicationProtocolTemplate app_protocols = 2;
   */
  appProtocols: ApplicationProtocolTemplate[];

  /**
   * The templates of the job actions for all supported action types. It must contain every action type supported by the driver once and only once.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.JobActionAttributes action_attributes = 3;
   */
  actionAttributes: JobActionAttributes[];

  /**
   * The templates of the access levels supported by the driver.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.AccessLevelTemplate access_templates = 4;
   */
  accessTemplates: AccessLevelTemplate[];

  /**
   * The templates of the job actions constraints.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobActionContraints action_constraints = 5;
   */
  actionConstraints?: JobActionContraints;
};

/**
 * Sub-message in driver negotiation request
 *
 * @generated from message io.clbs.openhes.models.acquisition.DriverTemplates
 */
export type DriverTemplatesJson = {
  /**
   * The templates of the communication options. Every template represents an option how the drivers allows to communicate. The driver can support multiple communication templates.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.CommunicationTemplate communication_templates = 1;
   */
  communicationTemplates?: CommunicationTemplateJson[];

  /**
   * The templates of the application protocols supported by the driver.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.ApplicationProtocolTemplate app_protocols = 2;
   */
  appProtocols?: ApplicationProtocolTemplateJson[];

  /**
   * The templates of the job actions for all supported action types. It must contain every action type supported by the driver once and only once.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.JobActionAttributes action_attributes = 3;
   */
  actionAttributes?: JobActionAttributesJson[];

  /**
   * The templates of the access levels supported by the driver.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.AccessLevelTemplate access_templates = 4;
   */
  accessTemplates?: AccessLevelTemplateJson[];

  /**
   * The templates of the job actions constraints.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobActionContraints action_constraints = 5;
   */
  actionConstraints?: JobActionContraintsJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.DriverTemplates.
 * Use `create(DriverTemplatesSchema)` to create a new message.
 */
export const DriverTemplatesSchema: GenMessage<DriverTemplates, {jsonType: DriverTemplatesJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 19);

/**
 * Sub-message containing action progress update
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionProgressUpdate
 */
export type ActionProgressUpdate = Message<"io.clbs.openhes.models.acquisition.ActionProgressUpdate"> & {
  /**
   * The job identifier.
   *
   * @generated from field: string job_id = 1;
   */
  jobId: string;

  /**
   * The action identifier.
   *
   * @generated from field: string action_id = 2;
   */
  actionId: string;

  /**
   * The status related to the action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionResultCode code = 3;
   */
  code: ActionResultCode;

  /**
   * The action result data. Shall be empty if the code is not OK.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionData data = 4;
   */
  data?: ActionData;
};

/**
 * Sub-message containing action progress update
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionProgressUpdate
 */
export type ActionProgressUpdateJson = {
  /**
   * The job identifier.
   *
   * @generated from field: string job_id = 1;
   */
  jobId?: string;

  /**
   * The action identifier.
   *
   * @generated from field: string action_id = 2;
   */
  actionId?: string;

  /**
   * The status related to the action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionResultCode code = 3;
   */
  code?: ActionResultCodeJson;

  /**
   * The action result data. Shall be empty if the code is not OK.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionData data = 4;
   */
  data?: ActionDataJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionProgressUpdate.
 * Use `create(ActionProgressUpdateSchema)` to create a new message.
 */
export const ActionProgressUpdateSchema: GenMessage<ActionProgressUpdate, {jsonType: ActionProgressUpdateJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 20);

/**
 * Sub-message containing job progress update
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobProgressUpdate
 */
export type JobProgressUpdate = Message<"io.clbs.openhes.models.acquisition.JobProgressUpdate"> & {
  /**
   * The job identifier.
   *
   * @generated from field: string job_id = 1;
   */
  jobId: string;

  /**
   * The status related to the job and or action update message.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobErrorCode code = 2;
   */
  code: JobErrorCode;

  /**
   * The time spent to handle the job.
   *
   * @generated from field: google.protobuf.Duration duration = 3;
   */
  duration?: Duration;
};

/**
 * Sub-message containing job progress update
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobProgressUpdate
 */
export type JobProgressUpdateJson = {
  /**
   * The job identifier.
   *
   * @generated from field: string job_id = 1;
   */
  jobId?: string;

  /**
   * The status related to the job and or action update message.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobErrorCode code = 2;
   */
  code?: JobErrorCodeJson;

  /**
   * The time spent to handle the job.
   *
   * @generated from field: google.protobuf.Duration duration = 3;
   */
  duration?: DurationJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.JobProgressUpdate.
 * Use `create(JobProgressUpdateSchema)` to create a new message.
 */
export const JobProgressUpdateSchema: GenMessage<JobProgressUpdate, {jsonType: JobProgressUpdateJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 21);

/**
 * Sub-message containing action-based variant of data values
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionData
 */
export type ActionData = Message<"io.clbs.openhes.models.acquisition.ActionData"> & {
  /**
   * @generated from oneof io.clbs.openhes.models.acquisition.ActionData.data
   */
  data: {
    /**
     * No data
     *
     * @generated from field: google.protobuf.Empty nodata = 1;
     */
    value: Empty;
    case: "nodata";
  } | {
    /**
     * Register values
     *
     * @generated from field: io.clbs.openhes.models.acquisition.RegisterValues registers = 2;
     */
    value: RegisterValues;
    case: "registers";
  } | {
    /**
     * Profile values
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ProfileValues profile = 3;
     */
    value: ProfileValues;
    case: "profile";
  } | {
    /**
     * Irregular (non-periodical) profile values, e.g. daily profile
     *
     * @generated from field: io.clbs.openhes.models.acquisition.IrregularProfileValues irregular_profile = 4;
     */
    value: IrregularProfileValues;
    case: "irregularProfile";
  } | {
    /**
     * Device info
     *
     * @generated from field: io.clbs.openhes.models.acquisition.DeviceInfo device_info = 5;
     */
    value: DeviceInfo;
    case: "deviceInfo";
  } | {
    /**
     * Event records
     *
     * @generated from field: io.clbs.openhes.models.acquisition.EventRecords events = 6;
     */
    value: EventRecords;
    case: "events";
  } | {
    /**
     * The time-of-use table.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.timeofuse.TimeOfUseTableSpec tou_table = 7;
     */
    value: TimeOfUseTableSpec;
    case: "touTable";
  } | { case: undefined; value?: undefined };
};

/**
 * Sub-message containing action-based variant of data values
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionData
 */
export type ActionDataJson = {
  /**
   * No data
   *
   * @generated from field: google.protobuf.Empty nodata = 1;
   */
  nodata?: EmptyJson;

  /**
   * Register values
   *
   * @generated from field: io.clbs.openhes.models.acquisition.RegisterValues registers = 2;
   */
  registers?: RegisterValuesJson;

  /**
   * Profile values
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ProfileValues profile = 3;
   */
  profile?: ProfileValuesJson;

  /**
   * Irregular (non-periodical) profile values, e.g. daily profile
   *
   * @generated from field: io.clbs.openhes.models.acquisition.IrregularProfileValues irregular_profile = 4;
   */
  irregularProfile?: IrregularProfileValuesJson;

  /**
   * Device info
   *
   * @generated from field: io.clbs.openhes.models.acquisition.DeviceInfo device_info = 5;
   */
  deviceInfo?: DeviceInfoJson;

  /**
   * Event records
   *
   * @generated from field: io.clbs.openhes.models.acquisition.EventRecords events = 6;
   */
  events?: EventRecordsJson;

  /**
   * The time-of-use table.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.timeofuse.TimeOfUseTableSpec tou_table = 7;
   */
  touTable?: TimeOfUseTableSpecJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionData.
 * Use `create(ActionDataSchema)` to create a new message.
 */
export const ActionDataSchema: GenMessage<ActionData, {jsonType: ActionDataJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 22);

/**
 * Sub-message containing event records
 *
 * @generated from message io.clbs.openhes.models.acquisition.EventRecords
 */
export type EventRecords = Message<"io.clbs.openhes.models.acquisition.EventRecords"> & {
  /**
   * The list of events.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.EventRecord values = 1;
   */
  values: EventRecord[];
};

/**
 * Sub-message containing event records
 *
 * @generated from message io.clbs.openhes.models.acquisition.EventRecords
 */
export type EventRecordsJson = {
  /**
   * The list of events.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.EventRecord values = 1;
   */
  values?: EventRecordJson[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.EventRecords.
 * Use `create(EventRecordsSchema)` to create a new message.
 */
export const EventRecordsSchema: GenMessage<EventRecords, {jsonType: EventRecordsJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 23);

/**
 * Sub-message describing a single event.
 *
 * @generated from message io.clbs.openhes.models.acquisition.EventRecord
 */
export type EventRecord = Message<"io.clbs.openhes.models.acquisition.EventRecord"> & {
  /**
   * The timestamp of the event.
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: Timestamp;

  /**
   * The identifier of the event.
   *
   * @generated from field: int64 event_id = 2;
   */
  eventId: bigint;

  /**
   * The code of the event as generated by the device.
   *
   * @generated from field: int64 event_code = 3;
   */
  eventCode: bigint;

  /**
   * The event source.
   *
   * @generated from field: string event_source = 5;
   */
  eventSource: string;

  /**
   * The text of the event.
   *
   * @generated from field: string event_text = 4;
   */
  eventText: string;
};

/**
 * Sub-message describing a single event.
 *
 * @generated from message io.clbs.openhes.models.acquisition.EventRecord
 */
export type EventRecordJson = {
  /**
   * The timestamp of the event.
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: TimestampJson;

  /**
   * The identifier of the event.
   *
   * @generated from field: int64 event_id = 2;
   */
  eventId?: string;

  /**
   * The code of the event as generated by the device.
   *
   * @generated from field: int64 event_code = 3;
   */
  eventCode?: string;

  /**
   * The event source.
   *
   * @generated from field: string event_source = 5;
   */
  eventSource?: string;

  /**
   * The text of the event.
   *
   * @generated from field: string event_text = 4;
   */
  eventText?: string;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.EventRecord.
 * Use `create(EventRecordSchema)` to create a new message.
 */
export const EventRecordSchema: GenMessage<EventRecord, {jsonType: EventRecordJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 24);

/**
 * Message holds common device information.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DeviceInfo
 */
export type DeviceInfo = Message<"io.clbs.openhes.models.acquisition.DeviceInfo"> & {
  /**
   * The timestamp when the values were read.
   *
   * @generated from field: google.protobuf.Timestamp info_timestamp = 1;
   */
  infoTimestamp?: Timestamp;

  /**
   * The serial number of the device set by manufacturer. Typical source: 0-0:42.0.0.255
   *
   * @generated from field: string manufacturer_serial_number = 2;
   */
  manufacturerSerialNumber: string;

  /**
   * The device serial number of the device.  Typical source: 0-0:96.1.0.255
   *
   * @generated from field: string device_serial_number = 3;
   */
  deviceSerialNumber: string;

  /**
   * The firmware version identifier of the device. Typical source: 0-0:0.2.0.255
   *
   * @generated from field: string firmware_version = 4;
   */
  firmwareVersion: string;

  /**
   * The clock delta against acquisition server clock (got by a driver) where positive value means that the device clock is ahead of local clock and vice versa.
   *
   * @generated from field: google.protobuf.Duration clock_delta = 5;
   */
  clockDelta?: Duration;

  /**
   * The model of the device.
   *
   * @generated from field: string device_model = 6;
   */
  deviceModel: string;

  /**
   * The error register 0. Typical source: 0-0:97.97.1.255 (higher 32-bit) + 0-0:97.97.0.255 (lower 32-bit)
   *
   * @generated from field: uint64 error_register = 7;
   */
  errorRegister: bigint;

  /**
   * The list of relay states. The order of the relays is the same as in the device. The value is true if the relay is connected and false if the relay is disconnected.
   *
   * @generated from field: repeated bool relay_states = 8;
   */
  relayStates: boolean[];

  /**
   * The state of the connection. It represents the disconnector state where true means that the customer is connected and false means that the customer is disconnected.
   *
   * @generated from field: bool connection_state = 9;
   */
  connectionState: boolean;
};

/**
 * Message holds common device information.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DeviceInfo
 */
export type DeviceInfoJson = {
  /**
   * The timestamp when the values were read.
   *
   * @generated from field: google.protobuf.Timestamp info_timestamp = 1;
   */
  infoTimestamp?: TimestampJson;

  /**
   * The serial number of the device set by manufacturer. Typical source: 0-0:42.0.0.255
   *
   * @generated from field: string manufacturer_serial_number = 2;
   */
  manufacturerSerialNumber?: string;

  /**
   * The device serial number of the device.  Typical source: 0-0:96.1.0.255
   *
   * @generated from field: string device_serial_number = 3;
   */
  deviceSerialNumber?: string;

  /**
   * The firmware version identifier of the device. Typical source: 0-0:0.2.0.255
   *
   * @generated from field: string firmware_version = 4;
   */
  firmwareVersion?: string;

  /**
   * The clock delta against acquisition server clock (got by a driver) where positive value means that the device clock is ahead of local clock and vice versa.
   *
   * @generated from field: google.protobuf.Duration clock_delta = 5;
   */
  clockDelta?: DurationJson;

  /**
   * The model of the device.
   *
   * @generated from field: string device_model = 6;
   */
  deviceModel?: string;

  /**
   * The error register 0. Typical source: 0-0:97.97.1.255 (higher 32-bit) + 0-0:97.97.0.255 (lower 32-bit)
   *
   * @generated from field: uint64 error_register = 7;
   */
  errorRegister?: string;

  /**
   * The list of relay states. The order of the relays is the same as in the device. The value is true if the relay is connected and false if the relay is disconnected.
   *
   * @generated from field: repeated bool relay_states = 8;
   */
  relayStates?: boolean[];

  /**
   * The state of the connection. It represents the disconnector state where true means that the customer is connected and false means that the customer is disconnected.
   *
   * @generated from field: bool connection_state = 9;
   */
  connectionState?: boolean;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.DeviceInfo.
 * Use `create(DeviceInfoSchema)` to create a new message.
 */
export const DeviceInfoSchema: GenMessage<DeviceInfo, {jsonType: DeviceInfoJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 25);

/**
 * Sub-message containing profile-typed values
 *
 * @generated from message io.clbs.openhes.models.acquisition.ProfileValues
 */
export type ProfileValues = Message<"io.clbs.openhes.models.acquisition.ProfileValues"> & {
  /**
   * The period of the profile values.
   *
   * @generated from field: int32 period = 1;
   */
  period: number;

  /**
   * The unit of the profile values.
   *
   * @generated from field: string unit = 2;
   */
  unit: string;

  /**
   * The list of continuous profile blocks.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.ProfileBlock blocks = 3;
   */
  blocks: ProfileBlock[];
};

/**
 * Sub-message containing profile-typed values
 *
 * @generated from message io.clbs.openhes.models.acquisition.ProfileValues
 */
export type ProfileValuesJson = {
  /**
   * The period of the profile values.
   *
   * @generated from field: int32 period = 1;
   */
  period?: number;

  /**
   * The unit of the profile values.
   *
   * @generated from field: string unit = 2;
   */
  unit?: string;

  /**
   * The list of continuous profile blocks.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.ProfileBlock blocks = 3;
   */
  blocks?: ProfileBlockJson[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ProfileValues.
 * Use `create(ProfileValuesSchema)` to create a new message.
 */
export const ProfileValuesSchema: GenMessage<ProfileValues, {jsonType: ProfileValuesJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 26);

/**
 * @generated from message io.clbs.openhes.models.acquisition.IrregularProfileValues
 */
export type IrregularProfileValues = Message<"io.clbs.openhes.models.acquisition.IrregularProfileValues"> & {
  /**
   * The unit of the profile values.
   *
   * @generated from field: string unit = 1;
   */
  unit: string;

  /**
   * The list of continuous profile blocks.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.IrregularValue values = 2;
   */
  values: IrregularValue[];
};

/**
 * @generated from message io.clbs.openhes.models.acquisition.IrregularProfileValues
 */
export type IrregularProfileValuesJson = {
  /**
   * The unit of the profile values.
   *
   * @generated from field: string unit = 1;
   */
  unit?: string;

  /**
   * The list of continuous profile blocks.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.IrregularValue values = 2;
   */
  values?: IrregularValueJson[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.IrregularProfileValues.
 * Use `create(IrregularProfileValuesSchema)` to create a new message.
 */
export const IrregularProfileValuesSchema: GenMessage<IrregularProfileValues, {jsonType: IrregularProfileValuesJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 27);

/**
 * @generated from message io.clbs.openhes.models.acquisition.IrregularValue
 */
export type IrregularValue = Message<"io.clbs.openhes.models.acquisition.IrregularValue"> & {
  /**
   * The timestamp of the value.
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: Timestamp;

  /**
   * The value.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.MeasuredValue value = 2;
   */
  value?: MeasuredValue;
};

/**
 * @generated from message io.clbs.openhes.models.acquisition.IrregularValue
 */
export type IrregularValueJson = {
  /**
   * The timestamp of the value.
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: TimestampJson;

  /**
   * The value.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.MeasuredValue value = 2;
   */
  value?: MeasuredValueJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.IrregularValue.
 * Use `create(IrregularValueSchema)` to create a new message.
 */
export const IrregularValueSchema: GenMessage<IrregularValue, {jsonType: IrregularValueJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 28);

/**
 * Sub-message containing a single profile block
 *
 * @generated from message io.clbs.openhes.models.acquisition.ProfileBlock
 */
export type ProfileBlock = Message<"io.clbs.openhes.models.acquisition.ProfileBlock"> & {
  /**
   * The start timestamp of the block.
   *
   * @generated from field: google.protobuf.Timestamp start_timestamp = 1;
   */
  startTimestamp?: Timestamp;

  /**
   * The list of profile values. Values are ordered by timestamp.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.MeasuredValue values = 2;
   */
  values: MeasuredValue[];
};

/**
 * Sub-message containing a single profile block
 *
 * @generated from message io.clbs.openhes.models.acquisition.ProfileBlock
 */
export type ProfileBlockJson = {
  /**
   * The start timestamp of the block.
   *
   * @generated from field: google.protobuf.Timestamp start_timestamp = 1;
   */
  startTimestamp?: TimestampJson;

  /**
   * The list of profile values. Values are ordered by timestamp.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.MeasuredValue values = 2;
   */
  values?: MeasuredValueJson[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ProfileBlock.
 * Use `create(ProfileBlockSchema)` to create a new message.
 */
export const ProfileBlockSchema: GenMessage<ProfileBlock, {jsonType: ProfileBlockJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 29);

/**
 * Sub-message containing register-typed values
 *
 * @generated from message io.clbs.openhes.models.acquisition.RegisterValues
 */
export type RegisterValues = Message<"io.clbs.openhes.models.acquisition.RegisterValues"> & {
  /**
   * The list of register values.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.RegisterValue values = 1;
   */
  values: RegisterValue[];
};

/**
 * Sub-message containing register-typed values
 *
 * @generated from message io.clbs.openhes.models.acquisition.RegisterValues
 */
export type RegisterValuesJson = {
  /**
   * The list of register values.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.RegisterValue values = 1;
   */
  values?: RegisterValueJson[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.RegisterValues.
 * Use `create(RegisterValuesSchema)` to create a new message.
 */
export const RegisterValuesSchema: GenMessage<RegisterValues, {jsonType: RegisterValuesJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 30);

/**
 * Sub-message containing register-typed value
 *
 * @generated from message io.clbs.openhes.models.acquisition.RegisterValue
 */
export type RegisterValue = Message<"io.clbs.openhes.models.acquisition.RegisterValue"> & {
  /**
   * The timestamp of the value.
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: Timestamp;

  /**
   * The unit of the value.
   *
   * @generated from field: string unit = 2;
   */
  unit: string;

  /**
   * The value.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.MeasuredValue value = 3;
   */
  value?: MeasuredValue;
};

/**
 * Sub-message containing register-typed value
 *
 * @generated from message io.clbs.openhes.models.acquisition.RegisterValue
 */
export type RegisterValueJson = {
  /**
   * The timestamp of the value.
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: TimestampJson;

  /**
   * The unit of the value.
   *
   * @generated from field: string unit = 2;
   */
  unit?: string;

  /**
   * The value.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.MeasuredValue value = 3;
   */
  value?: MeasuredValueJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.RegisterValue.
 * Use `create(RegisterValueSchema)` to create a new message.
 */
export const RegisterValueSchema: GenMessage<RegisterValue, {jsonType: RegisterValueJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 31);

/**
 * Sub-message containing measured value
 *
 * @generated from message io.clbs.openhes.models.acquisition.MeasuredValue
 */
export type MeasuredValue = Message<"io.clbs.openhes.models.acquisition.MeasuredValue"> & {
  /**
   * The status of the value.
   *
   * @generated from field: int64 status = 1;
   */
  status: bigint;

  /**
   * The exponent of the value. It's used to calculate the real value as value * 10^exponent for double and int values.
   *
   * @generated from field: int32 exponent = 2;
   */
  exponent: number;

  /**
   * @generated from oneof io.clbs.openhes.models.acquisition.MeasuredValue.kind
   */
  kind: {
    /**
     * The double-typed value.
     *
     * @generated from field: double double_value = 3;
     */
    value: number;
    case: "doubleValue";
  } | {
    /**
     * The integer-typed value.
     *
     * @generated from field: int64 integer_value = 4;
     */
    value: bigint;
    case: "integerValue";
  } | {
    /**
     * The string-typed value.
     *
     * @generated from field: string string_value = 5;
     */
    value: string;
    case: "stringValue";
  } | {
    /**
     * The timestamp-typed value.
     *
     * @generated from field: google.protobuf.Timestamp timestamp_value = 6;
     */
    value: Timestamp;
    case: "timestampValue";
  } | {
    /**
     * The timestamp with timezone-typed value, stored as string in ISO-8601.
     *
     * @generated from field: string timestamp_tz_value = 7;
     */
    value: string;
    case: "timestampTzValue";
  } | {
    /**
     * The boolean-typed value.
     *
     * @generated from field: bool bool_value = 8;
     */
    value: boolean;
    case: "boolValue";
  } | { case: undefined; value?: undefined };

  /**
   * The normalized status of the value, see StatusBits enum for more details.
   *
   * @generated from field: uint64 nstatus = 9;
   */
  nstatus: bigint;

  /**
   * The timestamp when the value (e.g. peak) was recorded. It's typically before the capture timestamp.
   *
   * @generated from field: google.protobuf.Timestamp peak_ts = 10;
   */
  peakTs?: Timestamp;
};

/**
 * Sub-message containing measured value
 *
 * @generated from message io.clbs.openhes.models.acquisition.MeasuredValue
 */
export type MeasuredValueJson = {
  /**
   * The status of the value.
   *
   * @generated from field: int64 status = 1;
   */
  status?: string;

  /**
   * The exponent of the value. It's used to calculate the real value as value * 10^exponent for double and int values.
   *
   * @generated from field: int32 exponent = 2;
   */
  exponent?: number;

  /**
   * The double-typed value.
   *
   * @generated from field: double double_value = 3;
   */
  doubleValue?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * The integer-typed value.
   *
   * @generated from field: int64 integer_value = 4;
   */
  integerValue?: string;

  /**
   * The string-typed value.
   *
   * @generated from field: string string_value = 5;
   */
  stringValue?: string;

  /**
   * The timestamp-typed value.
   *
   * @generated from field: google.protobuf.Timestamp timestamp_value = 6;
   */
  timestampValue?: TimestampJson;

  /**
   * The timestamp with timezone-typed value, stored as string in ISO-8601.
   *
   * @generated from field: string timestamp_tz_value = 7;
   */
  timestampTzValue?: string;

  /**
   * The boolean-typed value.
   *
   * @generated from field: bool bool_value = 8;
   */
  boolValue?: boolean;

  /**
   * The normalized status of the value, see StatusBits enum for more details.
   *
   * @generated from field: uint64 nstatus = 9;
   */
  nstatus?: string;

  /**
   * The timestamp when the value (e.g. peak) was recorded. It's typically before the capture timestamp.
   *
   * @generated from field: google.protobuf.Timestamp peak_ts = 10;
   */
  peakTs?: TimestampJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.MeasuredValue.
 * Use `create(MeasuredValueSchema)` to create a new message.
 */
export const MeasuredValueSchema: GenMessage<MeasuredValue, {jsonType: MeasuredValueJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 32);

/**
 * Sub-message containing job action attributes
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobActionAttributes
 */
export type JobActionAttributes = Message<"io.clbs.openhes.models.acquisition.JobActionAttributes"> & {
  /**
   * The type of action for which this instance of the template is defined.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionType type = 1;
   */
  type: ActionType;

  /**
   * The template of the action attributes. It is represented as a list of attribute definitions.
   *
   * @generated from field: repeated io.clbs.openhes.models.common.FieldDescriptor attributes = 2;
   */
  attributes: FieldDescriptor[];
};

/**
 * Sub-message containing job action attributes
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobActionAttributes
 */
export type JobActionAttributesJson = {
  /**
   * The type of action for which this instance of the template is defined.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionType type = 1;
   */
  type?: ActionTypeJson;

  /**
   * The template of the action attributes. It is represented as a list of attribute definitions.
   *
   * @generated from field: repeated io.clbs.openhes.models.common.FieldDescriptor attributes = 2;
   */
  attributes?: FieldDescriptorJson[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.JobActionAttributes.
 * Use `create(JobActionAttributesSchema)` to create a new message.
 */
export const JobActionAttributesSchema: GenMessage<JobActionAttributes, {jsonType: JobActionAttributesJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 33);

/**
 * Sub-message containing connection info for controlled-serial line over IP (e.g. Moxa) connection type
 *
 * @generated from message io.clbs.openhes.models.acquisition.ConnectionTypeControlledSerial
 */
export type ConnectionTypeControlledSerial = Message<"io.clbs.openhes.models.acquisition.ConnectionTypeControlledSerial"> & {
  /**
   * IP-to-serial converter description.
   *
   * @generated from oneof io.clbs.openhes.models.acquisition.ConnectionTypeControlledSerial.converter
   */
  converter: {
    /**
     * The simple direct serial connection type.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ConnectionTypeSerialDirect direct = 1;
     */
    value: ConnectionTypeSerialDirect;
    case: "direct";
  } | {
    /**
     * The Moxa connection type.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ConnectionTypeSerialMoxa moxa = 2;
     */
    value: ConnectionTypeSerialMoxa;
    case: "moxa";
  } | {
    /**
     * The RFC 2217 connection type.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ConnectionTypeSerialRfc2217 rfc2217 = 3;
     */
    value: ConnectionTypeSerialRfc2217;
    case: "rfc2217";
  } | { case: undefined; value?: undefined };
};

/**
 * Sub-message containing connection info for controlled-serial line over IP (e.g. Moxa) connection type
 *
 * @generated from message io.clbs.openhes.models.acquisition.ConnectionTypeControlledSerial
 */
export type ConnectionTypeControlledSerialJson = {
  /**
   * The simple direct serial connection type.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ConnectionTypeSerialDirect direct = 1;
   */
  direct?: ConnectionTypeSerialDirectJson;

  /**
   * The Moxa connection type.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ConnectionTypeSerialMoxa moxa = 2;
   */
  moxa?: ConnectionTypeSerialMoxaJson;

  /**
   * The RFC 2217 connection type.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ConnectionTypeSerialRfc2217 rfc2217 = 3;
   */
  rfc2217?: ConnectionTypeSerialRfc2217Json;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ConnectionTypeControlledSerial.
 * Use `create(ConnectionTypeControlledSerialSchema)` to create a new message.
 */
export const ConnectionTypeControlledSerialSchema: GenMessage<ConnectionTypeControlledSerial, {jsonType: ConnectionTypeControlledSerialJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 34);

/**
 * Sub-message containing get register action specification
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionGetRegister
 */
export type ActionGetRegister = Message<"io.clbs.openhes.models.acquisition.ActionGetRegister"> & {
};

/**
 * Sub-message containing get register action specification
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionGetRegister
 */
export type ActionGetRegisterJson = {
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionGetRegister.
 * Use `create(ActionGetRegisterSchema)` to create a new message.
 */
export const ActionGetRegisterSchema: GenMessage<ActionGetRegister, {jsonType: ActionGetRegisterJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 35);

/**
 * Sub-message containing get periodical profile action specification
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionGetPeriodicalProfile
 */
export type ActionGetPeriodicalProfile = Message<"io.clbs.openhes.models.acquisition.ActionGetPeriodicalProfile"> & {
  /**
   * The start timestamp of the profile.
   *
   * @generated from field: google.protobuf.Timestamp from = 1;
   */
  from?: Timestamp;

  /**
   * The end timestamp of the profile.
   *
   * @generated from field: google.protobuf.Timestamp to = 2;
   */
  to?: Timestamp;
};

/**
 * Sub-message containing get periodical profile action specification
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionGetPeriodicalProfile
 */
export type ActionGetPeriodicalProfileJson = {
  /**
   * The start timestamp of the profile.
   *
   * @generated from field: google.protobuf.Timestamp from = 1;
   */
  from?: TimestampJson;

  /**
   * The end timestamp of the profile.
   *
   * @generated from field: google.protobuf.Timestamp to = 2;
   */
  to?: TimestampJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionGetPeriodicalProfile.
 * Use `create(ActionGetPeriodicalProfileSchema)` to create a new message.
 */
export const ActionGetPeriodicalProfileSchema: GenMessage<ActionGetPeriodicalProfile, {jsonType: ActionGetPeriodicalProfileJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 36);

/**
 * Sub-message containing get irregular profile action specification
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionGetIrregularProfile
 */
export type ActionGetIrregularProfile = Message<"io.clbs.openhes.models.acquisition.ActionGetIrregularProfile"> & {
  /**
   * The start timestamp of the profile.
   *
   * @generated from field: google.protobuf.Timestamp from = 1;
   */
  from?: Timestamp;

  /**
   * The end timestamp of the profile.
   *
   * @generated from field: google.protobuf.Timestamp to = 2;
   */
  to?: Timestamp;
};

/**
 * Sub-message containing get irregular profile action specification
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionGetIrregularProfile
 */
export type ActionGetIrregularProfileJson = {
  /**
   * The start timestamp of the profile.
   *
   * @generated from field: google.protobuf.Timestamp from = 1;
   */
  from?: TimestampJson;

  /**
   * The end timestamp of the profile.
   *
   * @generated from field: google.protobuf.Timestamp to = 2;
   */
  to?: TimestampJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionGetIrregularProfile.
 * Use `create(ActionGetIrregularProfileSchema)` to create a new message.
 */
export const ActionGetIrregularProfileSchema: GenMessage<ActionGetIrregularProfile, {jsonType: ActionGetIrregularProfileJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 37);

/**
 * Sub-message containing get events action specification
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionGetEvents
 */
export type ActionGetEvents = Message<"io.clbs.openhes.models.acquisition.ActionGetEvents"> & {
  /**
   * The start timestamp of the profile.
   *
   * @generated from field: google.protobuf.Timestamp from = 1;
   */
  from?: Timestamp;

  /**
   * The end timestamp of the profile.
   *
   * @generated from field: google.protobuf.Timestamp to = 2;
   */
  to?: Timestamp;
};

/**
 * Sub-message containing get events action specification
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionGetEvents
 */
export type ActionGetEventsJson = {
  /**
   * The start timestamp of the profile.
   *
   * @generated from field: google.protobuf.Timestamp from = 1;
   */
  from?: TimestampJson;

  /**
   * The end timestamp of the profile.
   *
   * @generated from field: google.protobuf.Timestamp to = 2;
   */
  to?: TimestampJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionGetEvents.
 * Use `create(ActionGetEventsSchema)` to create a new message.
 */
export const ActionGetEventsSchema: GenMessage<ActionGetEvents, {jsonType: ActionGetEventsJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 38);

/**
 * Sub-message containing get device info action specification
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionGetDeviceInfo
 */
export type ActionGetDeviceInfo = Message<"io.clbs.openhes.models.acquisition.ActionGetDeviceInfo"> & {
};

/**
 * Sub-message containing get device info action specification
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionGetDeviceInfo
 */
export type ActionGetDeviceInfoJson = {
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionGetDeviceInfo.
 * Use `create(ActionGetDeviceInfoSchema)` to create a new message.
 */
export const ActionGetDeviceInfoSchema: GenMessage<ActionGetDeviceInfo, {jsonType: ActionGetDeviceInfoJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 39);

/**
 * Sub-message containing sync clock action specification
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionSyncClock
 */
export type ActionSyncClock = Message<"io.clbs.openhes.models.acquisition.ActionSyncClock"> & {
};

/**
 * Sub-message containing sync clock action specification
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionSyncClock
 */
export type ActionSyncClockJson = {
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionSyncClock.
 * Use `create(ActionSyncClockSchema)` to create a new message.
 */
export const ActionSyncClockSchema: GenMessage<ActionSyncClock, {jsonType: ActionSyncClockJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 40);

/**
 * Sub-message containing set relay state action specification
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionSetRelayState
 */
export type ActionSetRelayState = Message<"io.clbs.openhes.models.acquisition.ActionSetRelayState"> & {
};

/**
 * Sub-message containing set relay state action specification
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionSetRelayState
 */
export type ActionSetRelayStateJson = {
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionSetRelayState.
 * Use `create(ActionSetRelayStateSchema)` to create a new message.
 */
export const ActionSetRelayStateSchema: GenMessage<ActionSetRelayState, {jsonType: ActionSetRelayStateJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 41);

/**
 * Sub-message containing set disconnector state action specification
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionSetDisconnectorState
 */
export type ActionSetDisconnectorState = Message<"io.clbs.openhes.models.acquisition.ActionSetDisconnectorState"> & {
};

/**
 * Sub-message containing set disconnector state action specification
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionSetDisconnectorState
 */
export type ActionSetDisconnectorStateJson = {
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionSetDisconnectorState.
 * Use `create(ActionSetDisconnectorStateSchema)` to create a new message.
 */
export const ActionSetDisconnectorStateSchema: GenMessage<ActionSetDisconnectorState, {jsonType: ActionSetDisconnectorStateJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 42);

/**
 * Sub-message containing get tou action specification
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionGetTou
 */
export type ActionGetTou = Message<"io.clbs.openhes.models.acquisition.ActionGetTou"> & {
  /**
   * Identifies whether to read passive TOU table. By default it is set to false to read active TOU table.
   *
   * @generated from field: bool passive = 1;
   */
  passive: boolean;
};

/**
 * Sub-message containing get tou action specification
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionGetTou
 */
export type ActionGetTouJson = {
  /**
   * Identifies whether to read passive TOU table. By default it is set to false to read active TOU table.
   *
   * @generated from field: bool passive = 1;
   */
  passive?: boolean;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionGetTou.
 * Use `create(ActionGetTouSchema)` to create a new message.
 */
export const ActionGetTouSchema: GenMessage<ActionGetTou, {jsonType: ActionGetTouJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 43);

/**
 * Sub-message containing set tou action specification
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionSetTou
 */
export type ActionSetTou = Message<"io.clbs.openhes.models.acquisition.ActionSetTou"> & {
  /**
   * The time-of-use table to be set.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.timeofuse.TimeOfUseTableSpec table = 1;
   */
  table?: TimeOfUseTableSpec;
};

/**
 * Sub-message containing set tou action specification
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionSetTou
 */
export type ActionSetTouJson = {
  /**
   * The time-of-use table to be set.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.timeofuse.TimeOfUseTableSpec table = 1;
   */
  table?: TimeOfUseTableSpecJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionSetTou.
 * Use `create(ActionSetTouSchema)` to create a new message.
 */
export const ActionSetTouSchema: GenMessage<ActionSetTou, {jsonType: ActionSetTouJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 44);

/**
 * Sub-message containing set limiter action specification
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionSetLimiter
 */
export type ActionSetLimiter = Message<"io.clbs.openhes.models.acquisition.ActionSetLimiter"> & {
};

/**
 * Sub-message containing set limiter action specification
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionSetLimiter
 */
export type ActionSetLimiterJson = {
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionSetLimiter.
 * Use `create(ActionSetLimiterSchema)` to create a new message.
 */
export const ActionSetLimiterSchema: GenMessage<ActionSetLimiter, {jsonType: ActionSetLimiterJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 45);

/**
 * Sub-message containing reset billing period action specification
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionResetBillingPeriod
 */
export type ActionResetBillingPeriod = Message<"io.clbs.openhes.models.acquisition.ActionResetBillingPeriod"> & {
};

/**
 * Sub-message containing reset billing period action specification
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionResetBillingPeriod
 */
export type ActionResetBillingPeriodJson = {
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionResetBillingPeriod.
 * Use `create(ActionResetBillingPeriodSchema)` to create a new message.
 */
export const ActionResetBillingPeriodSchema: GenMessage<ActionResetBillingPeriod, {jsonType: ActionResetBillingPeriodJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 46);

/**
 * Sub-message containing firmware update action specification
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionFwUpdate
 */
export type ActionFwUpdate = Message<"io.clbs.openhes.models.acquisition.ActionFwUpdate"> & {
};

/**
 * Sub-message containing firmware update action specification
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionFwUpdate
 */
export type ActionFwUpdateJson = {
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionFwUpdate.
 * Use `create(ActionFwUpdateSchema)` to create a new message.
 */
export const ActionFwUpdateSchema: GenMessage<ActionFwUpdate, {jsonType: ActionFwUpdateJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 47);

/**
 * Sub-message containing constraints for job actions.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobActionContraints
 */
export type JobActionContraints = Message<"io.clbs.openhes.models.acquisition.JobActionContraints"> & {
  /**
   * Contains all the register types & their names in the English language. For example: [gen]="Generic Register", [vqi]="Quality VQI Register"
   * Action: ACTION_TYPE_GET_REGISTER
   *
   * @generated from field: map<string, string> get_register_type_name = 1;
   */
  getRegisterTypeName: { [key: string]: string };

  /**
   * Contains all the register types & their attributes. For example: [gen]=["attribute1", "attribute2"], [vqi]=["attribute1", "attribute3"]
   * See JobActionAttributes for the attribute definitions.
   * Action: ACTION_TYPE_GET_REGISTER
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.ListOfString> get_register_type_attributes = 2;
   */
  getRegisterTypeAttributes: { [key: string]: ListOfString };
};

/**
 * Sub-message containing constraints for job actions.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobActionContraints
 */
export type JobActionContraintsJson = {
  /**
   * Contains all the register types & their names in the English language. For example: [gen]="Generic Register", [vqi]="Quality VQI Register"
   * Action: ACTION_TYPE_GET_REGISTER
   *
   * @generated from field: map<string, string> get_register_type_name = 1;
   */
  getRegisterTypeName?: { [key: string]: string };

  /**
   * Contains all the register types & their attributes. For example: [gen]=["attribute1", "attribute2"], [vqi]=["attribute1", "attribute3"]
   * See JobActionAttributes for the attribute definitions.
   * Action: ACTION_TYPE_GET_REGISTER
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.ListOfString> get_register_type_attributes = 2;
   */
  getRegisterTypeAttributes?: { [key: string]: ListOfStringJson };
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.JobActionContraints.
 * Use `create(JobActionContraintsSchema)` to create a new message.
 */
export const JobActionContraintsSchema: GenMessage<JobActionContraints, {jsonType: JobActionContraintsJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 48);

/**
 * Sub-message containing job status info
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobStatus
 */
export type JobStatus = Message<"io.clbs.openhes.models.acquisition.JobStatus"> & {
  /**
   * The status of the job.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobStatusCode status = 1;
   */
  status: JobStatusCode;

  /**
   * The error code of the job.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobErrorCode code = 2;
   */
  code: JobErrorCode;

  /**
   * The result data for all job actions.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.ActionResult results = 3;
   */
  results: ActionResult[];

  /**
   * The start timestamp of the job.
   *
   * @generated from field: google.protobuf.Timestamp started_at = 4;
   */
  startedAt?: Timestamp;

  /**
   * The finish timestamp of the job.
   *
   * @generated from field: google.protobuf.Timestamp finished_at = 5;
   */
  finishedAt?: Timestamp;

  /**
   * The number of attempts already done.
   *
   * @generated from field: int32 attempts_done = 6;
   */
  attemptsDone: number;

  /**
   * The device info. It contains the data from the action ACTION_TYPE_GET_DEVICE_INFO.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.DeviceInfo device_info = 7;
   */
  deviceInfo?: DeviceInfo;

  /**
   * The internal queue identifier set by the Taskmaster when the job is queued to process.
   *
   * @generated from field: int64 queue_id = 8;
   */
  queueId: bigint;
};

/**
 * Sub-message containing job status info
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobStatus
 */
export type JobStatusJson = {
  /**
   * The status of the job.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobStatusCode status = 1;
   */
  status?: JobStatusCodeJson;

  /**
   * The error code of the job.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobErrorCode code = 2;
   */
  code?: JobErrorCodeJson;

  /**
   * The result data for all job actions.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.ActionResult results = 3;
   */
  results?: ActionResultJson[];

  /**
   * The start timestamp of the job.
   *
   * @generated from field: google.protobuf.Timestamp started_at = 4;
   */
  startedAt?: TimestampJson;

  /**
   * The finish timestamp of the job.
   *
   * @generated from field: google.protobuf.Timestamp finished_at = 5;
   */
  finishedAt?: TimestampJson;

  /**
   * The number of attempts already done.
   *
   * @generated from field: int32 attempts_done = 6;
   */
  attemptsDone?: number;

  /**
   * The device info. It contains the data from the action ACTION_TYPE_GET_DEVICE_INFO.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.DeviceInfo device_info = 7;
   */
  deviceInfo?: DeviceInfoJson;

  /**
   * The internal queue identifier set by the Taskmaster when the job is queued to process.
   *
   * @generated from field: int64 queue_id = 8;
   */
  queueId?: string;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.JobStatus.
 * Use `create(JobStatusSchema)` to create a new message.
 */
export const JobStatusSchema: GenMessage<JobStatus, {jsonType: JobStatusJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 49);

/**
 * Sub-message containing job start request for single device
 *
 * @generated from message io.clbs.openhes.models.acquisition.StartJobData
 */
export type StartJobData = Message<"io.clbs.openhes.models.acquisition.StartJobData"> & {
  /**
   * The device attributes. For example HDLC address, password and other driver-specific attributes.
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.FieldValue> device_attributes = 1;
   */
  deviceAttributes: { [key: string]: FieldValue };

  /**
   * The job identifier.
   *
   * @generated from field: string job_id = 2;
   */
  jobId: string;

  /**
   * The job parameters.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobSettings job_settings = 3;
   */
  jobSettings?: JobSettings;

  /**
   * The list actions to be executed.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.JobAction job_actions = 4;
   */
  jobActions: JobAction[];

  /**
   * The application protocol.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ApplicationProtocol app_protocol = 5;
   */
  appProtocol: ApplicationProtocol;

  /**
   * The timezone related to the device, e.g. "America/New_York", "Europe/Prague", "CET", "GMT", "Etc/GMT+2".
   *
   * @generated from field: string timezone = 6;
   */
  timezone: string;
};

/**
 * Sub-message containing job start request for single device
 *
 * @generated from message io.clbs.openhes.models.acquisition.StartJobData
 */
export type StartJobDataJson = {
  /**
   * The device attributes. For example HDLC address, password and other driver-specific attributes.
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.FieldValue> device_attributes = 1;
   */
  deviceAttributes?: { [key: string]: FieldValueJson };

  /**
   * The job identifier.
   *
   * @generated from field: string job_id = 2;
   */
  jobId?: string;

  /**
   * The job parameters.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobSettings job_settings = 3;
   */
  jobSettings?: JobSettingsJson;

  /**
   * The list actions to be executed.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.JobAction job_actions = 4;
   */
  jobActions?: JobActionJson[];

  /**
   * The application protocol.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ApplicationProtocol app_protocol = 5;
   */
  appProtocol?: ApplicationProtocolJson;

  /**
   * The timezone related to the device, e.g. "America/New_York", "Europe/Prague", "CET", "GMT", "Etc/GMT+2".
   *
   * @generated from field: string timezone = 6;
   */
  timezone?: string;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.StartJobData.
 * Use `create(StartJobDataSchema)` to create a new message.
 */
export const StartJobDataSchema: GenMessage<StartJobData, {jsonType: StartJobDataJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 50);

/**
 * Taskmaster -> Driver cancel job request message
 *
 * @generated from message io.clbs.openhes.models.acquisition.CancelJobRequest
 */
export type CancelJobRequest = Message<"io.clbs.openhes.models.acquisition.CancelJobRequest"> & {
  /**
   * The job identifier.
   *
   * @generated from field: string job_id = 1;
   */
  jobId: string;
};

/**
 * Taskmaster -> Driver cancel job request message
 *
 * @generated from message io.clbs.openhes.models.acquisition.CancelJobRequest
 */
export type CancelJobRequestJson = {
  /**
   * The job identifier.
   *
   * @generated from field: string job_id = 1;
   */
  jobId?: string;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.CancelJobRequest.
 * Use `create(CancelJobRequestSchema)` to create a new message.
 */
export const CancelJobRequestSchema: GenMessage<CancelJobRequest, {jsonType: CancelJobRequestJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 51);

/**
 * @generated from message io.clbs.openhes.models.acquisition.DeviceConfigurationRegisterSpec
 */
export type DeviceConfigurationRegisterSpec = Message<"io.clbs.openhes.models.acquisition.DeviceConfigurationRegisterSpec"> & {
  /**
   * The device (driver) type.
   *
   * @generated from field: string driver_type = 1;
   */
  driverType: string;

  /**
   * The type of action for which the register is defined.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.RegisterType register_type = 2;
   */
  registerType: RegisterType;

  /**
   * The field values.
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.FieldValue> attributes = 3;
   */
  attributes: { [key: string]: FieldValue };
};

/**
 * @generated from message io.clbs.openhes.models.acquisition.DeviceConfigurationRegisterSpec
 */
export type DeviceConfigurationRegisterSpecJson = {
  /**
   * The device (driver) type.
   *
   * @generated from field: string driver_type = 1;
   */
  driverType?: string;

  /**
   * The type of action for which the register is defined.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.RegisterType register_type = 2;
   */
  registerType?: RegisterTypeJson;

  /**
   * The field values.
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.FieldValue> attributes = 3;
   */
  attributes?: { [key: string]: FieldValueJson };
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.DeviceConfigurationRegisterSpec.
 * Use `create(DeviceConfigurationRegisterSpecSchema)` to create a new message.
 */
export const DeviceConfigurationRegisterSpecSchema: GenMessage<DeviceConfigurationRegisterSpec, {jsonType: DeviceConfigurationRegisterSpecJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 52);

/**
 * Addon
 *
 * @generated from message io.clbs.openhes.models.acquisition.DeviceRegister
 */
export type DeviceRegister = Message<"io.clbs.openhes.models.acquisition.DeviceRegister"> & {
  /**
   * The register identifier.
   *
   * @generated from field: int64 register_id = 1;
   */
  registerId: bigint;

  /**
   * The public register identifier.
   *
   * @generated from field: string public_register_id = 2;
   */
  publicRegisterId: string;

  /**
   * The register spec.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.DeviceConfigurationRegisterSpec spec = 3;
   */
  spec?: DeviceConfigurationRegisterSpec;

  /**
   * The name of the variable, if the register is assigned to some.
   *
   * @generated from field: repeated string variable_name = 4;
   */
  variableName: string[];
};

/**
 * Addon
 *
 * @generated from message io.clbs.openhes.models.acquisition.DeviceRegister
 */
export type DeviceRegisterJson = {
  /**
   * The register identifier.
   *
   * @generated from field: int64 register_id = 1;
   */
  registerId?: string;

  /**
   * The public register identifier.
   *
   * @generated from field: string public_register_id = 2;
   */
  publicRegisterId?: string;

  /**
   * The register spec.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.DeviceConfigurationRegisterSpec spec = 3;
   */
  spec?: DeviceConfigurationRegisterSpecJson;

  /**
   * The name of the variable, if the register is assigned to some.
   *
   * @generated from field: repeated string variable_name = 4;
   */
  variableName?: string[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.DeviceRegister.
 * Use `create(DeviceRegisterSchema)` to create a new message.
 */
export const DeviceRegisterSchema: GenMessage<DeviceRegister, {jsonType: DeviceRegisterJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 53);

/**
 * Addon
 *
 * @generated from message io.clbs.openhes.models.acquisition.DeviceConnectionInfo
 */
export type DeviceConnectionInfo = Message<"io.clbs.openhes.models.acquisition.DeviceConnectionInfo"> & {
  /**
   * The unique identifier of the communication unit.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ConnectionInfo communication_unit = 1;
   */
  communicationUnit?: ConnectionInfo;

  /**
   * The application protocol to be used for the communication over the communication unit.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ApplicationProtocol app_protocol = 2;
   */
  appProtocol: ApplicationProtocol;

  /**
   * The device attributes. For example HDLC address, password and other driver-specific attributes.
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.FieldValue> device_attributes = 3;
   */
  deviceAttributes: { [key: string]: FieldValue };

  /**
   * The timezone related to the device, e.g. "America/New_York", "Europe/Prague", "CET", "GMT", "Etc/GMT+2".
   *
   * @generated from field: string timezone = 4;
   */
  timezone: string;

  /**
   * The driver type identifier.
   *
   * @generated from field: string driver_type = 5;
   */
  driverType: string;

  /**
   * The driver version.
   *
   * @generated from field: string driver_version = 7;
   */
  driverVersion: string;

  /**
   * The list of registers get using current device configuration template.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.DeviceRegister registers = 8;
   */
  registers: DeviceRegister[];
};

/**
 * Addon
 *
 * @generated from message io.clbs.openhes.models.acquisition.DeviceConnectionInfo
 */
export type DeviceConnectionInfoJson = {
  /**
   * The unique identifier of the communication unit.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ConnectionInfo communication_unit = 1;
   */
  communicationUnit?: ConnectionInfoJson;

  /**
   * The application protocol to be used for the communication over the communication unit.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ApplicationProtocol app_protocol = 2;
   */
  appProtocol?: ApplicationProtocolJson;

  /**
   * The device attributes. For example HDLC address, password and other driver-specific attributes.
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.FieldValue> device_attributes = 3;
   */
  deviceAttributes?: { [key: string]: FieldValueJson };

  /**
   * The timezone related to the device, e.g. "America/New_York", "Europe/Prague", "CET", "GMT", "Etc/GMT+2".
   *
   * @generated from field: string timezone = 4;
   */
  timezone?: string;

  /**
   * The driver type identifier.
   *
   * @generated from field: string driver_type = 5;
   */
  driverType?: string;

  /**
   * The driver version.
   *
   * @generated from field: string driver_version = 7;
   */
  driverVersion?: string;

  /**
   * The list of registers get using current device configuration template.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.DeviceRegister registers = 8;
   */
  registers?: DeviceRegisterJson[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.DeviceConnectionInfo.
 * Use `create(DeviceConnectionInfoSchema)` to create a new message.
 */
export const DeviceConnectionInfoSchema: GenMessage<DeviceConnectionInfo, {jsonType: DeviceConnectionInfoJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 54);

/**
 * Addon for DB
 *
 * @generated from message io.clbs.openhes.models.acquisition.ListOfModemInfo
 */
export type ListOfModemInfo = Message<"io.clbs.openhes.models.acquisition.ListOfModemInfo"> & {
  /**
   * @generated from field: repeated io.clbs.openhes.models.acquisition.ModemInfo items = 1;
   */
  items: ModemInfo[];

  /**
   * The total number of items.
   *
   * @generated from field: int32 total_count = 2;
   */
  totalCount: number;
};

/**
 * Addon for DB
 *
 * @generated from message io.clbs.openhes.models.acquisition.ListOfModemInfo
 */
export type ListOfModemInfoJson = {
  /**
   * @generated from field: repeated io.clbs.openhes.models.acquisition.ModemInfo items = 1;
   */
  items?: ModemInfoJson[];

  /**
   * The total number of items.
   *
   * @generated from field: int32 total_count = 2;
   */
  totalCount?: number;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ListOfModemInfo.
 * Use `create(ListOfModemInfoSchema)` to create a new message.
 */
export const ListOfModemInfoSchema: GenMessage<ListOfModemInfo, {jsonType: ListOfModemInfoJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 55);

/**
 * Addon for DB
 *
 * @generated from message io.clbs.openhes.models.acquisition.ListOfConnectionInfo
 */
export type ListOfConnectionInfo = Message<"io.clbs.openhes.models.acquisition.ListOfConnectionInfo"> & {
  /**
   * @generated from field: repeated io.clbs.openhes.models.acquisition.DeviceConnectionInfo items = 1;
   */
  items: DeviceConnectionInfo[];

  /**
   * The total number of items.
   *
   * @generated from field: int32 total_count = 2;
   */
  totalCount: number;
};

/**
 * Addon for DB
 *
 * @generated from message io.clbs.openhes.models.acquisition.ListOfConnectionInfo
 */
export type ListOfConnectionInfoJson = {
  /**
   * @generated from field: repeated io.clbs.openhes.models.acquisition.DeviceConnectionInfo items = 1;
   */
  items?: DeviceConnectionInfoJson[];

  /**
   * The total number of items.
   *
   * @generated from field: int32 total_count = 2;
   */
  totalCount?: number;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ListOfConnectionInfo.
 * Use `create(ListOfConnectionInfoSchema)` to create a new message.
 */
export const ListOfConnectionInfoSchema: GenMessage<ListOfConnectionInfo, {jsonType: ListOfConnectionInfoJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 56);

/**
 * Addon for DB
 *
 * @generated from message io.clbs.openhes.models.acquisition.FieldValuesList
 */
export type FieldValuesList = Message<"io.clbs.openhes.models.acquisition.FieldValuesList"> & {
  /**
   * The list of field values.
   *
   * @generated from field: repeated io.clbs.openhes.models.common.FieldValues items = 1;
   */
  items: FieldValues[];
};

/**
 * Addon for DB
 *
 * @generated from message io.clbs.openhes.models.acquisition.FieldValuesList
 */
export type FieldValuesListJson = {
  /**
   * The list of field values.
   *
   * @generated from field: repeated io.clbs.openhes.models.common.FieldValues items = 1;
   */
  items?: FieldValuesJson[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.FieldValuesList.
 * Use `create(FieldValuesListSchema)` to create a new message.
 */
export const FieldValuesListSchema: GenMessage<FieldValuesList, {jsonType: FieldValuesListJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 57);

/**
 * Generic attribute selector using field values
 *
 * @generated from message io.clbs.openhes.models.acquisition.ObjectAttributeSelector
 */
export type ObjectAttributeSelector = Message<"io.clbs.openhes.models.acquisition.ObjectAttributeSelector"> & {
  /**
   * The list of field values.
   *
   * @generated from field: io.clbs.openhes.models.common.FieldValues attributes = 1;
   */
  attributes?: FieldValues;
};

/**
 * Generic attribute selector using field values
 *
 * @generated from message io.clbs.openhes.models.acquisition.ObjectAttributeSelector
 */
export type ObjectAttributeSelectorJson = {
  /**
   * The list of field values.
   *
   * @generated from field: io.clbs.openhes.models.common.FieldValues attributes = 1;
   */
  attributes?: FieldValuesJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ObjectAttributeSelector.
 * Use `create(ObjectAttributeSelectorSchema)` to create a new message.
 */
export const ObjectAttributeSelectorSchema: GenMessage<ObjectAttributeSelector, {jsonType: ObjectAttributeSelectorJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 58);

/**
 * Sub-message containing action result for a single action.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionResult
 */
export type ActionResult = Message<"io.clbs.openhes.models.acquisition.ActionResult"> & {
  /**
   * The action identifier.
   *
   * @generated from field: string action_id = 1;
   */
  actionId: string;

  /**
   * The status of the action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionResultCode status = 2;
   */
  status: ActionResultCode;

  /**
   * The action result data.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionData data = 3;
   */
  data?: ActionData;

  /**
   * The register identifier. It is a read-only value, set only if the action data are related to a register. The value is applicable only and only for results for regular bulks.
   *
   * @generated from field: string register_id = 4;
   */
  registerId: string;

  /**
   * The variable name(s). It is a read-only value, set only if the action data are related to one or more variables based on device template mapping. The value is applicable only and only for results for regular bulks.
   *
   * @generated from field: repeated string variable_name = 5;
   */
  variableName: string[];
};

/**
 * Sub-message containing action result for a single action.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionResult
 */
export type ActionResultJson = {
  /**
   * The action identifier.
   *
   * @generated from field: string action_id = 1;
   */
  actionId?: string;

  /**
   * The status of the action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionResultCode status = 2;
   */
  status?: ActionResultCodeJson;

  /**
   * The action result data.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionData data = 3;
   */
  data?: ActionDataJson;

  /**
   * The register identifier. It is a read-only value, set only if the action data are related to a register. The value is applicable only and only for results for regular bulks.
   *
   * @generated from field: string register_id = 4;
   */
  registerId?: string;

  /**
   * The variable name(s). It is a read-only value, set only if the action data are related to one or more variables based on device template mapping. The value is applicable only and only for results for regular bulks.
   *
   * @generated from field: repeated string variable_name = 5;
   */
  variableName?: string[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionResult.
 * Use `create(ActionResultSchema)` to create a new message.
 */
export const ActionResultSchema: GenMessage<ActionResult, {jsonType: ActionResultJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 59);

/**
 * Taskmaster -> Dataproxy job/action progress update message
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobEventData
 */
export type JobEventData = Message<"io.clbs.openhes.models.acquisition.JobEventData"> & {
  /**
   * The job identifier.
   *
   * @generated from field: bytes job_id = 1;
   */
  jobId: Uint8Array;
};

/**
 * Taskmaster -> Dataproxy job/action progress update message
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobEventData
 */
export type JobEventDataJson = {
  /**
   * The job identifier.
   *
   * @generated from field: bytes job_id = 1;
   */
  jobId?: string;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.JobEventData.
 * Use `create(JobEventDataSchema)` to create a new message.
 */
export const JobEventDataSchema: GenMessage<JobEventData, {jsonType: JobEventDataJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 60);

/**
 * Sub-message - the device specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DeviceSpec
 */
export type DeviceSpec = Message<"io.clbs.openhes.models.acquisition.DeviceSpec"> & {
  /**
   * @gqltype: UUID
   *
   * The device configuration template identifier.
   *
   * @generated from field: string dct_id = 1;
   */
  dctId: string;

  /**
   * The external identifier of the device.
   *
   * @generated from field: string external_id = 2;
   */
  externalId: string;

  /**
   * The list of communication unit identifiers (and additional info) that set CUs usable to communicate with the device. It's an ordered set where the first element is the primary communication unit with the highest priority.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.DeviceCommunicationUnit communication_unit_link = 3;
   */
  communicationUnitLink: DeviceCommunicationUnit[];

  /**
   * The timezone related to the device, e.g. "America/New_York", "Europe/Prague", "CET", "GMT", "Etc/GMT+2".
   *
   * @generated from field: string timezone = 4;
   */
  timezone: string;
};

/**
 * Sub-message - the device specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DeviceSpec
 */
export type DeviceSpecJson = {
  /**
   * @gqltype: UUID
   *
   * The device configuration template identifier.
   *
   * @generated from field: string dct_id = 1;
   */
  dctId?: string;

  /**
   * The external identifier of the device.
   *
   * @generated from field: string external_id = 2;
   */
  externalId?: string;

  /**
   * The list of communication unit identifiers (and additional info) that set CUs usable to communicate with the device. It's an ordered set where the first element is the primary communication unit with the highest priority.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.DeviceCommunicationUnit communication_unit_link = 3;
   */
  communicationUnitLink?: DeviceCommunicationUnitJson[];

  /**
   * The timezone related to the device, e.g. "America/New_York", "Europe/Prague", "CET", "GMT", "Etc/GMT+2".
   *
   * @generated from field: string timezone = 4;
   */
  timezone?: string;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.DeviceSpec.
 * Use `create(DeviceSpecSchema)` to create a new message.
 */
export const DeviceSpecSchema: GenMessage<DeviceSpec, {jsonType: DeviceSpecJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 61);

/**
 * @generated from message io.clbs.openhes.models.acquisition.DeviceStatus
 */
export type DeviceStatus = Message<"io.clbs.openhes.models.acquisition.DeviceStatus"> & {
  /**
   * The device info.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.DeviceInfo info = 1;
   */
  info?: DeviceInfo;

  /**
   * The driver type selecte by it's device configuration template.
   *
   * @generated from field: string driver_type = 2;
   */
  driverType: string;
};

/**
 * @generated from message io.clbs.openhes.models.acquisition.DeviceStatus
 */
export type DeviceStatusJson = {
  /**
   * The device info.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.DeviceInfo info = 1;
   */
  info?: DeviceInfoJson;

  /**
   * The driver type selecte by it's device configuration template.
   *
   * @generated from field: string driver_type = 2;
   */
  driverType?: string;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.DeviceStatus.
 * Use `create(DeviceStatusSchema)` to create a new message.
 */
export const DeviceStatusSchema: GenMessage<DeviceStatus, {jsonType: DeviceStatusJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 62);

/**
 * @generated from message io.clbs.openhes.models.acquisition.DeviceCommunicationUnit
 */
export type DeviceCommunicationUnit = Message<"io.clbs.openhes.models.acquisition.DeviceCommunicationUnit"> & {
  /**
   * The unique identifier of the communication unit.
   *
   * @generated from field: string communication_unit_id = 1;
   */
  communicationUnitId: string;

  /**
   * The application protocol to be used for the communication over the communication unit.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ApplicationProtocol app_protocol = 2;
   */
  appProtocol: ApplicationProtocol;

  /**
   * The app-protocol related device attributes. It is represented as a list of attribute definitions.
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.FieldValue> attributes = 3;
   */
  attributes: { [key: string]: FieldValue };
};

/**
 * @generated from message io.clbs.openhes.models.acquisition.DeviceCommunicationUnit
 */
export type DeviceCommunicationUnitJson = {
  /**
   * The unique identifier of the communication unit.
   *
   * @generated from field: string communication_unit_id = 1;
   */
  communicationUnitId?: string;

  /**
   * The application protocol to be used for the communication over the communication unit.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ApplicationProtocol app_protocol = 2;
   */
  appProtocol?: ApplicationProtocolJson;

  /**
   * The app-protocol related device attributes. It is represented as a list of attribute definitions.
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.FieldValue> attributes = 3;
   */
  attributes?: { [key: string]: FieldValueJson };
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.DeviceCommunicationUnit.
 * Use `create(DeviceCommunicationUnitSchema)` to create a new message.
 */
export const DeviceCommunicationUnitSchema: GenMessage<DeviceCommunicationUnit, {jsonType: DeviceCommunicationUnitJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 63);

/**
 * Sub-message - job specification
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobSpec
 */
export type JobSpec = Message<"io.clbs.openhes.models.acquisition.JobSpec"> & {
  /**
   * The device info.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobDevice device = 2;
   */
  device?: JobDevice;

  /**
   * The job parameters.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobSettings job_settings = 3;
   */
  jobSettings?: JobSettings;

  /**
   * The device (driver) type.
   *
   * @generated from field: string driver_type = 4;
   */
  driverType: string;

  /**
   * The list actions to be executed.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.JobAction job_actions = 5;
   */
  jobActions: JobAction[];

  /**
   * The mapping data for all actions.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.JobActionMapRecord job_action_info = 6;
   */
  jobActionInfo: JobActionMapRecord[];
};

/**
 * Sub-message - job specification
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobSpec
 */
export type JobSpecJson = {
  /**
   * The device info.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobDevice device = 2;
   */
  device?: JobDeviceJson;

  /**
   * The job parameters.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobSettings job_settings = 3;
   */
  jobSettings?: JobSettingsJson;

  /**
   * The device (driver) type.
   *
   * @generated from field: string driver_type = 4;
   */
  driverType?: string;

  /**
   * The list actions to be executed.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.JobAction job_actions = 5;
   */
  jobActions?: JobActionJson[];

  /**
   * The mapping data for all actions.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.JobActionMapRecord job_action_info = 6;
   */
  jobActionInfo?: JobActionMapRecordJson[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.JobSpec.
 * Use `create(JobSpecSchema)` to create a new message.
 */
export const JobSpecSchema: GenMessage<JobSpec, {jsonType: JobSpecJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 64);

/**
 * @generated from message io.clbs.openhes.models.acquisition.JobActionMapRecord
 */
export type JobActionMapRecord = Message<"io.clbs.openhes.models.acquisition.JobActionMapRecord"> & {
  /**
   * The index of the action in the job_actions list.
   *
   * @generated from field: int32 action_index = 1;
   */
  actionIndex: number;

  /**
   * The internal register identifier.
   *
   * @generated from field: int64 register_id = 3;
   */
  registerId: bigint;

  /**
   * The register identifier.
   *
   * @generated from field: string public_register_id = 2;
   */
  publicRegisterId: string;

  /**
   * The name of the variable, if the register is assigned to some.
   *
   * @generated from field: repeated string variable_name = 4;
   */
  variableName: string[];
};

/**
 * @generated from message io.clbs.openhes.models.acquisition.JobActionMapRecord
 */
export type JobActionMapRecordJson = {
  /**
   * The index of the action in the job_actions list.
   *
   * @generated from field: int32 action_index = 1;
   */
  actionIndex?: number;

  /**
   * The internal register identifier.
   *
   * @generated from field: int64 register_id = 3;
   */
  registerId?: string;

  /**
   * The register identifier.
   *
   * @generated from field: string public_register_id = 2;
   */
  publicRegisterId?: string;

  /**
   * The name of the variable, if the register is assigned to some.
   *
   * @generated from field: repeated string variable_name = 4;
   */
  variableName?: string[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.JobActionMapRecord.
 * Use `create(JobActionMapRecordSchema)` to create a new message.
 */
export const JobActionMapRecordSchema: GenMessage<JobActionMapRecord, {jsonType: JobActionMapRecordJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 65);

/**
 * Message used to notify DP that the job is done, sent by Taskmaster
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobDoneNotification
 */
export type JobDoneNotification = Message<"io.clbs.openhes.models.acquisition.JobDoneNotification"> & {
  /**
   * The job specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobSpec spec = 1;
   */
  spec?: JobSpec;

  /**
   * The status of the job
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobStatus status = 2;
   */
  status?: JobStatus;
};

/**
 * Message used to notify DP that the job is done, sent by Taskmaster
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobDoneNotification
 */
export type JobDoneNotificationJson = {
  /**
   * The job specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobSpec spec = 1;
   */
  spec?: JobSpecJson;

  /**
   * The status of the job
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobStatus status = 2;
   */
  status?: JobStatusJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.JobDoneNotification.
 * Use `create(JobDoneNotificationSchema)` to create a new message.
 */
export const JobDoneNotificationSchema: GenMessage<JobDoneNotification, {jsonType: JobDoneNotificationJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 66);

/**
 * Sub-message containing driver info
 *
 * @generated from message io.clbs.openhes.models.acquisition.DriverInfo
 */
export type DriverInfo = Message<"io.clbs.openhes.models.acquisition.DriverInfo"> & {
  /**
   * The driver unique identifier.
   *
   * @generated from field: string driver_type = 1;
   */
  driverType: string;

  /**
   * The version of the driver.
   *
   * @generated from field: string version = 2;
   */
  version: string;
};

/**
 * Sub-message containing driver info
 *
 * @generated from message io.clbs.openhes.models.acquisition.DriverInfo
 */
export type DriverInfoJson = {
  /**
   * The driver unique identifier.
   *
   * @generated from field: string driver_type = 1;
   */
  driverType?: string;

  /**
   * The version of the driver.
   *
   * @generated from field: string version = 2;
   */
  version?: string;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.DriverInfo.
 * Use `create(DriverInfoSchema)` to create a new message.
 */
export const DriverInfoSchema: GenMessage<DriverInfo, {jsonType: DriverInfoJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 67);

/**
 * @generated from message io.clbs.openhes.models.acquisition.CommunicationUnit
 */
export type CommunicationUnit = Message<"io.clbs.openhes.models.acquisition.CommunicationUnit"> & {
  /**
   * The communication unit specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.CommunicationUnitSpec spec = 1;
   */
  spec?: CommunicationUnitSpec;

  /**
   * The metadata fields.
   *
   * @generated from field: io.clbs.openhes.models.common.MetadataFields metadata = 3;
   */
  metadata?: MetadataFields;
};

/**
 * @generated from message io.clbs.openhes.models.acquisition.CommunicationUnit
 */
export type CommunicationUnitJson = {
  /**
   * The communication unit specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.CommunicationUnitSpec spec = 1;
   */
  spec?: CommunicationUnitSpecJson;

  /**
   * The metadata fields.
   *
   * @generated from field: io.clbs.openhes.models.common.MetadataFields metadata = 3;
   */
  metadata?: MetadataFieldsJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.CommunicationUnit.
 * Use `create(CommunicationUnitSchema)` to create a new message.
 */
export const CommunicationUnitSchema: GenMessage<CommunicationUnit, {jsonType: CommunicationUnitJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 68);

/**
 * @generated from message io.clbs.openhes.models.acquisition.CommunicationUnitSpec
 */
export type CommunicationUnitSpec = Message<"io.clbs.openhes.models.acquisition.CommunicationUnitSpec"> & {
  /**
   * The external identifier of the communication unit.
   *
   * @generated from field: string external_id = 1;
   */
  externalId: string;

  /**
   * The connection info.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ConnectionInfo connection_info = 2;
   */
  connectionInfo?: ConnectionInfo;
};

/**
 * @generated from message io.clbs.openhes.models.acquisition.CommunicationUnitSpec
 */
export type CommunicationUnitSpecJson = {
  /**
   * The external identifier of the communication unit.
   *
   * @generated from field: string external_id = 1;
   */
  externalId?: string;

  /**
   * The connection info.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ConnectionInfo connection_info = 2;
   */
  connectionInfo?: ConnectionInfoJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.CommunicationUnitSpec.
 * Use `create(CommunicationUnitSpecSchema)` to create a new message.
 */
export const CommunicationUnitSpecSchema: GenMessage<CommunicationUnitSpec, {jsonType: CommunicationUnitSpecJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 69);

/**
 * @generated from message io.clbs.openhes.models.acquisition.CommunicationBus
 */
export type CommunicationBus = Message<"io.clbs.openhes.models.acquisition.CommunicationBus"> & {
  /**
   * The communication bus status.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.CommunicationBusStatus status = 2;
   */
  status?: CommunicationBusStatus;

  /**
   * The metadata fields.
   *
   * @generated from field: io.clbs.openhes.models.common.MetadataFields metadata = 3;
   */
  metadata?: MetadataFields;
};

/**
 * @generated from message io.clbs.openhes.models.acquisition.CommunicationBus
 */
export type CommunicationBusJson = {
  /**
   * The communication bus status.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.CommunicationBusStatus status = 2;
   */
  status?: CommunicationBusStatusJson;

  /**
   * The metadata fields.
   *
   * @generated from field: io.clbs.openhes.models.common.MetadataFields metadata = 3;
   */
  metadata?: MetadataFieldsJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.CommunicationBus.
 * Use `create(CommunicationBusSchema)` to create a new message.
 */
export const CommunicationBusSchema: GenMessage<CommunicationBus, {jsonType: CommunicationBusJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 70);

/**
 * @generated from message io.clbs.openhes.models.acquisition.CommunicationBusStatus
 */
export type CommunicationBusStatus = Message<"io.clbs.openhes.models.acquisition.CommunicationBusStatus"> & {
  /**
   * The list of communication unit identifiers.
   *
   * @generated from field: repeated string communication_unit_id = 1;
   */
  communicationUnitId: string[];
};

/**
 * @generated from message io.clbs.openhes.models.acquisition.CommunicationBusStatus
 */
export type CommunicationBusStatusJson = {
  /**
   * The list of communication unit identifiers.
   *
   * @generated from field: repeated string communication_unit_id = 1;
   */
  communicationUnitId?: string[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.CommunicationBusStatus.
 * Use `create(CommunicationBusStatusSchema)` to create a new message.
 */
export const CommunicationBusStatusSchema: GenMessage<CommunicationBusStatus, {jsonType: CommunicationBusStatusJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 71);

/**
 * Job priorities
 *
 * @generated from enum io.clbs.openhes.models.acquisition.JobPriority
 */
export enum JobPriority {
  /**
   * The lowest priority
   *
   * @generated from enum value: JOB_PRIORITY_0 = 0;
   */
  JOB_PRIORITY_0 = 0,

  /**
   * The priority 1
   *
   * @generated from enum value: JOB_PRIORITY_1 = 1;
   */
  JOB_PRIORITY_1 = 1,

  /**
   * The priority 2
   *
   * @generated from enum value: JOB_PRIORITY_2 = 2;
   */
  JOB_PRIORITY_2 = 2,

  /**
   * The priority 3
   *
   * @generated from enum value: JOB_PRIORITY_3 = 3;
   */
  JOB_PRIORITY_3 = 3,

  /**
   * The priority 4
   *
   * @generated from enum value: JOB_PRIORITY_4 = 4;
   */
  JOB_PRIORITY_4 = 4,

  /**
   * The priority 5
   *
   * @generated from enum value: JOB_PRIORITY_5 = 5;
   */
  JOB_PRIORITY_5 = 5,

  /**
   * The priority 6
   *
   * @generated from enum value: JOB_PRIORITY_6 = 6;
   */
  JOB_PRIORITY_6 = 6,

  /**
   * The priority 7
   *
   * @generated from enum value: JOB_PRIORITY_7 = 7;
   */
  JOB_PRIORITY_7 = 7,

  /**
   * The highest priority
   *
   * @generated from enum value: JOB_PRIORITY_8 = 8;
   */
  JOB_PRIORITY_8 = 8,
}

/**
 * Job priorities
 *
 * @generated from enum io.clbs.openhes.models.acquisition.JobPriority
 */
export type JobPriorityJson = "JOB_PRIORITY_0" | "JOB_PRIORITY_1" | "JOB_PRIORITY_2" | "JOB_PRIORITY_3" | "JOB_PRIORITY_4" | "JOB_PRIORITY_5" | "JOB_PRIORITY_6" | "JOB_PRIORITY_7" | "JOB_PRIORITY_8";

/**
 * Describes the enum io.clbs.openhes.models.acquisition.JobPriority.
 */
export const JobPrioritySchema: GenEnum<JobPriority, JobPriorityJson> = /*@__PURE__*/
  enumDesc(file_acquisition_shared, 0);

/**
 * Parity types
 *
 * @generated from enum io.clbs.openhes.models.acquisition.SerialConfigParity
 */
export enum SerialConfigParity {
  /**
   * No parity
   *
   * @generated from enum value: PARITY_NONE = 0;
   */
  PARITY_NONE = 0,

  /**
   * Even parity
   *
   * @generated from enum value: PARITY_EVEN = 1;
   */
  PARITY_EVEN = 1,

  /**
   * Odd parity
   *
   * @generated from enum value: PARITY_ODD = 2;
   */
  PARITY_ODD = 2,

  /**
   * Mark parity
   *
   * @generated from enum value: PARITY_MARK = 3;
   */
  PARITY_MARK = 3,

  /**
   * Space parity
   *
   * @generated from enum value: PARITY_SPACE = 4;
   */
  PARITY_SPACE = 4,
}

/**
 * Parity types
 *
 * @generated from enum io.clbs.openhes.models.acquisition.SerialConfigParity
 */
export type SerialConfigParityJson = "PARITY_NONE" | "PARITY_EVEN" | "PARITY_ODD" | "PARITY_MARK" | "PARITY_SPACE";

/**
 * Describes the enum io.clbs.openhes.models.acquisition.SerialConfigParity.
 */
export const SerialConfigParitySchema: GenEnum<SerialConfigParity, SerialConfigParityJson> = /*@__PURE__*/
  enumDesc(file_acquisition_shared, 1);

/**
 * Baud rate types
 *
 * @generated from enum io.clbs.openhes.models.acquisition.SerialConfigBaudRate
 */
export enum SerialConfigBaudRate {
  /**
   * 110 baud
   *
   * @generated from enum value: BAUD_RATE_110 = 0;
   */
  BAUD_RATE_110 = 0,

  /**
   * 300 baud
   *
   * @generated from enum value: BAUD_RATE_300 = 1;
   */
  BAUD_RATE_300 = 1,

  /**
   * 600 baud
   *
   * @generated from enum value: BAUD_RATE_600 = 2;
   */
  BAUD_RATE_600 = 2,

  /**
   * 1200 baud
   *
   * @generated from enum value: BAUD_RATE_1200 = 3;
   */
  BAUD_RATE_1200 = 3,

  /**
   * 2400 baud
   *
   * @generated from enum value: BAUD_RATE_2400 = 4;
   */
  BAUD_RATE_2400 = 4,

  /**
   * 4800 baud
   *
   * @generated from enum value: BAUD_RATE_4800 = 5;
   */
  BAUD_RATE_4800 = 5,

  /**
   * 9600 baud
   *
   * @generated from enum value: BAUD_RATE_9600 = 6;
   */
  BAUD_RATE_9600 = 6,

  /**
   * 14400 baud
   *
   * @generated from enum value: BAUD_RATE_14400 = 7;
   */
  BAUD_RATE_14400 = 7,

  /**
   * 19200 baud
   *
   * @generated from enum value: BAUD_RATE_19200 = 8;
   */
  BAUD_RATE_19200 = 8,

  /**
   * 38400 baud
   *
   * @generated from enum value: BAUD_RATE_38400 = 9;
   */
  BAUD_RATE_38400 = 9,

  /**
   * 57600 baud
   *
   * @generated from enum value: BAUD_RATE_57600 = 10;
   */
  BAUD_RATE_57600 = 10,

  /**
   * 115200 baud
   *
   * @generated from enum value: BAUD_RATE_115200 = 11;
   */
  BAUD_RATE_115200 = 11,

  /**
   * 230400 baud
   *
   * @generated from enum value: BAUD_RATE_230400 = 12;
   */
  BAUD_RATE_230400 = 12,

  /**
   * 460800 baud
   *
   * @generated from enum value: BAUD_RATE_460800 = 13;
   */
  BAUD_RATE_460800 = 13,

  /**
   * 921600 baud
   *
   * @generated from enum value: BAUD_RATE_921600 = 14;
   */
  BAUD_RATE_921600 = 14,
}

/**
 * Baud rate types
 *
 * @generated from enum io.clbs.openhes.models.acquisition.SerialConfigBaudRate
 */
export type SerialConfigBaudRateJson = "BAUD_RATE_110" | "BAUD_RATE_300" | "BAUD_RATE_600" | "BAUD_RATE_1200" | "BAUD_RATE_2400" | "BAUD_RATE_4800" | "BAUD_RATE_9600" | "BAUD_RATE_14400" | "BAUD_RATE_19200" | "BAUD_RATE_38400" | "BAUD_RATE_57600" | "BAUD_RATE_115200" | "BAUD_RATE_230400" | "BAUD_RATE_460800" | "BAUD_RATE_921600";

/**
 * Describes the enum io.clbs.openhes.models.acquisition.SerialConfigBaudRate.
 */
export const SerialConfigBaudRateSchema: GenEnum<SerialConfigBaudRate, SerialConfigBaudRateJson> = /*@__PURE__*/
  enumDesc(file_acquisition_shared, 2);

/**
 * Data bits types
 *
 * @generated from enum io.clbs.openhes.models.acquisition.SerialConfigDataBits
 */
export enum SerialConfigDataBits {
  /**
   * 5 data bits
   *
   * @generated from enum value: DATA_BITS_5 = 0;
   */
  DATA_BITS_5 = 0,

  /**
   * 6 data bits
   *
   * @generated from enum value: DATA_BITS_6 = 1;
   */
  DATA_BITS_6 = 1,

  /**
   * 7 data bits
   *
   * @generated from enum value: DATA_BITS_7 = 2;
   */
  DATA_BITS_7 = 2,

  /**
   * 8 data bits
   *
   * @generated from enum value: DATA_BITS_8 = 3;
   */
  DATA_BITS_8 = 3,
}

/**
 * Data bits types
 *
 * @generated from enum io.clbs.openhes.models.acquisition.SerialConfigDataBits
 */
export type SerialConfigDataBitsJson = "DATA_BITS_5" | "DATA_BITS_6" | "DATA_BITS_7" | "DATA_BITS_8";

/**
 * Describes the enum io.clbs.openhes.models.acquisition.SerialConfigDataBits.
 */
export const SerialConfigDataBitsSchema: GenEnum<SerialConfigDataBits, SerialConfigDataBitsJson> = /*@__PURE__*/
  enumDesc(file_acquisition_shared, 3);

/**
 * Stop bits types
 *
 * @generated from enum io.clbs.openhes.models.acquisition.SerialConfigStopBits
 */
export enum SerialConfigStopBits {
  /**
   * 1 stop bit
   *
   * @generated from enum value: STOP_BITS_1 = 0;
   */
  STOP_BITS_1 = 0,

  /**
   * 1.5 stop bits
   *
   * @generated from enum value: STOP_BITS_1_5 = 1;
   */
  STOP_BITS_1_5 = 1,

  /**
   * 2 stop bits
   *
   * @generated from enum value: STOP_BITS_2 = 2;
   */
  STOP_BITS_2 = 2,
}

/**
 * Stop bits types
 *
 * @generated from enum io.clbs.openhes.models.acquisition.SerialConfigStopBits
 */
export type SerialConfigStopBitsJson = "STOP_BITS_1" | "STOP_BITS_1_5" | "STOP_BITS_2";

/**
 * Describes the enum io.clbs.openhes.models.acquisition.SerialConfigStopBits.
 */
export const SerialConfigStopBitsSchema: GenEnum<SerialConfigStopBits, SerialConfigStopBitsJson> = /*@__PURE__*/
  enumDesc(file_acquisition_shared, 4);

/**
 * Connection types
 *
 * @generated from enum io.clbs.openhes.models.acquisition.CommunicationType
 */
export enum CommunicationType {
  /**
   * The communication is done via direct TCP/IP.
   *
   * @generated from enum value: COMMUNICATION_TYPE_TCPIP = 0;
   */
  TCPIP = 0,

  /**
   * The communication is done via phone line (modem).
   *
   * @generated from enum value: COMMUNICATION_TYPE_MODEM_POOL = 1;
   */
  MODEM_POOL = 1,

  /**
   * The communication is done via direct serial line.
   *
   * @generated from enum value: COMMUNICATION_TYPE_SERIAL_LINE_DIRECT = 2;
   */
  SERIAL_LINE_DIRECT = 2,

  /**
   * The communication is done via controller-serial line (Moxa).
   *
   * @generated from enum value: COMMUNICATION_TYPE_SERIAL_LINE_MOXA = 3;
   */
  SERIAL_LINE_MOXA = 3,

  /**
   * The communication is passive, the driver is a service that listens on a port (DLMS devices in push mode) or a service that implements a subscriber to a message queue (e.g. MQTT).
   *
   * @generated from enum value: COMMUNICATION_TYPE_LISTENING = 99;
   */
  LISTENING = 99,
}

/**
 * Connection types
 *
 * @generated from enum io.clbs.openhes.models.acquisition.CommunicationType
 */
export type CommunicationTypeJson = "COMMUNICATION_TYPE_TCPIP" | "COMMUNICATION_TYPE_MODEM_POOL" | "COMMUNICATION_TYPE_SERIAL_LINE_DIRECT" | "COMMUNICATION_TYPE_SERIAL_LINE_MOXA" | "COMMUNICATION_TYPE_LISTENING";

/**
 * Describes the enum io.clbs.openhes.models.acquisition.CommunicationType.
 */
export const CommunicationTypeSchema: GenEnum<CommunicationType, CommunicationTypeJson> = /*@__PURE__*/
  enumDesc(file_acquisition_shared, 5);

/**
 * Data link protocols
 *
 * @generated from enum io.clbs.openhes.models.acquisition.DataLinkProtocol
 */
export enum DataLinkProtocol {
  /**
   * The VDEW (IEC 62056-21, IEC-61107) protocol. In combination with DLMS protocol the driver initiates the communication by IEC and switches to the mode E to the HDLC+DLMS protocol. Supports addressing = multiple devices on the same line.
   *
   * @generated from enum value: LINKPROTO_IEC_62056_21 = 0;
   */
  LINKPROTO_IEC_62056_21 = 0,

  /**
   * The HDLC (ISO/IEC-3309) framing. It can be used for various application protocols, such as DLMS or MODBUS. Supports client/server addressing = multiple devices on the same line.
   *
   * @generated from enum value: LINKPROTO_HDLC = 1;
   */
  LINKPROTO_HDLC = 1,

  /**
   * The COSEM wrapper. It can be used for DLMS application protocol. Supports client/server addressing = multiple devices on the same line.
   *
   * @generated from enum value: LINKPROTO_COSEM_WRAPPER = 2;
   */
  LINKPROTO_COSEM_WRAPPER = 2,

  /**
   * The Modbus protocol. It shall be used for Modbus application protocol where no other data link layer, such as HDLC, is used.
   *
   * @generated from enum value: LINKPROTO_MODBUS = 3;
   */
  LINKPROTO_MODBUS = 3,

  /**
   * The M-Bus protocol. It shall be used for M-Bus application protocol.
   *
   * @generated from enum value: LINKPROTO_MBUS = 4;
   */
  LINKPROTO_MBUS = 4,

  /**
   * The Viktor protocol. It is a proprietary protocol used by Viktor-based devices, such as DC450 Vitkor.
   *
   * @generated from enum value: LINKPROTO_VIKTOR = 5;
   */
  LINKPROTO_VIKTOR = 5,

  /**
   * The data link protocol is not applicable. It's useful for listening communication type.
   *
   * @generated from enum value: LINKPROTO_NOT_APPLICABLE = 99;
   */
  LINKPROTO_NOT_APPLICABLE = 99,
}

/**
 * Data link protocols
 *
 * @generated from enum io.clbs.openhes.models.acquisition.DataLinkProtocol
 */
export type DataLinkProtocolJson = "LINKPROTO_IEC_62056_21" | "LINKPROTO_HDLC" | "LINKPROTO_COSEM_WRAPPER" | "LINKPROTO_MODBUS" | "LINKPROTO_MBUS" | "LINKPROTO_VIKTOR" | "LINKPROTO_NOT_APPLICABLE";

/**
 * Describes the enum io.clbs.openhes.models.acquisition.DataLinkProtocol.
 */
export const DataLinkProtocolSchema: GenEnum<DataLinkProtocol, DataLinkProtocolJson> = /*@__PURE__*/
  enumDesc(file_acquisition_shared, 6);

/**
 * Application protocols
 *
 * @generated from enum io.clbs.openhes.models.acquisition.ApplicationProtocol
 */
export enum ApplicationProtocol {
  /**
   * The IEC 62056-21 (IEC-61107, VDEW) protocol.
   *
   * @generated from enum value: APPPROTO_IEC_62056_21 = 0;
   */
  APPPROTO_IEC_62056_21 = 0,

  /**
   * The DLMS short-name protocol.
   *
   * @generated from enum value: APPPROTO_DLMS_SN = 1;
   */
  APPPROTO_DLMS_SN = 1,

  /**
   * The DLMS logical-name protocol.
   *
   * @generated from enum value: APPPROTO_DLMS_LN = 2;
   */
  APPPROTO_DLMS_LN = 2,

  /**
   * The SCTM protocol.
   *
   * @generated from enum value: APPPROTO_SCTM = 3;
   */
  APPPROTO_SCTM = 3,

  /**
   * The LIS200 protocol.
   *
   * @generated from enum value: APPPROTO_LIS200 = 4;
   */
  APPPROTO_LIS200 = 4,

  /**
   * The ANSI C12 protocol.
   *
   * @generated from enum value: APPPROTO_ANSI_C12 = 5;
   */
  APPPROTO_ANSI_C12 = 5,

  /**
   * The MQTT protocol.
   *
   * @generated from enum value: APPPROTO_MQTT = 6;
   */
  APPPROTO_MQTT = 6,
}

/**
 * Application protocols
 *
 * @generated from enum io.clbs.openhes.models.acquisition.ApplicationProtocol
 */
export type ApplicationProtocolJson = "APPPROTO_IEC_62056_21" | "APPPROTO_DLMS_SN" | "APPPROTO_DLMS_LN" | "APPPROTO_SCTM" | "APPPROTO_LIS200" | "APPPROTO_ANSI_C12" | "APPPROTO_MQTT";

/**
 * Describes the enum io.clbs.openhes.models.acquisition.ApplicationProtocol.
 */
export const ApplicationProtocolSchema: GenEnum<ApplicationProtocol, ApplicationProtocolJson> = /*@__PURE__*/
  enumDesc(file_acquisition_shared, 7);

/**
 * Action types
 *
 * @generated from enum io.clbs.openhes.models.acquisition.ActionType
 */
export enum ActionType {
  /**
   * Get register value, for example instantaneous values. The action covers specific register.
   *
   * @generated from enum value: ACTION_TYPE_GET_REGISTER = 0;
   */
  GET_REGISTER = 0,

  /**
   * Get periodical profile, for example load-profile. The action covers specific profile column.
   *
   * @generated from enum value: ACTION_TYPE_GET_PERIODICAL_PROFILE = 1;
   */
  GET_PERIODICAL_PROFILE = 1,

  /**
   * Get non-periodical profile, for example daily profile or monthly billing registers. The action covers specific profile column and or specific billing register.
   *
   * @generated from enum value: ACTION_TYPE_GET_IRREGULAR_PROFILE = 2;
   */
  GET_IRREGULAR_PROFILE = 2,

  /**
   * Get event log. The action covers specific event log.
   *
   * @generated from enum value: ACTION_TYPE_GET_EVENTS = 3;
   */
  GET_EVENTS = 3,

  /**
   * Get device info. The action returns info data about remote device.
   *
   * @generated from enum value: ACTION_TYPE_GET_DEVICE_INFO = 10;
   */
  GET_DEVICE_INFO = 10,

  /**
   * Synchornize clock. The action synchronizes the time in the device, it can forcefully set it if force attribute is set.
   *
   * @generated from enum value: ACTION_TYPE_SYNC_CLOCK = 11;
   */
  SYNC_CLOCK = 11,

  /**
   * Set relay state. The action covers single relay.
   *
   * @generated from enum value: ACTION_TYPE_SET_RELAY_STATE = 21;
   */
  SET_RELAY_STATE = 21,

  /**
   * Get disconnector state. The action covers single disconnector if multiple disconnectors are present in the device.
   *
   * @generated from enum value: ACTION_TYPE_GET_DISCONNECTOR_STATE = 22;
   */
  GET_DISCONNECTOR_STATE = 22,

  /**
   * Set disconnector state. The action covers single relay. The action covers single disconnector if multiple disconnectors are present in the device.
   *
   * @generated from enum value: ACTION_TYPE_SET_DISCONNECTOR_STATE = 23;
   */
  SET_DISCONNECTOR_STATE = 23,

  /**
   * Get time-of-use table.
   *
   * @generated from enum value: ACTION_TYPE_GET_TOU = 24;
   */
  GET_TOU = 24,

  /**
   * Set time-of-use table.
   *
   * @generated from enum value: ACTION_TYPE_SET_TOU = 25;
   */
  SET_TOU = 25,

  /**
   * Set limiter settings. The action covers single limiter.
   *
   * @generated from enum value: ACTION_TYPE_SET_LIMITER = 27;
   */
  SET_LIMITER = 27,

  /**
   * Reseet billing period.
   *
   * @generated from enum value: ACTION_TYPE_RESET_BILLING_PERIOD = 40;
   */
  RESET_BILLING_PERIOD = 40,

  /**
   * Start firmware update. The action updates starts FW upgrade procedure.
   *
   * @generated from enum value: ACTION_TYPE_FW_UPDATE = 50;
   */
  FW_UPDATE = 50,
}

/**
 * Action types
 *
 * @generated from enum io.clbs.openhes.models.acquisition.ActionType
 */
export type ActionTypeJson = "ACTION_TYPE_GET_REGISTER" | "ACTION_TYPE_GET_PERIODICAL_PROFILE" | "ACTION_TYPE_GET_IRREGULAR_PROFILE" | "ACTION_TYPE_GET_EVENTS" | "ACTION_TYPE_GET_DEVICE_INFO" | "ACTION_TYPE_SYNC_CLOCK" | "ACTION_TYPE_SET_RELAY_STATE" | "ACTION_TYPE_GET_DISCONNECTOR_STATE" | "ACTION_TYPE_SET_DISCONNECTOR_STATE" | "ACTION_TYPE_GET_TOU" | "ACTION_TYPE_SET_TOU" | "ACTION_TYPE_SET_LIMITER" | "ACTION_TYPE_RESET_BILLING_PERIOD" | "ACTION_TYPE_FW_UPDATE";

/**
 * Describes the enum io.clbs.openhes.models.acquisition.ActionType.
 */
export const ActionTypeSchema: GenEnum<ActionType, ActionTypeJson> = /*@__PURE__*/
  enumDesc(file_acquisition_shared, 8);

/**
 * Result codes related to job actions
 *
 * @generated from enum io.clbs.openhes.models.acquisition.ActionResultCode
 */
export enum ActionResultCode {
  /**
   * The action has been completed successfully.
   *
   * @generated from enum value: ERROR_CODE_ACTION_OK = 0;
   */
  ERROR_CODE_ACTION_OK = 0,

  /**
   * The action is not supported by the driver (or device).
   *
   * @generated from enum value: ERROR_CODE_ACTION_UNSUPPORTED = 1;
   */
  ERROR_CODE_ACTION_UNSUPPORTED = 1,

  /**
   * The action is pending.
   *
   * @generated from enum value: ERROR_CODE_ACTION_PENDING = 3;
   */
  ERROR_CODE_ACTION_PENDING = 3,

  /**
   * The action failed.
   *
   * @generated from enum value: ERROR_CODE_ACTION_ERROR = 5;
   */
  ERROR_CODE_ACTION_ERROR = 5,
}

/**
 * Result codes related to job actions
 *
 * @generated from enum io.clbs.openhes.models.acquisition.ActionResultCode
 */
export type ActionResultCodeJson = "ERROR_CODE_ACTION_OK" | "ERROR_CODE_ACTION_UNSUPPORTED" | "ERROR_CODE_ACTION_PENDING" | "ERROR_CODE_ACTION_ERROR";

/**
 * Describes the enum io.clbs.openhes.models.acquisition.ActionResultCode.
 */
export const ActionResultCodeSchema: GenEnum<ActionResultCode, ActionResultCodeJson> = /*@__PURE__*/
  enumDesc(file_acquisition_shared, 9);

/**
 * Error codes related to jobs
 *
 * @generated from enum io.clbs.openhes.models.acquisition.JobErrorCode
 */
export enum JobErrorCode {
  /**
   * The job has been completed successfully.
   *
   * @generated from enum value: JOB_ERROR_CODE_NONE = 0;
   */
  NONE = 0,

  /**
   * There is no free slot in the driver to handle the job; the job shall be send again later.
   *
   * @generated from enum value: JOB_ERROR_CODE_BUSY = 1;
   */
  BUSY = 1,

  /**
   * The job failed, the retry will be attempted.
   *
   * @generated from enum value: JOB_ERROR_CODE_ERROR = 5;
   */
  ERROR = 5,

  /**
   * This should never happen! It means that the same job is currently being processed by the driver and it was sent to the driver mutliple times which would mean that there is a bug.
   *
   * @generated from enum value: JOB_ERROR_CODE_ALREADY_EXISTS = 8;
   */
  ALREADY_EXISTS = 8,

  /**
   * The job failed, the retry will NOT be attempted.
   *
   * @generated from enum value: JOB_ERROR_CODE_FATAL = 9;
   */
  FATAL = 9,
}

/**
 * Error codes related to jobs
 *
 * @generated from enum io.clbs.openhes.models.acquisition.JobErrorCode
 */
export type JobErrorCodeJson = "JOB_ERROR_CODE_NONE" | "JOB_ERROR_CODE_BUSY" | "JOB_ERROR_CODE_ERROR" | "JOB_ERROR_CODE_ALREADY_EXISTS" | "JOB_ERROR_CODE_FATAL";

/**
 * Describes the enum io.clbs.openhes.models.acquisition.JobErrorCode.
 */
export const JobErrorCodeSchema: GenEnum<JobErrorCode, JobErrorCodeJson> = /*@__PURE__*/
  enumDesc(file_acquisition_shared, 10);

/**
 * Bulk statuses
 *
 * @generated from enum io.clbs.openhes.models.acquisition.BulkStatusCode
 */
export enum BulkStatusCode {
  /**
   * The job is waiting in the queue
   *
   * @generated from enum value: BULK_STATUS_QUEUED = 0;
   */
  BULK_STATUS_QUEUED = 0,

  /**
   * The job is running
   *
   * @generated from enum value: BULK_STATUS_RUNNING = 1;
   */
  BULK_STATUS_RUNNING = 1,

  /**
   * The job is completed
   *
   * @generated from enum value: BULK_STATUS_COMPLETED = 2;
   */
  BULK_STATUS_COMPLETED = 2,

  /**
   * The job is cancelled
   *
   * @generated from enum value: BULK_STATUS_CANCELLED = 3;
   */
  BULK_STATUS_CANCELLED = 3,

  /**
   * The job has expired
   *
   * @generated from enum value: BULK_STATUS_EXPIRED = 4;
   */
  BULK_STATUS_EXPIRED = 4,
}

/**
 * Bulk statuses
 *
 * @generated from enum io.clbs.openhes.models.acquisition.BulkStatusCode
 */
export type BulkStatusCodeJson = "BULK_STATUS_QUEUED" | "BULK_STATUS_RUNNING" | "BULK_STATUS_COMPLETED" | "BULK_STATUS_CANCELLED" | "BULK_STATUS_EXPIRED";

/**
 * Describes the enum io.clbs.openhes.models.acquisition.BulkStatusCode.
 */
export const BulkStatusCodeSchema: GenEnum<BulkStatusCode, BulkStatusCodeJson> = /*@__PURE__*/
  enumDesc(file_acquisition_shared, 11);

/**
 * @generated from enum io.clbs.openhes.models.acquisition.RegisterType
 */
export enum RegisterType {
  /**
   * The register is a generic register.
   *
   * @generated from enum value: Register = 0;
   */
  Register = 0,

  /**
   * The register is part of a periodical profile.
   *
   * @generated from enum value: PeriodicalProfile = 1;
   */
  PeriodicalProfile = 1,

  /**
   * The register is part of an irregular profile.
   *
   * @generated from enum value: IrregularProfile = 2;
   */
  IrregularProfile = 2,

  /**
   * Synthetic register, not visible by drivers. It can be defined to store derived or external data.
   *
   * @generated from enum value: Synthetic = 99;
   */
  Synthetic = 99,
}

/**
 * @generated from enum io.clbs.openhes.models.acquisition.RegisterType
 */
export type RegisterTypeJson = "Register" | "PeriodicalProfile" | "IrregularProfile" | "Synthetic";

/**
 * Describes the enum io.clbs.openhes.models.acquisition.RegisterType.
 */
export const RegisterTypeSchema: GenEnum<RegisterType, RegisterTypeJson> = /*@__PURE__*/
  enumDesc(file_acquisition_shared, 12);

/**
 * Job statuses
 *
 * @generated from enum io.clbs.openhes.models.acquisition.JobStatusCode
 */
export enum JobStatusCode {
  /**
   * The job is waiting in the queue
   *
   * @generated from enum value: JOB_STATUS_QUEUED = 0;
   */
  JOB_STATUS_QUEUED = 0,

  /**
   * The job is running
   *
   * @generated from enum value: JOB_STATUS_RUNNING = 1;
   */
  JOB_STATUS_RUNNING = 1,

  /**
   * The data has been fully acquired and is being processed
   *
   * @generated from enum value: JOB_STATUS_PROCESSING_DATA = 2;
   */
  JOB_STATUS_PROCESSING_DATA = 2,

  /**
   * The job is completed
   *
   * @generated from enum value: JOB_STATUS_COMPLETED = 3;
   */
  JOB_STATUS_COMPLETED = 3,

  /**
   * The job is failed
   *
   * @generated from enum value: JOB_STATUS_FAILED = 4;
   */
  JOB_STATUS_FAILED = 4,

  /**
   * The job is cancelled
   *
   * @generated from enum value: JOB_STATUS_CANCELLED = 5;
   */
  JOB_STATUS_CANCELLED = 5,

  /**
   * The job has expired
   *
   * @generated from enum value: JOB_STATUS_EXPIRED = 6;
   */
  JOB_STATUS_EXPIRED = 6,
}

/**
 * Job statuses
 *
 * @generated from enum io.clbs.openhes.models.acquisition.JobStatusCode
 */
export type JobStatusCodeJson = "JOB_STATUS_QUEUED" | "JOB_STATUS_RUNNING" | "JOB_STATUS_PROCESSING_DATA" | "JOB_STATUS_COMPLETED" | "JOB_STATUS_FAILED" | "JOB_STATUS_CANCELLED" | "JOB_STATUS_EXPIRED";

/**
 * Describes the enum io.clbs.openhes.models.acquisition.JobStatusCode.
 */
export const JobStatusCodeSchema: GenEnum<JobStatusCode, JobStatusCodeJson> = /*@__PURE__*/
  enumDesc(file_acquisition_shared, 13);

