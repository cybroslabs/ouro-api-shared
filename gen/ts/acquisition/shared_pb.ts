// @generated by protoc-gen-es v2.10.0 with parameter "target=ts,json_types=true"
// @generated from file acquisition/shared.proto (package io.clbs.openhes.models.acquisition, edition 2023)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { Duration, DurationJson, Empty, EmptyJson, Timestamp, TimestampJson } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_duration, file_google_protobuf_empty, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { FormattedMessage, FormattedMessageJson } from "../common/messages_pb";
import { file_common_messages } from "../common/messages_pb";
import type { FieldDataType, FieldDataTypeJson, FieldDescriptor, FieldDescriptorJson, FieldValue, FieldValueJson, FieldValues, FieldValuesJson, FilterOperator, FilterOperatorJson } from "../common/fields_pb";
import { file_common_fields } from "../common/fields_pb";
import type { MetadataFields, MetadataFieldsJson } from "../common/metadata_pb";
import { file_common_metadata } from "../common/metadata_pb";
import type { ListOfString, ListOfStringJson } from "../common/types_pb";
import { file_common_types } from "../common/types_pb";
import type { TimeOfUseTableSpec, TimeOfUseTableSpecJson } from "./timeofuse/timeofuse_pb";
import { file_acquisition_timeofuse_timeofuse } from "./timeofuse/timeofuse_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file acquisition/shared.proto.
 */
export const file_acquisition_shared: GenFile = /*@__PURE__*/
  fileDesc("ChhhY3F1aXNpdGlvbi9zaGFyZWQucHJvdG8SImlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24i8QIKC0pvYlNldHRpbmdzEi8KDG1heF9kdXJhdGlvbhgBIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhJBCghwcmlvcml0eRgCIAEoDjIvLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uSm9iUHJpb3JpdHkSEAoIYXR0ZW1wdHMYAyADKAUSLgoLcmV0cnlfZGVsYXkYBCABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SLgoLZGVmZXJfc3RhcnQYBSABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SLgoKZXhwaXJlc19hdBgGIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASTAoQcmVhZF9wYXRoX3BvbGljeRgHIAEoDjIyLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uUmVhZFBhdGhQb2xpY3kiiAoKCUpvYkFjdGlvbhIRCglhY3Rpb25faWQYASABKAkSUQoKYXR0cmlidXRlcxgCIAMoCzI9LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uSm9iQWN0aW9uLkF0dHJpYnV0ZXNFbnRyeRJNCgxnZXRfcmVnaXN0ZXIYAyABKAsyNS5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFjdGlvbkdldFJlZ2lzdGVySAASYAoWZ2V0X3BlcmlvZGljYWxfcHJvZmlsZRgEIAEoCzI+LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQWN0aW9uR2V0UGVyaW9kaWNhbFByb2ZpbGVIABJeChVnZXRfaXJyZWd1bGFyX3Byb2ZpbGUYBSABKAsyPS5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFjdGlvbkdldElycmVndWxhclByb2ZpbGVIABJJCgpnZXRfZXZlbnRzGAYgASgLMjMuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5BY3Rpb25HZXRFdmVudHNIABJSCg9nZXRfZGV2aWNlX2luZm8YByABKAsyNy5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFjdGlvbkdldERldmljZUluZm9IABJJCgpzeW5jX2Nsb2NrGAggASgLMjMuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5BY3Rpb25TeW5jQ2xvY2tIABJSCg9zZXRfcmVsYXlfc3RhdGUYCiABKAsyNy5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFjdGlvblNldFJlbGF5U3RhdGVIABJgChZzZXRfZGlzY29ubmVjdG9yX3N0YXRlGAwgASgLMj4uaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5BY3Rpb25TZXREaXNjb25uZWN0b3JTdGF0ZUgAEkMKB2dldF90b3UYDSABKAsyMC5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFjdGlvbkdldFRvdUgAEkMKB3NldF90b3UYDiABKAsyMC5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFjdGlvblNldFRvdUgAEksKC3NldF9saW1pdGVyGBAgASgLMjQuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5BY3Rpb25TZXRMaW1pdGVySAASXAoUcmVzZXRfYmlsbGluZ19wZXJpb2QYESABKAsyPC5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFjdGlvblJlc2V0QmlsbGluZ1BlcmlvZEgAEkcKCWZ3X3VwZGF0ZRgSIAEoCzIyLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQWN0aW9uRndVcGRhdGVIABpcCg9BdHRyaWJ1dGVzRW50cnkSCwoDa2V5GAEgASgJEjgKBXZhbHVlGAIgASgLMikuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5jb21tb24uRmllbGRWYWx1ZToCOAFCCAoGYWN0aW9uItoICgxKb2JBY3Rpb25TZXQSEQoJdmFyaWFibGVzGAIgAygJEk0KDGdldF9yZWdpc3RlchgDIAEoCzI1LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQWN0aW9uR2V0UmVnaXN0ZXJIABJgChZnZXRfcGVyaW9kaWNhbF9wcm9maWxlGAQgASgLMj4uaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5BY3Rpb25HZXRQZXJpb2RpY2FsUHJvZmlsZUgAEl4KFWdldF9pcnJlZ3VsYXJfcHJvZmlsZRgFIAEoCzI9LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQWN0aW9uR2V0SXJyZWd1bGFyUHJvZmlsZUgAEkkKCmdldF9ldmVudHMYBiABKAsyMy5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFjdGlvbkdldEV2ZW50c0gAElIKD2dldF9kZXZpY2VfaW5mbxgHIAEoCzI3LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQWN0aW9uR2V0RGV2aWNlSW5mb0gAEkkKCnN5bmNfY2xvY2sYCCABKAsyMy5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFjdGlvblN5bmNDbG9ja0gAElIKD3NldF9yZWxheV9zdGF0ZRgKIAEoCzI3LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQWN0aW9uU2V0UmVsYXlTdGF0ZUgAEmAKFnNldF9kaXNjb25uZWN0b3Jfc3RhdGUYDCABKAsyPi5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFjdGlvblNldERpc2Nvbm5lY3RvclN0YXRlSAASQwoHZ2V0X3RvdRgNIAEoCzIwLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQWN0aW9uR2V0VG91SAASQwoHc2V0X3RvdRgOIAEoCzIwLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQWN0aW9uU2V0VG91SAASSwoLc2V0X2xpbWl0ZXIYECABKAsyNC5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFjdGlvblNldExpbWl0ZXJIABJcChRyZXNldF9iaWxsaW5nX3BlcmlvZBgRIAEoCzI8LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQWN0aW9uUmVzZXRCaWxsaW5nUGVyaW9kSAASRwoJZndfdXBkYXRlGBIgASgLMjIuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5BY3Rpb25Gd1VwZGF0ZUgAQggKBmFjdGlvbiJjCg9MaXN0T2ZKb2JEZXZpY2USOwoEbGlzdBgBIAMoCzItLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uSm9iRGV2aWNlEhMKC3RvdGFsX2NvdW50GAIgASgFImcKEUxpc3RPZkpvYkRldmljZUlkEj0KBGxpc3QYASADKAsyLy5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkpvYkRldmljZUlkEhMKC3RvdGFsX2NvdW50GAIgASgFIjAKC0pvYkRldmljZUlkEg4KBmpvYl9pZBgBIAEoCRIRCglkZXZpY2VfaWQYAiABKAkitQMKCUpvYkRldmljZRIOCgZqb2JfaWQYASABKAkSEQoJZGV2aWNlX2lkGAIgASgJEhMKC2V4dGVybmFsX2lkGAMgASgJEl4KEWRldmljZV9hdHRyaWJ1dGVzGAQgAygLMkMuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5Kb2JEZXZpY2UuRGV2aWNlQXR0cmlidXRlc0VudHJ5EksKD2Nvbm5lY3Rpb25faW5mbxgFIAMoCzIyLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQ29ubmVjdGlvbkluZm8STQoMYXBwX3Byb3RvY29sGAYgASgOMjcuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5BcHBsaWNhdGlvblByb3RvY29sEhAKCHRpbWV6b25lGAcgASgJGmIKFURldmljZUF0dHJpYnV0ZXNFbnRyeRILCgNrZXkYASABKAkSOAoFdmFsdWUYAiABKAsyKS5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmNvbW1vbi5GaWVsZFZhbHVlOgI4ASKdAwoJTW9kZW1JbmZvEhAKCG1vZGVtX2lkGAEgASgJEgwKBG5hbWUYAiABKAkSDwoHYXRfaW5pdBgDIAEoCRIPCgdhdF9kaWFsGAQgASgJEhEKCWF0X2hhbmd1cBgFIAEoCRIRCglhdF9lc2NhcGUYBiABKAkSMgoPY29ubmVjdF90aW1lb3V0GAcgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEjIKD2NvbW1hbmRfdGltZW91dBgIIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhJOCgV0Y3BpcBgJIAEoCzI9LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQ29ubmVjdGlvblR5cGVEaXJlY3RUY3BJcEgAElwKDnNlcmlhbF9vdmVyX2lwGAogASgLMkIuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5Db25uZWN0aW9uVHlwZUNvbnRyb2xsZWRTZXJpYWxIAEISChBtb2RlbV9jb25uZWN0aW9uItgCCgxTZXJpYWxDb25maWcSEQoJYmF1ZF9yYXRlGAEgASgFEkYKBnBhcml0eRgCIAEoDjI2LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uU2VyaWFsQ29uZmlnUGFyaXR5EksKCWRhdGFfYml0cxgDIAEoDjI4LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uU2VyaWFsQ29uZmlnRGF0YUJpdHMSSwoJc3RvcF9iaXRzGAQgASgOMjguaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5TZXJpYWxDb25maWdTdG9wQml0cxJTCgxmbG93X2NvbnRyb2wYBSABKA4yPS5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLlNlcmlhbENvbmZpZ0ZMb3dDb250cm9sZXIiwAQKDkNvbm5lY3Rpb25JbmZvEk4KBXRjcGlwGAEgASgLMj0uaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5Db25uZWN0aW9uVHlwZURpcmVjdFRjcElwSAASUQoKbW9kZW1fcG9vbBgCIAEoCzI7LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQ29ubmVjdGlvblR5cGVNb2RlbVBvb2xIABJcCg5zZXJpYWxfb3Zlcl9pcBgDIAEoCzJCLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQ29ubmVjdGlvblR5cGVDb250cm9sbGVkU2VyaWFsSAASSwoNbGlua19wcm90b2NvbBgEIAEoDjI0LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uRGF0YUxpbmtQcm90b2NvbBIcChRjb21tdW5pY2F0aW9uX2J1c19pZBgFIAEoCRJWCgphdHRyaWJ1dGVzGAYgAygLMkIuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5Db25uZWN0aW9uSW5mby5BdHRyaWJ1dGVzRW50cnkaXAoPQXR0cmlidXRlc0VudHJ5EgsKA2tleRgBIAEoCRI4CgV2YWx1ZRgCIAEoCzIpLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuY29tbW9uLkZpZWxkVmFsdWU6AjgBQgwKCmNvbm5lY3Rpb24iYwoZQ29ubmVjdGlvblR5cGVEaXJlY3RUY3BJcBIMCgRob3N0GAEgASgJEgwKBHBvcnQYAiABKA0SKgoHdGltZW91dBgDIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbiJ4ChdDb25uZWN0aW9uVHlwZU1vZGVtUG9vbBIOCgZudW1iZXIYASABKAkSDwoHcG9vbF9pZBgCIAEoCRI8CgVtb2RlbRgEIAEoCzItLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uTW9kZW1JbmZvImQKGkNvbm5lY3Rpb25UeXBlU2VyaWFsRGlyZWN0EgwKBGhvc3QYASABKAkSDAoEcG9ydBgCIAEoDRIqCgd0aW1lb3V0GAMgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uIsYBChhDb25uZWN0aW9uVHlwZVNlcmlhbE1veGESDAoEaG9zdBgBIAEoCRIRCglkYXRhX3BvcnQYAiABKA0SFAoMY29tbWFuZF9wb3J0GAMgASgNEioKB3RpbWVvdXQYBCABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SRwoNc2VyaWFsX2NvbmZpZxgFIAEoCzIwLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uU2VyaWFsQ29uZmlnIq4BChtDb25uZWN0aW9uVHlwZVNlcmlhbFJmYzIyMTcSDAoEaG9zdBgBIAEoCRIMCgRwb3J0GAIgASgNEioKB3RpbWVvdXQYAyABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SRwoNc2VyaWFsX2NvbmZpZxgEIAEoCzIwLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uU2VyaWFsQ29uZmlnIqwBChtBcHBsaWNhdGlvblByb3RvY29sVGVtcGxhdGUSSQoIcHJvdG9jb2wYASABKA4yNy5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFwcGxpY2F0aW9uUHJvdG9jb2wSQgoKYXR0cmlidXRlcxgCIAMoCzIuLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuY29tbW9uLkZpZWxkRGVzY3JpcHRvciL3AQoQRGF0YUxpbmtUZW1wbGF0ZRJLCg1saW5rX3Byb3RvY29sGAEgASgOMjQuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5EYXRhTGlua1Byb3RvY29sElIKEWFwcF9wcm90b2NvbF9yZWZzGAIgAygOMjcuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5BcHBsaWNhdGlvblByb3RvY29sEkIKCmF0dHJpYnV0ZXMYAyADKAsyLi5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmNvbW1vbi5GaWVsZERlc2NyaXB0b3IipQEKFUNvbW11bmljYXRpb25UZW1wbGF0ZRJDCgR0eXBlGAEgASgOMjUuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5Db21tdW5pY2F0aW9uVHlwZRJHCglkYXRhbGlua3MYAiADKAsyNC5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkRhdGFMaW5rVGVtcGxhdGUiLwoTQWNjZXNzTGV2ZWxUZW1wbGF0ZRIKCgJpZBgBIAEoCRIMCgRuYW1lGAIgASgJIpQECg9Ecml2ZXJUZW1wbGF0ZXMSWgoXY29tbXVuaWNhdGlvbl90ZW1wbGF0ZXMYASADKAsyOS5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkNvbW11bmljYXRpb25UZW1wbGF0ZRJWCg1hcHBfcHJvdG9jb2xzGAIgAygLMj8uaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5BcHBsaWNhdGlvblByb3RvY29sVGVtcGxhdGUSUgoRYWN0aW9uX2F0dHJpYnV0ZXMYAyADKAsyNy5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkpvYkFjdGlvbkF0dHJpYnV0ZXMSUQoQYWNjZXNzX3RlbXBsYXRlcxgEIAMoCzI3LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQWNjZXNzTGV2ZWxUZW1wbGF0ZRJTChJhY3Rpb25fY29uc3RyYWludHMYBSABKAsyNy5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkpvYkFjdGlvbkNvbnRyYWludHMSUQoZdWtub3duX2RldmljZV9kZXNjcmlwdG9ycxgGIAMoCzIuLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuY29tbW9uLkZpZWxkRGVzY3JpcHRvciKLAgoUQWN0aW9uUHJvZ3Jlc3NVcGRhdGUSDgoGam9iX2lkGAEgASgJEhEKCWFjdGlvbl9pZBgCIAEoCRJCCgRjb2RlGAMgASgOMjQuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5BY3Rpb25SZXN1bHRDb2RlEkQKBGRhdGEYBCABKAsyNi5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFjdGlvblByb2dyZXNzRGF0YRJGCg1lcnJvcl9tZXNzYWdlGAUgASgLMi8uaW8uY2xicy5vcGVuaGVzLm1vZGVscy5jb21tb24uRm9ybWF0dGVkTWVzc2FnZSLYAQoRSm9iUHJvZ3Jlc3NVcGRhdGUSDgoGam9iX2lkGAEgASgJEj4KBGNvZGUYAiABKA4yMC5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkpvYkVycm9yQ29kZRIrCghkdXJhdGlvbhgDIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhJGCg1lcnJvcl9tZXNzYWdlGAQgASgLMi8uaW8uY2xicy5vcGVuaGVzLm1vZGVscy5jb21tb24uRm9ybWF0dGVkTWVzc2FnZSLdAwoSQWN0aW9uUHJvZ3Jlc3NEYXRhEigKBm5vZGF0YRgBIAEoCzIWLmdvb2dsZS5wcm90b2J1Zi5FbXB0eUgAEkcKCXJlZ2lzdGVycxgCIAEoCzIyLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uUmVnaXN0ZXJWYWx1ZXNIABIRCgdwcm9maWxlGAMgASgMSAASVwoRaXJyZWd1bGFyX3Byb2ZpbGUYBCABKAsyOi5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLklycmVndWxhclByb2ZpbGVWYWx1ZXNIABJFCgtkZXZpY2VfaW5mbxgFIAEoCzIuLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uRGV2aWNlSW5mb0gAEkIKBmV2ZW50cxgGIAEoCzIwLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uRXZlbnRSZWNvcmRzSAASVQoJdG91X3RhYmxlGAcgASgLMkAuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi50aW1lb2Z1c2UuVGltZU9mVXNlVGFibGVTcGVjSABCBgoEZGF0YSKIBAoKQWN0aW9uRGF0YRIoCgZub2RhdGEYASABKAsyFi5nb29nbGUucHJvdG9idWYuRW1wdHlIABJHCglyZWdpc3RlcnMYAiABKAsyMi5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLlJlZ2lzdGVyVmFsdWVzSAASRAoHcHJvZmlsZRgDIAEoCzIxLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uUHJvZmlsZVZhbHVlc0gAElcKEWlycmVndWxhcl9wcm9maWxlGAQgASgLMjouaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5JcnJlZ3VsYXJQcm9maWxlVmFsdWVzSAASRQoLZGV2aWNlX2luZm8YBSABKAsyLi5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkRldmljZUluZm9IABJCCgZldmVudHMYBiABKAsyMC5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkV2ZW50UmVjb3Jkc0gAElUKCXRvdV90YWJsZRgHIAEoCzJALmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24udGltZW9mdXNlLlRpbWVPZlVzZVRhYmxlU3BlY0gAQgYKBGRhdGEiTwoMRXZlbnRSZWNvcmRzEj8KBnZhbHVlcxgBIAMoCzIvLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uRXZlbnRSZWNvcmQijAEKC0V2ZW50UmVjb3JkEi0KCXRpbWVzdGFtcBgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASEAoIZXZlbnRfaWQYAiABKAMSEgoKZXZlbnRfY29kZRgDIAEoAxIUCgxldmVudF9zb3VyY2UYBSABKAkSEgoKZXZlbnRfdGV4dBgEIAEoCSKlAQoRRGV2aWNlRXZlbnRSZWNvcmQSEQoJZGV2aWNlX2lkGAEgASgJEi0KCXRpbWVzdGFtcBgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASEAoIZXZlbnRfaWQYAyABKAMSEgoKZXZlbnRfY29kZRgEIAEoAxIUCgxldmVudF9zb3VyY2UYBSABKAkSEgoKZXZlbnRfdGV4dBgGIAEoCSJVCgxEZXZpY2VFdmVudHMSRQoGZXZlbnRzGAEgAygLMjUuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5EZXZpY2VFdmVudFJlY29yZCKqAgoKRGV2aWNlSW5mbxIyCg5pbmZvX3RpbWVzdGFtcBgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASIgoabWFudWZhY3R1cmVyX3NlcmlhbF9udW1iZXIYAiABKAkSHAoUZGV2aWNlX3NlcmlhbF9udW1iZXIYAyABKAkSGAoQZmlybXdhcmVfdmVyc2lvbhgEIAEoCRIuCgtjbG9ja19kZWx0YRgFIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhIUCgxkZXZpY2VfbW9kZWwYBiABKAkSFgoOZXJyb3JfcmVnaXN0ZXIYByABKAQSFAoMcmVsYXlfc3RhdGVzGAggAygIEhgKEGNvbm5lY3Rpb25fc3RhdGUYCSABKAgiigEKDVByb2ZpbGVWYWx1ZXMSKQoGcGVyaW9kGAEgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEgwKBHVuaXQYAiABKAkSQAoGYmxvY2tzGAMgAygLMjAuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5Qcm9maWxlQmxvY2siagoWSXJyZWd1bGFyUHJvZmlsZVZhbHVlcxIMCgR1bml0GAEgASgJEkIKBnZhbHVlcxgCIAMoCzIyLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uSXJyZWd1bGFyVmFsdWUigQEKDklycmVndWxhclZhbHVlEi0KCXRpbWVzdGFtcBgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASQAoFdmFsdWUYAiABKAsyMS5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLk1lYXN1cmVkVmFsdWUihgEKDFByb2ZpbGVCbG9jaxIzCg9zdGFydF90aW1lc3RhbXAYASABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEkEKBnZhbHVlcxgCIAMoCzIxLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uTWVhc3VyZWRWYWx1ZSJTCg5SZWdpc3RlclZhbHVlcxJBCgZ2YWx1ZXMYASADKAsyMS5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLlJlZ2lzdGVyVmFsdWUijgEKDVJlZ2lzdGVyVmFsdWUSLQoJdGltZXN0YW1wGAEgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIMCgR1bml0GAIgASgJEkAKBXZhbHVlGAMgASgLMjEuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5NZWFzdXJlZFZhbHVlIqsCCg1NZWFzdXJlZFZhbHVlEg4KBnN0YXR1cxgBIAEoAxIQCghleHBvbmVudBgCIAEoBRIWCgxkb3VibGVfdmFsdWUYAyABKAFIABIXCg1pbnRlZ2VyX3ZhbHVlGAQgASgDSAASFgoMc3RyaW5nX3ZhbHVlGAUgASgJSAASNQoPdGltZXN0YW1wX3ZhbHVlGAYgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEgAEhwKEnRpbWVzdGFtcF90el92YWx1ZRgHIAEoCUgAEhQKCmJvb2xfdmFsdWUYCCABKAhIABIPCgduc3RhdHVzGAkgASgEEisKB3BlYWtfdHMYCiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQgYKBGtpbmQilwEKE0pvYkFjdGlvbkF0dHJpYnV0ZXMSPAoEdHlwZRgBIAEoDjIuLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQWN0aW9uVHlwZRJCCgphdHRyaWJ1dGVzGAIgAygLMi4uaW8uY2xicy5vcGVuaGVzLm1vZGVscy5jb21tb24uRmllbGREZXNjcmlwdG9yIuMCCh5Db25uZWN0aW9uVHlwZUNvbnRyb2xsZWRTZXJpYWwSUAoGZGlyZWN0GAEgASgLMj4uaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5Db25uZWN0aW9uVHlwZVNlcmlhbERpcmVjdEgAEkwKBG1veGEYAiABKAsyPC5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkNvbm5lY3Rpb25UeXBlU2VyaWFsTW94YUgAElIKB3JmYzIyMTcYAyABKAsyPy5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkNvbm5lY3Rpb25UeXBlU2VyaWFsUmZjMjIxN0gAEkAKBmNvbmZpZxgEIAEoCzIwLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uU2VyaWFsQ29uZmlnQgsKCWNvbnZlcnRlciJUChFBY3Rpb25HZXRSZWdpc3RlchI/CglkYXRhX3R5cGUYASABKA4yLC5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmNvbW1vbi5GaWVsZERhdGFUeXBlIr0BChpBY3Rpb25HZXRQZXJpb2RpY2FsUHJvZmlsZRIvCgtyYW5nZV9zdGFydBgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASLQoJcmFuZ2VfZW5kGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBI/CglkYXRhX3R5cGUYAyABKA4yLC5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmNvbW1vbi5GaWVsZERhdGFUeXBlIrwBChlBY3Rpb25HZXRJcnJlZ3VsYXJQcm9maWxlEi8KC3JhbmdlX3N0YXJ0GAEgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBItCglyYW5nZV9lbmQYAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEj8KCWRhdGFfdHlwZRgDIAEoDjIsLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuY29tbW9uLkZpZWxkRGF0YVR5cGUicQoPQWN0aW9uR2V0RXZlbnRzEi8KC3JhbmdlX3N0YXJ0GAEgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBItCglyYW5nZV9lbmQYAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wIhUKE0FjdGlvbkdldERldmljZUluZm8iEQoPQWN0aW9uU3luY0Nsb2NrIhUKE0FjdGlvblNldFJlbGF5U3RhdGUiHAoaQWN0aW9uU2V0RGlzY29ubmVjdG9yU3RhdGUiHwoMQWN0aW9uR2V0VG91Eg8KB3Bhc3NpdmUYASABKAgiXwoMQWN0aW9uU2V0VG91Ek8KBXRhYmxlGAEgASgLMkAuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi50aW1lb2Z1c2UuVGltZU9mVXNlVGFibGVTcGVjIhIKEEFjdGlvblNldExpbWl0ZXIiGgoYQWN0aW9uUmVzZXRCaWxsaW5nUGVyaW9kIhAKDkFjdGlvbkZ3VXBkYXRlIrADChNKb2JBY3Rpb25Db250cmFpbnRzEnAKFmdldF9yZWdpc3Rlcl90eXBlX25hbWUYASADKAsyUC5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkpvYkFjdGlvbkNvbnRyYWludHMuR2V0UmVnaXN0ZXJUeXBlTmFtZUVudHJ5EnwKHGdldF9yZWdpc3Rlcl90eXBlX2F0dHJpYnV0ZXMYAiADKAsyVi5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkpvYkFjdGlvbkNvbnRyYWludHMuR2V0UmVnaXN0ZXJUeXBlQXR0cmlidXRlc0VudHJ5GjoKGEdldFJlZ2lzdGVyVHlwZU5hbWVFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBGm0KHkdldFJlZ2lzdGVyVHlwZUF0dHJpYnV0ZXNFbnRyeRILCgNrZXkYASABKAkSOgoFdmFsdWUYAiABKAsyKy5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmNvbW1vbi5MaXN0T2ZTdHJpbmc6AjgBIugDCglKb2JTdGF0dXMSQQoGc3RhdHVzGAEgASgOMjEuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5Kb2JTdGF0dXNDb2RlEj4KBGNvZGUYAiABKA4yMC5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkpvYkVycm9yQ29kZRJBCgdyZXN1bHRzGAMgAygLMjAuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5BY3Rpb25SZXN1bHQSLgoKc3RhcnRlZF9hdBgEIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASLwoLZmluaXNoZWRfYXQYBSABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEhUKDWF0dGVtcHRzX2RvbmUYBiABKAUSQwoLZGV2aWNlX2luZm8YByABKAsyLi5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkRldmljZUluZm8SEAoIcXVldWVfaWQYCCABKAMSRgoNZXJyb3JfbWVzc2FnZRgJIAEoCzIvLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuY29tbW9uLkZvcm1hdHRlZE1lc3NhZ2Ui9gMKEUpvYlByb2dyZXNzU3RhdHVzEkEKBnN0YXR1cxgBIAEoDjIxLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uSm9iU3RhdHVzQ29kZRI+CgRjb2RlGAIgASgOMjAuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5Kb2JFcnJvckNvZGUSRwoHcmVzdWx0cxgDIAMoCzI2LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQWN0aW9uUHJvZ3Jlc3NEYXRhEi4KCnN0YXJ0ZWRfYXQYBCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEi8KC2ZpbmlzaGVkX2F0GAUgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIVCg1hdHRlbXB0c19kb25lGAYgASgFEkMKC2RldmljZV9pbmZvGAcgASgLMi4uaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5EZXZpY2VJbmZvEhAKCHF1ZXVlX2lkGAggASgDEkYKDWVycm9yX21lc3NhZ2UYCSABKAsyLy5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmNvbW1vbi5Gb3JtYXR0ZWRNZXNzYWdlItEDCgxTdGFydEpvYkRhdGESYQoRZGV2aWNlX2F0dHJpYnV0ZXMYASADKAsyRi5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLlN0YXJ0Sm9iRGF0YS5EZXZpY2VBdHRyaWJ1dGVzRW50cnkSDgoGam9iX2lkGAIgASgJEkUKDGpvYl9zZXR0aW5ncxgDIAEoCzIvLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uSm9iU2V0dGluZ3MSQgoLam9iX2FjdGlvbnMYBCADKAsyLS5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkpvYkFjdGlvbhJNCgxhcHBfcHJvdG9jb2wYBSABKA4yNy5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFwcGxpY2F0aW9uUHJvdG9jb2wSEAoIdGltZXpvbmUYBiABKAkaYgoVRGV2aWNlQXR0cmlidXRlc0VudHJ5EgsKA2tleRgBIAEoCRI4CgV2YWx1ZRgCIAEoCzIpLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuY29tbW9uLkZpZWxkVmFsdWU6AjgBIiIKEENhbmNlbEpvYlJlcXVlc3QSDgoGam9iX2lkGAEgASgJIpoDCh9EZXZpY2VDb25maWd1cmF0aW9uUmVnaXN0ZXJTcGVjEhMKC2RyaXZlcl90eXBlGAEgASgJEloKDXJlZ2lzdGVyX3R5cGUYAiABKA4yQy5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkRldmljZUNvbmZpZ3VyYXRpb25SZWdpc3RlcktpbmQSZwoKYXR0cmlidXRlcxgDIAMoCzJTLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uRGV2aWNlQ29uZmlndXJhdGlvblJlZ2lzdGVyU3BlYy5BdHRyaWJ1dGVzRW50cnkSPwoJZGF0YV90eXBlGAQgASgOMiwuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5jb21tb24uRmllbGREYXRhVHlwZRpcCg9BdHRyaWJ1dGVzRW50cnkSCwoDa2V5GAEgASgJEjgKBXZhbHVlGAIgASgLMikuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5jb21tb24uRmllbGRWYWx1ZToCOAEiqwEKDkRldmljZVJlZ2lzdGVyEhMKC3JlZ2lzdGVyX2lkGAEgASgDEhoKEnB1YmxpY19yZWdpc3Rlcl9pZBgCIAEoCRJRCgRzcGVjGAMgASgLMkMuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5EZXZpY2VDb25maWd1cmF0aW9uUmVnaXN0ZXJTcGVjEhUKDXZhcmlhYmxlX25hbWUYBCADKAkiigQKFERldmljZUNvbm5lY3Rpb25JbmZvEk4KEmNvbW11bmljYXRpb25fdW5pdBgBIAEoCzIyLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQ29ubmVjdGlvbkluZm8STQoMYXBwX3Byb3RvY29sGAIgASgOMjcuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5BcHBsaWNhdGlvblByb3RvY29sEmkKEWRldmljZV9hdHRyaWJ1dGVzGAMgAygLMk4uaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5EZXZpY2VDb25uZWN0aW9uSW5mby5EZXZpY2VBdHRyaWJ1dGVzRW50cnkSEAoIdGltZXpvbmUYBCABKAkSEwoLZHJpdmVyX3R5cGUYBSABKAkSFgoOZHJpdmVyX3ZlcnNpb24YByABKAkSRQoJcmVnaXN0ZXJzGAggAygLMjIuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5EZXZpY2VSZWdpc3RlchpiChVEZXZpY2VBdHRyaWJ1dGVzRW50cnkSCwoDa2V5GAEgASgJEjgKBXZhbHVlGAIgASgLMikuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5jb21tb24uRmllbGRWYWx1ZToCOAEiZAoPTGlzdE9mTW9kZW1JbmZvEjwKBWl0ZW1zGAEgAygLMi0uaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5Nb2RlbUluZm8SEwoLdG90YWxfY291bnQYAiABKAUidAoUTGlzdE9mQ29ubmVjdGlvbkluZm8SRwoFaXRlbXMYASADKAsyOC5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkRldmljZUNvbm5lY3Rpb25JbmZvEhMKC3RvdGFsX2NvdW50GAIgASgFIkwKD0ZpZWxkVmFsdWVzTGlzdBI5CgVpdGVtcxgBIAMoCzIqLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuY29tbW9uLkZpZWxkVmFsdWVzIpECChFBdHRyaWJ1dGVTZWxlY3RvchIQCghmaWVsZF9pZBgBIAEoCRI/CghvcGVyYXRvchgCIAEoDjItLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuY29tbW9uLkZpbHRlck9wZXJhdG9yEj8KCWRhdGFfdHlwZRgDIAEoDjIsLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuY29tbW9uLkZpZWxkRGF0YVR5cGUSDAoEdGV4dBgEIAMoCRIPCgdpbnRlZ2VyGAUgAygSEg4KBm51bWJlchgGIAMoARIPCgdib29sZWFuGAcgAygIEigKBGRhdGUYCCADKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wImQKF0RldmljZUF0dHJpYnV0ZVNlbGVjdG9yEkkKCmF0dHJpYnV0ZXMYAiADKAsyNS5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkF0dHJpYnV0ZVNlbGVjdG9yIrwBCiJDb21tdW5pY2F0aW9uVW5pdEF0dHJpYnV0ZVNlbGVjdG9yEksKDWxpbmtfcHJvdG9jb2wYASABKA4yNC5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkRhdGFMaW5rUHJvdG9jb2wSSQoKYXR0cmlidXRlcxgCIAMoCzI1LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQXR0cmlidXRlU2VsZWN0b3IimQIKDEFjdGlvblJlc3VsdBIRCglhY3Rpb25faWQYASABKAkSRAoGc3RhdHVzGAIgASgOMjQuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5BY3Rpb25SZXN1bHRDb2RlEjwKBGRhdGEYAyABKAsyLi5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFjdGlvbkRhdGESEwoLcmVnaXN0ZXJfaWQYBCABKAkSFQoNdmFyaWFibGVfbmFtZRgFIAMoCRJGCg1lcnJvcl9tZXNzYWdlGAYgASgLMi8uaW8uY2xicy5vcGVuaGVzLm1vZGVscy5jb21tb24uRm9ybWF0dGVkTWVzc2FnZSIeCgxKb2JFdmVudERhdGESDgoGam9iX2lkGAEgASgMIpACCgpEZXZpY2VTcGVjEg4KBmRjdF9pZBgBIAEoCRITCgtleHRlcm5hbF9pZBgCIAEoCRJcChdjb21tdW5pY2F0aW9uX3VuaXRfbGluaxgDIAMoCzI7LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uRGV2aWNlQ29tbXVuaWNhdGlvblVuaXQSEAoIdGltZXpvbmUYBCABKAkSbQoXZGVmYXVsdF9saW5rX2F0dHJpYnV0ZXMYBSADKAsyTC5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkRlZmF1bHREZXZpY2VDb21tdW5pY2F0aW9uVW5pdEF0dHJpYnV0ZXMiYQoMRGV2aWNlU3RhdHVzEjwKBGluZm8YASABKAsyLi5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkRldmljZUluZm8SEwoLZHJpdmVyX3R5cGUYAiABKAkixgIKF0RldmljZUNvbW11bmljYXRpb25Vbml0Eh0KFWNvbW11bmljYXRpb25fdW5pdF9pZBgBIAEoCRJNCgxhcHBfcHJvdG9jb2wYAiABKA4yNy5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFwcGxpY2F0aW9uUHJvdG9jb2wSXwoKYXR0cmlidXRlcxgDIAMoCzJLLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uRGV2aWNlQ29tbXVuaWNhdGlvblVuaXQuQXR0cmlidXRlc0VudHJ5GlwKD0F0dHJpYnV0ZXNFbnRyeRILCgNrZXkYASABKAkSOAoFdmFsdWUYAiABKAsyKS5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmNvbW1vbi5GaWVsZFZhbHVlOgI4ASLJAgooRGVmYXVsdERldmljZUNvbW11bmljYXRpb25Vbml0QXR0cmlidXRlcxJNCgxhcHBfcHJvdG9jb2wYASABKA4yNy5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkFwcGxpY2F0aW9uUHJvdG9jb2wScAoKYXR0cmlidXRlcxgCIAMoCzJcLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uRGVmYXVsdERldmljZUNvbW11bmljYXRpb25Vbml0QXR0cmlidXRlcy5BdHRyaWJ1dGVzRW50cnkaXAoPQXR0cmlidXRlc0VudHJ5EgsKA2tleRgBIAEoCRI4CgV2YWx1ZRgCIAEoCzIpLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuY29tbW9uLkZpZWxkVmFsdWU6AjgBIrkCCgdKb2JTcGVjEj0KBmRldmljZRgCIAEoCzItLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uSm9iRGV2aWNlEkUKDGpvYl9zZXR0aW5ncxgDIAEoCzIvLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uSm9iU2V0dGluZ3MSEwoLZHJpdmVyX3R5cGUYBCABKAkSQgoLam9iX2FjdGlvbnMYBSADKAsyLS5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkpvYkFjdGlvbhJPCg9qb2JfYWN0aW9uX2luZm8YBiADKAsyNi5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkpvYkFjdGlvbk1hcFJlY29yZCJyChJKb2JBY3Rpb25NYXBSZWNvcmQSFAoMYWN0aW9uX2luZGV4GAEgASgFEhMKC3JlZ2lzdGVyX2lkGAMgASgDEhoKEnB1YmxpY19yZWdpc3Rlcl9pZBgCIAEoCRIVCg12YXJpYWJsZV9uYW1lGAQgAygJIpcBChNKb2JEb25lTm90aWZpY2F0aW9uEjkKBHNwZWMYASABKAsyKy5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkpvYlNwZWMSRQoGc3RhdHVzGAIgASgLMjUuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5Kb2JQcm9ncmVzc1N0YXR1cyIyCgpEcml2ZXJJbmZvEhMKC2RyaXZlcl90eXBlGAEgASgJEg8KB3ZlcnNpb24YAiABKAkiowEKEUNvbW11bmljYXRpb25Vbml0EkcKBHNwZWMYASABKAsyOS5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkNvbW11bmljYXRpb25Vbml0U3BlYxI/CghtZXRhZGF0YRgDIAEoCzItLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuY29tbW9uLk1ldGFkYXRhRmllbGRzSgQIAhADInkKFUNvbW11bmljYXRpb25Vbml0U3BlYxITCgtleHRlcm5hbF9pZBgBIAEoCRJLCg9jb25uZWN0aW9uX2luZm8YAiABKAsyMi5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkNvbm5lY3Rpb25JbmZvIqUBChBDb21tdW5pY2F0aW9uQnVzEkoKBnN0YXR1cxgCIAEoCzI6LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuYWNxdWlzaXRpb24uQ29tbXVuaWNhdGlvbkJ1c1N0YXR1cxI/CghtZXRhZGF0YRgDIAEoCzItLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuY29tbW9uLk1ldGFkYXRhRmllbGRzSgQIARACIjcKFkNvbW11bmljYXRpb25CdXNTdGF0dXMSHQoVY29tbXVuaWNhdGlvbl91bml0X2lkGAEgAygJIqABCgxUb3BvbG9neU5vZGUSDAoEeF9pZBgBIAEoAxJCCgR0eXBlGAIgASgOMjQuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5Ub3BvbG9neU5vZGVUeXBlEj4KCmF0dHJpYnV0ZXMYAyABKAsyKi5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmNvbW1vbi5GaWVsZFZhbHVlcyJyCgxUb3BvbG9neUVkZ2USEQoJZnJvbV94X2lkGAEgASgDEg8KB3RvX3hfaWQYAiABKAMSPgoKYXR0cmlidXRlcxgDIAEoCzIqLmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuY29tbW9uLkZpZWxkVmFsdWVzIo4BCgpOZXR3b3JrTWFwEj8KBW5vZGVzGAEgAygLMjAuaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5Ub3BvbG9neU5vZGUSPwoFZWRnZXMYAiADKAsyMC5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLlRvcG9sb2d5RWRnZSLKAQoaQ29tbXVuaWNhdGlvblVuaXRMb2dSZWNvcmQSCgoCaWQYASABKAkSHQoVY29tbXVuaWNhdGlvbl91bml0X2lkGAIgASgJEi0KCXRpbWVzdGFtcBgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASQQoFbGV2ZWwYBCABKA4yMi5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmFjcXVpc2l0aW9uLkxvZ1JlY29yZExldmVsEg8KB21lc3NhZ2UYBSABKAkihgEKIExpc3RPZkNvbW11bmljYXRpb25Vbml0TG9nUmVjb3JkEk0KBWl0ZW1zGAEgAygLMj4uaW8uY2xicy5vcGVuaGVzLm1vZGVscy5hY3F1aXNpdGlvbi5Db21tdW5pY2F0aW9uVW5pdExvZ1JlY29yZBITCgt0b3RhbF9jb3VudBgCIAEoBSrfAQoLSm9iUHJpb3JpdHkSHAoYSk9CX1BSSU9SSVRZX1VOU1BFQ0lGSUVEEAASEgoOSk9CX1BSSU9SSVRZXzAQARISCg5KT0JfUFJJT1JJVFlfMRACEhIKDkpPQl9QUklPUklUWV8yEAMSEgoOSk9CX1BSSU9SSVRZXzMQBBISCg5KT0JfUFJJT1JJVFlfNBAFEhIKDkpPQl9QUklPUklUWV81EAYSEgoOSk9CX1BSSU9SSVRZXzYQBxISCg5KT0JfUFJJT1JJVFlfNxAIEhIKDkpPQl9QUklPUklUWV84EAkqcwoOUmVhZFBhdGhQb2xpY3kSIAocUkVBRF9QQVRIX1BPTElDWV9VTlNQRUNJRklFRBAAEiAKHFJFQURfUEFUSF9QT0xJQ1lfTUVURVJfRklSU1QQARIdChlSRUFEX1BBVEhfUE9MSUNZX0RDX0ZJUlNUEAIqgQEKElNlcmlhbENvbmZpZ1Bhcml0eRIWChJQQVJJVFlfVU5TUEVDSUZJRUQQABIPCgtQQVJJVFlfTk9ORRABEg8KC1BBUklUWV9FVkVOEAISDgoKUEFSSVRZX09ERBADEg8KC1BBUklUWV9NQVJLEAQSEAoMUEFSSVRZX1NQQUNFEAUqdQoUU2VyaWFsQ29uZmlnRGF0YUJpdHMSGQoVREFUQV9CSVRTX1VOU1BFQ0lGSUVEEAASDwoLREFUQV9CSVRTXzUQARIPCgtEQVRBX0JJVFNfNhACEg8KC0RBVEFfQklUU183EAMSDwoLREFUQV9CSVRTXzgQBCpmChRTZXJpYWxDb25maWdTdG9wQml0cxIZChVTVE9QX0JJVFNfVU5TUEVDSUZJRUQQABIPCgtTVE9QX0JJVFNfMRABEhEKDVNUT1BfQklUU18xXzUQAhIPCgtTVE9QX0JJVFNfMhADKoYBChlTZXJpYWxDb25maWdGTG93Q29udHJvbGVyEhwKGEZMT1dfQ09OVFJPTF9VTlNQRUNJRklFRBAAEhUKEUZMT1dfQ09OVFJPTF9OT05FEAESGQoVRkxPV19DT05UUk9MX0hBUkRXQVJFEAISGQoVRkxPV19DT05UUk9MX1NPRlRXQVJFEAMq7gEKEUNvbW11bmljYXRpb25UeXBlEiIKHkNPTU1VTklDQVRJT05fVFlQRV9VTlNQRUNJRklFRBAAEhwKGENPTU1VTklDQVRJT05fVFlQRV9UQ1BJUBABEiEKHUNPTU1VTklDQVRJT05fVFlQRV9NT0RFTV9QT09MEAISKQolQ09NTVVOSUNBVElPTl9UWVBFX1NFUklBTF9MSU5FX0RJUkVDVBADEicKI0NPTU1VTklDQVRJT05fVFlQRV9TRVJJQUxfTElORV9NT1hBEAQSIAocQ09NTVVOSUNBVElPTl9UWVBFX0xJU1RFTklORxBjKtgBChBEYXRhTGlua1Byb3RvY29sEhkKFUxJTlRQUk9UT19VTlNQRUNJRklFRBAAEhoKFkxJTktQUk9UT19JRUNfNjIwNTZfMjEQARISCg5MSU5LUFJPVE9fSERMQxACEhsKF0xJTktQUk9UT19DT1NFTV9XUkFQUEVSEAMSFAoQTElOS1BST1RPX01PREJVUxAEEhIKDkxJTktQUk9UT19NQlVTEAUSFAoQTElOS1BST1RPX1ZJS1RPUhAGEhwKGExJTktQUk9UT19OT1RfQVBQTElDQUJMRRBjKvABChNBcHBsaWNhdGlvblByb3RvY29sEhgKFEFQUFBST1RPX1VOU1BFQ0lGSUVEEAASGQoVQVBQUFJPVE9fSUVDXzYyMDU2XzIxEAESFAoQQVBQUFJPVE9fRExNU19TThACEhQKEEFQUFBST1RPX0RMTVNfTE4QAxIRCg1BUFBQUk9UT19TQ1RNEAQSEwoPQVBQUFJPVE9fTElTMjAwEAUSFQoRQVBQUFJPVE9fQU5TSV9DMTIQBhIRCg1BUFBQUk9UT19NUVRUEAcSEwoPQVBQUFJPVE9fTU9EQlVTEAgSEQoNQVBQUFJPVE9fTUJVUxAJKvADCgpBY3Rpb25UeXBlEhsKF0FDVElPTl9UWVBFX1VOU1BFQ0lGSUVEEAASHAoYQUNUSU9OX1RZUEVfR0VUX1JFR0lTVEVSEAESJgoiQUNUSU9OX1RZUEVfR0VUX1BFUklPRElDQUxfUFJPRklMRRACEiUKIUFDVElPTl9UWVBFX0dFVF9JUlJFR1VMQVJfUFJPRklMRRADEhoKFkFDVElPTl9UWVBFX0dFVF9FVkVOVFMQBBIfChtBQ1RJT05fVFlQRV9HRVRfREVWSUNFX0lORk8QChIaChZBQ1RJT05fVFlQRV9TWU5DX0NMT0NLEAsSHwobQUNUSU9OX1RZUEVfU0VUX1JFTEFZX1NUQVRFEBUSJgoiQUNUSU9OX1RZUEVfR0VUX0RJU0NPTk5FQ1RPUl9TVEFURRAWEiYKIkFDVElPTl9UWVBFX1NFVF9ESVNDT05ORUNUT1JfU1RBVEUQFxIXChNBQ1RJT05fVFlQRV9HRVRfVE9VEBgSFwoTQUNUSU9OX1RZUEVfU0VUX1RPVRAZEhsKF0FDVElPTl9UWVBFX1NFVF9MSU1JVEVSEBsSJAogQUNUSU9OX1RZUEVfUkVTRVRfQklMTElOR19QRVJJT0QQKBIZChVBQ1RJT05fVFlQRV9GV19VUERBVEUQMiquAQoQQWN0aW9uUmVzdWx0Q29kZRIhCh1FUlJPUl9DT0RFX0FDVElPTl9VTlNQRUNJRklFRBAAEhgKFEVSUk9SX0NPREVfQUNUSU9OX09LEAESIQodRVJST1JfQ09ERV9BQ1RJT05fVU5TVVBQT1JURUQQAhIdChlFUlJPUl9DT0RFX0FDVElPTl9QRU5ESU5HEAMSGwoXRVJST1JfQ09ERV9BQ1RJT05fRVJST1IQBSq3AQoMSm9iRXJyb3JDb2RlEh4KGkpPQl9FUlJPUl9DT0RFX1VOU1BFQ0lGSUVEEAASFwoTSk9CX0VSUk9SX0NPREVfTk9ORRABEhcKE0pPQl9FUlJPUl9DT0RFX0JVU1kQAhIYChRKT0JfRVJST1JfQ09ERV9FUlJPUhAFEiEKHUpPQl9FUlJPUl9DT0RFX0FMUkVBRFlfRVhJU1RTEAgSGAoUSk9CX0VSUk9SX0NPREVfRkFUQUwQCSqtAQoOQnVsa1N0YXR1c0NvZGUSGwoXQlVMS19TVEFUVVNfVU5TUEVDSUZJRUQQABIZChVCVUxLX1NUQVRVU19QUkVQQVJJTkcQARIWChJCVUxLX1NUQVRVU19RVUVVRUQQAhIXChNCVUxLX1NUQVRVU19SVU5OSU5HEAMSGQoVQlVMS19TVEFUVVNfQ09NUExFVEVEEAQSFwoTQlVMS19TVEFUVVNfRVhQSVJFRBAFKpcBCh9EZXZpY2VDb25maWd1cmF0aW9uUmVnaXN0ZXJLaW5kEhQKEEtJTkRfVU5TUEVDSUZJRUQQABIRCg1LSU5EX1JFR0lTVEVSEAESGwoXS0lORF9QRVJJT0RJQ0FMX1BST0ZJTEUQAhIaChZLSU5EX0lSUkVHVUxBUl9QUk9GSUxFEAMSEgoOS0lORF9TWU5USEVUSUMQYyr4AQoNSm9iU3RhdHVzQ29kZRIaChZKT0JfU1RBVFVTX1VOU1BFQ0lGSUVEEAASFQoRSk9CX1NUQVRVU19RVUVVRUQQARIWChJKT0JfU1RBVFVTX1JVTk5JTkcQAhIeChpKT0JfU1RBVFVTX1BST0NFU1NJTkdfREFUQRADEhgKFEpPQl9TVEFUVVNfQ09NUExFVEVEEAQSFQoRSk9CX1NUQVRVU19GQUlMRUQQBRIZChVKT0JfU1RBVFVTX0NBTkNFTExJTkcQBhIYChRKT0JfU1RBVFVTX0NBTkNFTExFRBAHEhYKEkpPQl9TVEFUVVNfRVhQSVJFRBAIKnEKEFRvcG9sb2d5Tm9kZVR5cGUSHQoZVE9QT0xPR1lfTk9ERV9VTlNQRUNJRklFRBAAEhgKFFRPUE9MT0dZX05PREVfREVWSUNFEAESJAogVE9QT0xPR1lfTk9ERV9DT01NVU5JQ0FUSU9OX1VOSVQQAiqdAQoOTG9nUmVjb3JkTGV2ZWwSGgoWTE9HX1JFQ09SRF9MRVZFTF9ERUJVRxAAEhkKFUxPR19SRUNPUkRfTEVWRUxfSU5GTxABEhwKGExPR19SRUNPUkRfTEVWRUxfV0FSTklORxACEhoKFkxPR19SRUNPUkRfTEVWRUxfRVJST1IQAxIaChZMT0dfUkVDT1JEX0xFVkVMX0ZBVEFMEARCOlo4Z2l0aHViLmNvbS9jeWJyb3NsYWJzL291cm8tYXBpLXNoYXJlZC9nZW4vZ28vYWNxdWlzaXRpb25iCGVkaXRpb25zcOgH", [file_google_protobuf_empty, file_google_protobuf_timestamp, file_google_protobuf_duration, file_common_messages, file_common_fields, file_common_metadata, file_common_types, file_acquisition_timeofuse_timeofuse]);

/**
 * Defines the parameters and execution rules that control how a job is processed.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobSettings
 */
export type JobSettings = Message<"io.clbs.openhes.models.acquisition.JobSettings"> & {
  /**
   * The maximum duration allowed for a job attempt. This value defines the real- time window for the driver to execute the job.
   *
   * @generated from field: google.protobuf.Duration max_duration = 1;
   */
  maxDuration?: Duration;

  /**
   * The execution priority assigned to the job.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobPriority priority = 2;
   */
  priority: JobPriority;

  /**
   * The maximum number of allowed job attempts. Must be at least `1`.
   *
   * @generated from field: repeated int32 attempts = 3;
   */
  attempts: number[];

  /**
   * The delay between two attempts.
   *
   * @generated from field: google.protobuf.Duration retry_delay = 4;
   */
  retryDelay?: Duration;

  /**
   * The time offset to wait before starting the job.
   *
   * @generated from field: google.protobuf.Duration defer_start = 5;
   */
  deferStart?: Duration;

  /**
   * The timestamp that specifies when the job expires and should no longer not be executed.
   *
   * @generated from field: google.protobuf.Timestamp expires_at = 6;
   */
  expiresAt?: Timestamp;

  /**
   * The policy that determines how data is read from devices.  It can be red directly from devices (meters) or via the data concentrator.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ReadPathPolicy read_path_policy = 7;
   */
  readPathPolicy: ReadPathPolicy;
};

/**
 * Defines the parameters and execution rules that control how a job is processed.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobSettings
 */
export type JobSettingsJson = {
  /**
   * The maximum duration allowed for a job attempt. This value defines the real- time window for the driver to execute the job.
   *
   * @generated from field: google.protobuf.Duration max_duration = 1;
   */
  maxDuration?: DurationJson;

  /**
   * The execution priority assigned to the job.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobPriority priority = 2;
   */
  priority?: JobPriorityJson;

  /**
   * The maximum number of allowed job attempts. Must be at least `1`.
   *
   * @generated from field: repeated int32 attempts = 3;
   */
  attempts?: number[];

  /**
   * The delay between two attempts.
   *
   * @generated from field: google.protobuf.Duration retry_delay = 4;
   */
  retryDelay?: DurationJson;

  /**
   * The time offset to wait before starting the job.
   *
   * @generated from field: google.protobuf.Duration defer_start = 5;
   */
  deferStart?: DurationJson;

  /**
   * The timestamp that specifies when the job expires and should no longer not be executed.
   *
   * @generated from field: google.protobuf.Timestamp expires_at = 6;
   */
  expiresAt?: TimestampJson;

  /**
   * The policy that determines how data is read from devices.  It can be red directly from devices (meters) or via the data concentrator.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ReadPathPolicy read_path_policy = 7;
   */
  readPathPolicy?: ReadPathPolicyJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.JobSettings.
 * Use `create(JobSettingsSchema)` to create a new message.
 */
export const JobSettingsSchema: GenMessage<JobSettings, {jsonType: JobSettingsJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 0);

/**
 * Defines the job action specification.
 * The `JobAction` represents a single action to be performed on a single device.
 * For example, if the action is `ActionGetRegister`, it specifies a single register to be read from the devices.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobAction
 */
export type JobAction = Message<"io.clbs.openhes.models.acquisition.JobAction"> & {
  /**
   * The unique identifier of the action.
   *
   * @generated from field: string action_id = 1;
   */
  actionId: string;

  /**
   * The action attributes.
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.FieldValue> attributes = 2;
   */
  attributes: { [key: string]: FieldValue };

  /**
   * @generated from oneof io.clbs.openhes.models.acquisition.JobAction.action
   */
  action: {
    /**
     * Defines the GetRegister action.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionGetRegister get_register = 3;
     */
    value: ActionGetRegister;
    case: "getRegister";
  } | {
    /**
     * Defines the GetPeriodicalProfile action.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionGetPeriodicalProfile get_periodical_profile = 4;
     */
    value: ActionGetPeriodicalProfile;
    case: "getPeriodicalProfile";
  } | {
    /**
     * Defines the GetIrregularProfile action.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionGetIrregularProfile get_irregular_profile = 5;
     */
    value: ActionGetIrregularProfile;
    case: "getIrregularProfile";
  } | {
    /**
     * Defines the GetEvents action.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionGetEvents get_events = 6;
     */
    value: ActionGetEvents;
    case: "getEvents";
  } | {
    /**
     * Defines the GetDeviceInfo action.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionGetDeviceInfo get_device_info = 7;
     */
    value: ActionGetDeviceInfo;
    case: "getDeviceInfo";
  } | {
    /**
     * Defines the SyncClock action.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionSyncClock sync_clock = 8;
     */
    value: ActionSyncClock;
    case: "syncClock";
  } | {
    /**
     * Defines the SetRelayState action.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionSetRelayState set_relay_state = 10;
     */
    value: ActionSetRelayState;
    case: "setRelayState";
  } | {
    /**
     * Defines the SetDisconnectorState action.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionSetDisconnectorState set_disconnector_state = 12;
     */
    value: ActionSetDisconnectorState;
    case: "setDisconnectorState";
  } | {
    /**
     * Defines the GetTou action.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionGetTou get_tou = 13;
     */
    value: ActionGetTou;
    case: "getTou";
  } | {
    /**
     * Defines the SetTou action..
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionSetTou set_tou = 14;
     */
    value: ActionSetTou;
    case: "setTou";
  } | {
    /**
     * Defines the SetLimiter action.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionSetLimiter set_limiter = 16;
     */
    value: ActionSetLimiter;
    case: "setLimiter";
  } | {
    /**
     * Defines the ResetBillingPeriod action.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionResetBillingPeriod reset_billing_period = 17;
     */
    value: ActionResetBillingPeriod;
    case: "resetBillingPeriod";
  } | {
    /**
     * Defines the firmware update action.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionFwUpdate fw_update = 18;
     */
    value: ActionFwUpdate;
    case: "fwUpdate";
  } | { case: undefined; value?: undefined };
};

/**
 * Defines the job action specification.
 * The `JobAction` represents a single action to be performed on a single device.
 * For example, if the action is `ActionGetRegister`, it specifies a single register to be read from the devices.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobAction
 */
export type JobActionJson = {
  /**
   * The unique identifier of the action.
   *
   * @generated from field: string action_id = 1;
   */
  actionId?: string;

  /**
   * The action attributes.
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.FieldValue> attributes = 2;
   */
  attributes?: { [key: string]: FieldValueJson };

  /**
   * Defines the GetRegister action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionGetRegister get_register = 3;
   */
  getRegister?: ActionGetRegisterJson;

  /**
   * Defines the GetPeriodicalProfile action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionGetPeriodicalProfile get_periodical_profile = 4;
   */
  getPeriodicalProfile?: ActionGetPeriodicalProfileJson;

  /**
   * Defines the GetIrregularProfile action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionGetIrregularProfile get_irregular_profile = 5;
   */
  getIrregularProfile?: ActionGetIrregularProfileJson;

  /**
   * Defines the GetEvents action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionGetEvents get_events = 6;
   */
  getEvents?: ActionGetEventsJson;

  /**
   * Defines the GetDeviceInfo action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionGetDeviceInfo get_device_info = 7;
   */
  getDeviceInfo?: ActionGetDeviceInfoJson;

  /**
   * Defines the SyncClock action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionSyncClock sync_clock = 8;
   */
  syncClock?: ActionSyncClockJson;

  /**
   * Defines the SetRelayState action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionSetRelayState set_relay_state = 10;
   */
  setRelayState?: ActionSetRelayStateJson;

  /**
   * Defines the SetDisconnectorState action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionSetDisconnectorState set_disconnector_state = 12;
   */
  setDisconnectorState?: ActionSetDisconnectorStateJson;

  /**
   * Defines the GetTou action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionGetTou get_tou = 13;
   */
  getTou?: ActionGetTouJson;

  /**
   * Defines the SetTou action..
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionSetTou set_tou = 14;
   */
  setTou?: ActionSetTouJson;

  /**
   * Defines the SetLimiter action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionSetLimiter set_limiter = 16;
   */
  setLimiter?: ActionSetLimiterJson;

  /**
   * Defines the ResetBillingPeriod action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionResetBillingPeriod reset_billing_period = 17;
   */
  resetBillingPeriod?: ActionResetBillingPeriodJson;

  /**
   * Defines the firmware update action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionFwUpdate fw_update = 18;
   */
  fwUpdate?: ActionFwUpdateJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.JobAction.
 * Use `create(JobActionSchema)` to create a new message.
 */
export const JobActionSchema: GenMessage<JobAction, {jsonType: JobActionJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 1);

/**
 * Defines the job action set specification.
 * Unlike a single `JobAction` that is used only once per bulk. `JobActionSet` may internally cover multiple `JobActions`.
 * For example, if the action type is `GetRegister` and no variable filter is specified, the system automatically retrieves all registers defined in the active device configuration template.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobActionSet
 */
export type JobActionSet = Message<"io.clbs.openhes.models.acquisition.JobActionSet"> & {
  /**
   * The variable filter. Meaning depends on the action type:
   *  - `GetRegister`, `GetPeriodicalProfile` and `GetIrregularProfile`: List of variable names (for example, `"A+"`) defined in the system. If not set, all variables of the given type are read.
   * - Others: Not applicable (ignored).
   *
   * @generated from field: repeated string variables = 2;
   */
  variables: string[];

  /**
   * @generated from oneof io.clbs.openhes.models.acquisition.JobActionSet.action
   */
  action: {
    /**
     * Defines the GetRegister action.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionGetRegister get_register = 3;
     */
    value: ActionGetRegister;
    case: "getRegister";
  } | {
    /**
     * Defines the GetPeriodicalProfile action.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionGetPeriodicalProfile get_periodical_profile = 4;
     */
    value: ActionGetPeriodicalProfile;
    case: "getPeriodicalProfile";
  } | {
    /**
     * Defines the GetIrregularProfile action.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionGetIrregularProfile get_irregular_profile = 5;
     */
    value: ActionGetIrregularProfile;
    case: "getIrregularProfile";
  } | {
    /**
     * Defines the GetEvents action.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionGetEvents get_events = 6;
     */
    value: ActionGetEvents;
    case: "getEvents";
  } | {
    /**
     * Defines the GetDeviceInfo action.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionGetDeviceInfo get_device_info = 7;
     */
    value: ActionGetDeviceInfo;
    case: "getDeviceInfo";
  } | {
    /**
     * Defines the SyncClock action.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionSyncClock sync_clock = 8;
     */
    value: ActionSyncClock;
    case: "syncClock";
  } | {
    /**
     * Defines the SetRelayState action.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionSetRelayState set_relay_state = 10;
     */
    value: ActionSetRelayState;
    case: "setRelayState";
  } | {
    /**
     * Defines the SetDisconnectorState action.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionSetDisconnectorState set_disconnector_state = 12;
     */
    value: ActionSetDisconnectorState;
    case: "setDisconnectorState";
  } | {
    /**
     * Defines the GetTou action.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionGetTou get_tou = 13;
     */
    value: ActionGetTou;
    case: "getTou";
  } | {
    /**
     * Defines the SetTou action..
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionSetTou set_tou = 14;
     */
    value: ActionSetTou;
    case: "setTou";
  } | {
    /**
     * Defines the SetLimiter action.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionSetLimiter set_limiter = 16;
     */
    value: ActionSetLimiter;
    case: "setLimiter";
  } | {
    /**
     * Defines the ResetBillingPeriod action.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionResetBillingPeriod reset_billing_period = 17;
     */
    value: ActionResetBillingPeriod;
    case: "resetBillingPeriod";
  } | {
    /**
     * Defines the firmware update action.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ActionFwUpdate fw_update = 18;
     */
    value: ActionFwUpdate;
    case: "fwUpdate";
  } | { case: undefined; value?: undefined };
};

/**
 * Defines the job action set specification.
 * Unlike a single `JobAction` that is used only once per bulk. `JobActionSet` may internally cover multiple `JobActions`.
 * For example, if the action type is `GetRegister` and no variable filter is specified, the system automatically retrieves all registers defined in the active device configuration template.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobActionSet
 */
export type JobActionSetJson = {
  /**
   * The variable filter. Meaning depends on the action type:
   *  - `GetRegister`, `GetPeriodicalProfile` and `GetIrregularProfile`: List of variable names (for example, `"A+"`) defined in the system. If not set, all variables of the given type are read.
   * - Others: Not applicable (ignored).
   *
   * @generated from field: repeated string variables = 2;
   */
  variables?: string[];

  /**
   * Defines the GetRegister action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionGetRegister get_register = 3;
   */
  getRegister?: ActionGetRegisterJson;

  /**
   * Defines the GetPeriodicalProfile action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionGetPeriodicalProfile get_periodical_profile = 4;
   */
  getPeriodicalProfile?: ActionGetPeriodicalProfileJson;

  /**
   * Defines the GetIrregularProfile action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionGetIrregularProfile get_irregular_profile = 5;
   */
  getIrregularProfile?: ActionGetIrregularProfileJson;

  /**
   * Defines the GetEvents action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionGetEvents get_events = 6;
   */
  getEvents?: ActionGetEventsJson;

  /**
   * Defines the GetDeviceInfo action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionGetDeviceInfo get_device_info = 7;
   */
  getDeviceInfo?: ActionGetDeviceInfoJson;

  /**
   * Defines the SyncClock action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionSyncClock sync_clock = 8;
   */
  syncClock?: ActionSyncClockJson;

  /**
   * Defines the SetRelayState action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionSetRelayState set_relay_state = 10;
   */
  setRelayState?: ActionSetRelayStateJson;

  /**
   * Defines the SetDisconnectorState action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionSetDisconnectorState set_disconnector_state = 12;
   */
  setDisconnectorState?: ActionSetDisconnectorStateJson;

  /**
   * Defines the GetTou action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionGetTou get_tou = 13;
   */
  getTou?: ActionGetTouJson;

  /**
   * Defines the SetTou action..
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionSetTou set_tou = 14;
   */
  setTou?: ActionSetTouJson;

  /**
   * Defines the SetLimiter action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionSetLimiter set_limiter = 16;
   */
  setLimiter?: ActionSetLimiterJson;

  /**
   * Defines the ResetBillingPeriod action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionResetBillingPeriod reset_billing_period = 17;
   */
  resetBillingPeriod?: ActionResetBillingPeriodJson;

  /**
   * Defines the firmware update action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionFwUpdate fw_update = 18;
   */
  fwUpdate?: ActionFwUpdateJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.JobActionSet.
 * Use `create(JobActionSetSchema)` to create a new message.
 */
export const JobActionSetSchema: GenMessage<JobActionSet, {jsonType: JobActionSetJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 2);

/**
 * Defines a list of job devices included in a bulk.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ListOfJobDevice
 */
export type ListOfJobDevice = Message<"io.clbs.openhes.models.acquisition.ListOfJobDevice"> & {
  /**
   * The list of devices included in the bulk.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.JobDevice list = 1;
   */
  list: JobDevice[];

  /**
   * The total number of items in the list.
   *
   * @generated from field: int32 total_count = 2;
   */
  totalCount: number;
};

/**
 * Defines a list of job devices included in a bulk.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ListOfJobDevice
 */
export type ListOfJobDeviceJson = {
  /**
   * The list of devices included in the bulk.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.JobDevice list = 1;
   */
  list?: JobDeviceJson[];

  /**
   * The total number of items in the list.
   *
   * @generated from field: int32 total_count = 2;
   */
  totalCount?: number;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ListOfJobDevice.
 * Use `create(ListOfJobDeviceSchema)` to create a new message.
 */
export const ListOfJobDeviceSchema: GenMessage<ListOfJobDevice, {jsonType: ListOfJobDeviceJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 3);

/**
 * Defines a list of device identifiers.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ListOfJobDeviceId
 */
export type ListOfJobDeviceId = Message<"io.clbs.openhes.models.acquisition.ListOfJobDeviceId"> & {
  /**
   * The list of device identifiers in the bulk.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.JobDeviceId list = 1;
   */
  list: JobDeviceId[];

  /**
   * The total number of device identifiers in the list.
   *
   * @generated from field: int32 total_count = 2;
   */
  totalCount: number;
};

/**
 * Defines a list of device identifiers.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ListOfJobDeviceId
 */
export type ListOfJobDeviceIdJson = {
  /**
   * The list of device identifiers in the bulk.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.JobDeviceId list = 1;
   */
  list?: JobDeviceIdJson[];

  /**
   * The total number of device identifiers in the list.
   *
   * @generated from field: int32 total_count = 2;
   */
  totalCount?: number;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ListOfJobDeviceId.
 * Use `create(ListOfJobDeviceIdSchema)` to create a new message.
 */
export const ListOfJobDeviceIdSchema: GenMessage<ListOfJobDeviceId, {jsonType: ListOfJobDeviceIdJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 4);

/**
 * Defines the association between bulk jobs and individual devices.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobDeviceId
 */
export type JobDeviceId = Message<"io.clbs.openhes.models.acquisition.JobDeviceId"> & {
  /**
   * The identifier of the device's job within the parent bulk.
   *
   * @generated from field: string job_id = 1;
   */
  jobId: string;

  /**
   * The unique identifier of the device.
   *
   * @generated from field: string device_id = 2;
   */
  deviceId: string;
};

/**
 * Defines the association between bulk jobs and individual devices.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobDeviceId
 */
export type JobDeviceIdJson = {
  /**
   * The identifier of the device's job within the parent bulk.
   *
   * @generated from field: string job_id = 1;
   */
  jobId?: string;

  /**
   * The unique identifier of the device.
   *
   * @generated from field: string device_id = 2;
   */
  deviceId?: string;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.JobDeviceId.
 * Use `create(JobDeviceIdSchema)` to create a new message.
 */
export const JobDeviceIdSchema: GenMessage<JobDeviceId, {jsonType: JobDeviceIdJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 5);

/**
 * Defines the information for a device job.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobDevice
 */
export type JobDevice = Message<"io.clbs.openhes.models.acquisition.JobDevice"> & {
  /**
   * The unique job identifier within the parent bulk.
   *
   * @generated from field: string job_id = 1;
   */
  jobId: string;

  /**
   * The unique device identifier. If set, all subsequent details are loaded automatically from the device registry.
   *
   * @generated from field: string device_id = 2;
   */
  deviceId: string;

  /**
   * The external device identifier.
   *
   * @generated from field: string external_id = 3;
   */
  externalId: string;

  /**
   * The connection attributes for the device. The options depend on the `ApplicationProtocolTemplate` of the given application protocol (see the `app_protocol` property).
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.FieldValue> device_attributes = 4;
   */
  deviceAttributes: { [key: string]: FieldValue };

  /**
   * The device connection parameters.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.ConnectionInfo connection_info = 5;
   */
  connectionInfo: ConnectionInfo[];

  /**
   * The application protocol used to communicate with the device.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ApplicationProtocol app_protocol = 6;
   */
  appProtocol: ApplicationProtocol;

  /**
   * The timezone associated with the device. For example, `"America/New_York"`, `"Europe/Prague"`, `"CET"`, `"GMT"`, `"Etc/GMT+2"`.
   *
   * @generated from field: string timezone = 7;
   */
  timezone: string;
};

/**
 * Defines the information for a device job.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobDevice
 */
export type JobDeviceJson = {
  /**
   * The unique job identifier within the parent bulk.
   *
   * @generated from field: string job_id = 1;
   */
  jobId?: string;

  /**
   * The unique device identifier. If set, all subsequent details are loaded automatically from the device registry.
   *
   * @generated from field: string device_id = 2;
   */
  deviceId?: string;

  /**
   * The external device identifier.
   *
   * @generated from field: string external_id = 3;
   */
  externalId?: string;

  /**
   * The connection attributes for the device. The options depend on the `ApplicationProtocolTemplate` of the given application protocol (see the `app_protocol` property).
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.FieldValue> device_attributes = 4;
   */
  deviceAttributes?: { [key: string]: FieldValueJson };

  /**
   * The device connection parameters.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.ConnectionInfo connection_info = 5;
   */
  connectionInfo?: ConnectionInfoJson[];

  /**
   * The application protocol used to communicate with the device.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ApplicationProtocol app_protocol = 6;
   */
  appProtocol?: ApplicationProtocolJson;

  /**
   * The timezone associated with the device. For example, `"America/New_York"`, `"Europe/Prague"`, `"CET"`, `"GMT"`, `"Etc/GMT+2"`.
   *
   * @generated from field: string timezone = 7;
   */
  timezone?: string;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.JobDevice.
 * Use `create(JobDeviceSchema)` to create a new message.
 */
export const JobDeviceSchema: GenMessage<JobDevice, {jsonType: JobDeviceJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 6);

/**
 * Defines modem connection information.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ModemInfo
 */
export type ModemInfo = Message<"io.clbs.openhes.models.acquisition.ModemInfo"> & {
  /**
   * The unique identifier of the modem. It is automatically generated during creation.
   *
   * @generated from field: string modem_id = 1;
   */
  modemId: string;

  /**
   * The name of the modem.
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * The modem initialization command. For example, `AT&FE0X3`.
   *
   * @generated from field: string at_init = 3;
   */
  atInit: string;

  /**
   * The modem dial command. For example, `ATD`.
   *
   * @generated from field: string at_dial = 4;
   */
  atDial: string;

  /**
   * The modem hangup command. For example, `ATH`.
   *
   * @generated from field: string at_hangup = 5;
   */
  atHangup: string;

  /**
   * The modem escape command. For exampl, `+++`.
   *
   * @generated from field: string at_escape = 6;
   */
  atEscape: string;

  /**
   * The modem connection timeout, if applicable by the `modem_connection` field.
   *
   * @generated from field: google.protobuf.Duration connect_timeout = 7;
   */
  connectTimeout?: Duration;

  /**
   * The modem command timeout, if applicable given by the modem_connection field.
   *
   * @generated from field: google.protobuf.Duration command_timeout = 8;
   */
  commandTimeout?: Duration;

  /**
   * The modem connection description.
   *
   * @generated from oneof io.clbs.openhes.models.acquisition.ModemInfo.modem_connection
   */
  modemConnection: {
    /**
     * The TCP connection type. The modem either supports TCP directly, or an IP-to-serial converter is used that handles the serial configuration.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ConnectionTypeDirectTcpIp tcpip = 9;
     */
    value: ConnectionTypeDirectTcpIp;
    case: "tcpip";
  } | {
    /**
     * The serial-over-IP connection type. Used when the modem is connected via an IP-to-serial converter and requires specific handling.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ConnectionTypeControlledSerial serial_over_ip = 10;
     */
    value: ConnectionTypeControlledSerial;
    case: "serialOverIp";
  } | { case: undefined; value?: undefined };
};

/**
 * Defines modem connection information.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ModemInfo
 */
export type ModemInfoJson = {
  /**
   * The unique identifier of the modem. It is automatically generated during creation.
   *
   * @generated from field: string modem_id = 1;
   */
  modemId?: string;

  /**
   * The name of the modem.
   *
   * @generated from field: string name = 2;
   */
  name?: string;

  /**
   * The modem initialization command. For example, `AT&FE0X3`.
   *
   * @generated from field: string at_init = 3;
   */
  atInit?: string;

  /**
   * The modem dial command. For example, `ATD`.
   *
   * @generated from field: string at_dial = 4;
   */
  atDial?: string;

  /**
   * The modem hangup command. For example, `ATH`.
   *
   * @generated from field: string at_hangup = 5;
   */
  atHangup?: string;

  /**
   * The modem escape command. For exampl, `+++`.
   *
   * @generated from field: string at_escape = 6;
   */
  atEscape?: string;

  /**
   * The modem connection timeout, if applicable by the `modem_connection` field.
   *
   * @generated from field: google.protobuf.Duration connect_timeout = 7;
   */
  connectTimeout?: DurationJson;

  /**
   * The modem command timeout, if applicable given by the modem_connection field.
   *
   * @generated from field: google.protobuf.Duration command_timeout = 8;
   */
  commandTimeout?: DurationJson;

  /**
   * The TCP connection type. The modem either supports TCP directly, or an IP-to-serial converter is used that handles the serial configuration.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ConnectionTypeDirectTcpIp tcpip = 9;
   */
  tcpip?: ConnectionTypeDirectTcpIpJson;

  /**
   * The serial-over-IP connection type. Used when the modem is connected via an IP-to-serial converter and requires specific handling.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ConnectionTypeControlledSerial serial_over_ip = 10;
   */
  serialOverIp?: ConnectionTypeControlledSerialJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ModemInfo.
 * Use `create(ModemInfoSchema)` to create a new message.
 */
export const ModemInfoSchema: GenMessage<ModemInfo, {jsonType: ModemInfoJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 7);

/**
 * Defines the parameters for serial port configuration.
 *
 * @generated from message io.clbs.openhes.models.acquisition.SerialConfig
 */
export type SerialConfig = Message<"io.clbs.openhes.models.acquisition.SerialConfig"> & {
  /**
   * The baud rate.
   *
   * @generated from field: int32 baud_rate = 1;
   */
  baudRate: number;

  /**
   * The parity.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.SerialConfigParity parity = 2;
   */
  parity: SerialConfigParity;

  /**
   * The data bits.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.SerialConfigDataBits data_bits = 3;
   */
  dataBits: SerialConfigDataBits;

  /**
   * The stop bits.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.SerialConfigStopBits stop_bits = 4;
   */
  stopBits: SerialConfigStopBits;

  /**
   * The flow control.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.SerialConfigFLowControler flow_control = 5;
   */
  flowControl: SerialConfigFLowControler;
};

/**
 * Defines the parameters for serial port configuration.
 *
 * @generated from message io.clbs.openhes.models.acquisition.SerialConfig
 */
export type SerialConfigJson = {
  /**
   * The baud rate.
   *
   * @generated from field: int32 baud_rate = 1;
   */
  baudRate?: number;

  /**
   * The parity.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.SerialConfigParity parity = 2;
   */
  parity?: SerialConfigParityJson;

  /**
   * The data bits.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.SerialConfigDataBits data_bits = 3;
   */
  dataBits?: SerialConfigDataBitsJson;

  /**
   * The stop bits.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.SerialConfigStopBits stop_bits = 4;
   */
  stopBits?: SerialConfigStopBitsJson;

  /**
   * The flow control.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.SerialConfigFLowControler flow_control = 5;
   */
  flowControl?: SerialConfigFLowControlerJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.SerialConfig.
 * Use `create(SerialConfigSchema)` to create a new message.
 */
export const SerialConfigSchema: GenMessage<SerialConfig, {jsonType: SerialConfigJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 8);

/**
 * Defines the configuration parameters for device connection.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ConnectionInfo
 */
export type ConnectionInfo = Message<"io.clbs.openhes.models.acquisition.ConnectionInfo"> & {
  /**
   * The entrypoint connection description. The connection can be either direct TCP, a modem from a pool, or a direct serial line over IP (via an using IP-to-serial converter).
   *
   * @generated from oneof io.clbs.openhes.models.acquisition.ConnectionInfo.connection
   */
  connection: {
    /**
     * The TCP/IP connection type.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ConnectionTypeDirectTcpIp tcpip = 1;
     */
    value: ConnectionTypeDirectTcpIp;
    case: "tcpip";
  } | {
    /**
     * The phone-based (modem pool) connection type..
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ConnectionTypeModemPool modem_pool = 2;
     */
    value: ConnectionTypeModemPool;
    case: "modemPool";
  } | {
    /**
     * The serial-over-IP connection type.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ConnectionTypeControlledSerial serial_over_ip = 3;
     */
    value: ConnectionTypeControlledSerial;
    case: "serialOverIp";
  } | { case: undefined; value?: undefined };

  /**
   * The data link protocol.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.DataLinkProtocol link_protocol = 4;
   */
  linkProtocol: DataLinkProtocol;

  /**
   * he communication bus identifier. Works as a custom grouping key to link jobs across multiple communication units when multiple entry points share a single communication bus (foe example, multi-master RS-485 withprimary and backup masters). If not set, jobs are grouped by the default group key based on the connection type.
   *
   * @generated from field: string communication_bus_id = 5;
   */
  communicationBusId: string;

  /**
   * The connection attributes. See `GetDataLinkFields` in the acquisition package.
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.FieldValue> attributes = 6;
   */
  attributes: { [key: string]: FieldValue };
};

/**
 * Defines the configuration parameters for device connection.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ConnectionInfo
 */
export type ConnectionInfoJson = {
  /**
   * The TCP/IP connection type.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ConnectionTypeDirectTcpIp tcpip = 1;
   */
  tcpip?: ConnectionTypeDirectTcpIpJson;

  /**
   * The phone-based (modem pool) connection type..
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ConnectionTypeModemPool modem_pool = 2;
   */
  modemPool?: ConnectionTypeModemPoolJson;

  /**
   * The serial-over-IP connection type.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ConnectionTypeControlledSerial serial_over_ip = 3;
   */
  serialOverIp?: ConnectionTypeControlledSerialJson;

  /**
   * The data link protocol.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.DataLinkProtocol link_protocol = 4;
   */
  linkProtocol?: DataLinkProtocolJson;

  /**
   * he communication bus identifier. Works as a custom grouping key to link jobs across multiple communication units when multiple entry points share a single communication bus (foe example, multi-master RS-485 withprimary and backup masters). If not set, jobs are grouped by the default group key based on the connection type.
   *
   * @generated from field: string communication_bus_id = 5;
   */
  communicationBusId?: string;

  /**
   * The connection attributes. See `GetDataLinkFields` in the acquisition package.
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.FieldValue> attributes = 6;
   */
  attributes?: { [key: string]: FieldValueJson };
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ConnectionInfo.
 * Use `create(ConnectionInfoSchema)` to create a new message.
 */
export const ConnectionInfoSchema: GenMessage<ConnectionInfo, {jsonType: ConnectionInfoJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 9);

/**
 * Defines the connection information for direct TCP/IP connection type.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ConnectionTypeDirectTcpIp
 */
export type ConnectionTypeDirectTcpIp = Message<"io.clbs.openhes.models.acquisition.ConnectionTypeDirectTcpIp"> & {
  /**
   * The hostname or IP address of the device to connect to.
   *
   * @generated from field: string host = 1;
   */
  host: string;

  /**
   * The TCP port number of the device to connect to.
   *
   * @generated from field: uint32 port = 2;
   */
  port: number;

  /**
   * The timeout for TCP/IP connection.
   *
   * @generated from field: google.protobuf.Duration timeout = 3;
   */
  timeout?: Duration;
};

/**
 * Defines the connection information for direct TCP/IP connection type.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ConnectionTypeDirectTcpIp
 */
export type ConnectionTypeDirectTcpIpJson = {
  /**
   * The hostname or IP address of the device to connect to.
   *
   * @generated from field: string host = 1;
   */
  host?: string;

  /**
   * The TCP port number of the device to connect to.
   *
   * @generated from field: uint32 port = 2;
   */
  port?: number;

  /**
   * The timeout for TCP/IP connection.
   *
   * @generated from field: google.protobuf.Duration timeout = 3;
   */
  timeout?: DurationJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ConnectionTypeDirectTcpIp.
 * Use `create(ConnectionTypeDirectTcpIpSchema)` to create a new message.
 */
export const ConnectionTypeDirectTcpIpSchema: GenMessage<ConnectionTypeDirectTcpIp, {jsonType: ConnectionTypeDirectTcpIpJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 10);

/**
 * Defines the connection information for a phone line (modem) connection type.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ConnectionTypeModemPool
 */
export type ConnectionTypeModemPool = Message<"io.clbs.openhes.models.acquisition.ConnectionTypeModemPool"> & {
  /**
   * The phone number of the device to connect to.
   *
   * @generated from field: string number = 1;
   */
  number: string;

  /**
   * The unique modem pool identifier. A modem pool is a group of modems that can be used to connect to the device. The final modem is selected by the Taskmaster at the job start.
   *
   * @generated from field: string pool_id = 2;
   */
  poolId: string;

  /**
   * The modem device assigned to the job. This field filled only when the connection type is modem. The value is assigned by the Taskmaster at the start of the job, and the driver must use this modem exclusively for this job!
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ModemInfo modem = 4;
   */
  modem?: ModemInfo;
};

/**
 * Defines the connection information for a phone line (modem) connection type.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ConnectionTypeModemPool
 */
export type ConnectionTypeModemPoolJson = {
  /**
   * The phone number of the device to connect to.
   *
   * @generated from field: string number = 1;
   */
  number?: string;

  /**
   * The unique modem pool identifier. A modem pool is a group of modems that can be used to connect to the device. The final modem is selected by the Taskmaster at the job start.
   *
   * @generated from field: string pool_id = 2;
   */
  poolId?: string;

  /**
   * The modem device assigned to the job. This field filled only when the connection type is modem. The value is assigned by the Taskmaster at the start of the job, and the driver must use this modem exclusively for this job!
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ModemInfo modem = 4;
   */
  modem?: ModemInfoJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ConnectionTypeModemPool.
 * Use `create(ConnectionTypeModemPoolSchema)` to create a new message.
 */
export const ConnectionTypeModemPoolSchema: GenMessage<ConnectionTypeModemPool, {jsonType: ConnectionTypeModemPoolJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 11);

/**
 * Defines the connection information for a direct serial port connection.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ConnectionTypeSerialDirect
 */
export type ConnectionTypeSerialDirect = Message<"io.clbs.openhes.models.acquisition.ConnectionTypeSerialDirect"> & {
  /**
   * The host name or IP address of the device to connect to.
   *
   * @generated from field: string host = 1;
   */
  host: string;

  /**
   * The TCP port number of the device to connect to.
   *
   * @generated from field: uint32 port = 2;
   */
  port: number;

  /**
   * The timeout for the direct serial port connection.
   *
   * @generated from field: google.protobuf.Duration timeout = 3;
   */
  timeout?: Duration;
};

/**
 * Defines the connection information for a direct serial port connection.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ConnectionTypeSerialDirect
 */
export type ConnectionTypeSerialDirectJson = {
  /**
   * The host name or IP address of the device to connect to.
   *
   * @generated from field: string host = 1;
   */
  host?: string;

  /**
   * The TCP port number of the device to connect to.
   *
   * @generated from field: uint32 port = 2;
   */
  port?: number;

  /**
   * The timeout for the direct serial port connection.
   *
   * @generated from field: google.protobuf.Duration timeout = 3;
   */
  timeout?: DurationJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ConnectionTypeSerialDirect.
 * Use `create(ConnectionTypeSerialDirectSchema)` to create a new message.
 */
export const ConnectionTypeSerialDirectSchema: GenMessage<ConnectionTypeSerialDirect, {jsonType: ConnectionTypeSerialDirectJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 12);

/**
 * Defines the connection information for a controlled serial line using the Moxa protocol.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ConnectionTypeSerialMoxa
 */
export type ConnectionTypeSerialMoxa = Message<"io.clbs.openhes.models.acquisition.ConnectionTypeSerialMoxa"> & {
  /**
   * The host name or IP address of the device to connect to.
   *
   * @generated from field: string host = 1;
   */
  host: string;

  /**
   * The TCP data port number of the device to connect to.
   *
   * @generated from field: uint32 data_port = 2;
   */
  dataPort: number;

  /**
   * The TCP command port number of the device to connect to.
   *
   * @generated from field: uint32 command_port = 3;
   */
  commandPort: number;

  /**
   * The timeout for the serial port connection using the Moxa protocol.
   *
   * @generated from field: google.protobuf.Duration timeout = 4;
   */
  timeout?: Duration;

  /**
   * The serial port configuration. Optional. If not set, current Moxa settings are preserved.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.SerialConfig serial_config = 5;
   */
  serialConfig?: SerialConfig;
};

/**
 * Defines the connection information for a controlled serial line using the Moxa protocol.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ConnectionTypeSerialMoxa
 */
export type ConnectionTypeSerialMoxaJson = {
  /**
   * The host name or IP address of the device to connect to.
   *
   * @generated from field: string host = 1;
   */
  host?: string;

  /**
   * The TCP data port number of the device to connect to.
   *
   * @generated from field: uint32 data_port = 2;
   */
  dataPort?: number;

  /**
   * The TCP command port number of the device to connect to.
   *
   * @generated from field: uint32 command_port = 3;
   */
  commandPort?: number;

  /**
   * The timeout for the serial port connection using the Moxa protocol.
   *
   * @generated from field: google.protobuf.Duration timeout = 4;
   */
  timeout?: DurationJson;

  /**
   * The serial port configuration. Optional. If not set, current Moxa settings are preserved.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.SerialConfig serial_config = 5;
   */
  serialConfig?: SerialConfigJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ConnectionTypeSerialMoxa.
 * Use `create(ConnectionTypeSerialMoxaSchema)` to create a new message.
 */
export const ConnectionTypeSerialMoxaSchema: GenMessage<ConnectionTypeSerialMoxa, {jsonType: ConnectionTypeSerialMoxaJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 13);

/**
 * Defines the connection information for a controlled serial line using the RFC 2217 protocol.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ConnectionTypeSerialRfc2217
 */
export type ConnectionTypeSerialRfc2217 = Message<"io.clbs.openhes.models.acquisition.ConnectionTypeSerialRfc2217"> & {
  /**
   * The host name or IP address of the device to connect to.
   *
   * @generated from field: string host = 1;
   */
  host: string;

  /**
   * The TCP port number of the device to connect to.
   *
   * @generated from field: uint32 port = 2;
   */
  port: number;

  /**
   * The timeout for serial port connection using the RFC 2217 protocol.
   *
   * @generated from field: google.protobuf.Duration timeout = 3;
   */
  timeout?: Duration;

  /**
   * The serial port configuration. Optional. If not set, current Moxa settings are preserved.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.SerialConfig serial_config = 4;
   */
  serialConfig?: SerialConfig;
};

/**
 * Defines the connection information for a controlled serial line using the RFC 2217 protocol.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ConnectionTypeSerialRfc2217
 */
export type ConnectionTypeSerialRfc2217Json = {
  /**
   * The host name or IP address of the device to connect to.
   *
   * @generated from field: string host = 1;
   */
  host?: string;

  /**
   * The TCP port number of the device to connect to.
   *
   * @generated from field: uint32 port = 2;
   */
  port?: number;

  /**
   * The timeout for serial port connection using the RFC 2217 protocol.
   *
   * @generated from field: google.protobuf.Duration timeout = 3;
   */
  timeout?: DurationJson;

  /**
   * The serial port configuration. Optional. If not set, current Moxa settings are preserved.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.SerialConfig serial_config = 4;
   */
  serialConfig?: SerialConfigJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ConnectionTypeSerialRfc2217.
 * Use `create(ConnectionTypeSerialRfc2217Schema)` to create a new message.
 */
export const ConnectionTypeSerialRfc2217Schema: GenMessage<ConnectionTypeSerialRfc2217, {jsonType: ConnectionTypeSerialRfc2217Json}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 14);

/**
 * Defines the destription for one application protocol, for example DLMS_SN.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ApplicationProtocolTemplate
 */
export type ApplicationProtocolTemplate = Message<"io.clbs.openhes.models.acquisition.ApplicationProtocolTemplate"> & {
  /**
   * The application protocol.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ApplicationProtocol protocol = 1;
   */
  protocol: ApplicationProtocol;

  /**
   * The list of attribute definitions for the selected application protocol. These attributes are instantiated for each device and communication unit pair.
   *
   * @generated from field: repeated io.clbs.openhes.models.common.FieldDescriptor attributes = 2;
   */
  attributes: FieldDescriptor[];
};

/**
 * Defines the destription for one application protocol, for example DLMS_SN.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ApplicationProtocolTemplate
 */
export type ApplicationProtocolTemplateJson = {
  /**
   * The application protocol.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ApplicationProtocol protocol = 1;
   */
  protocol?: ApplicationProtocolJson;

  /**
   * The list of attribute definitions for the selected application protocol. These attributes are instantiated for each device and communication unit pair.
   *
   * @generated from field: repeated io.clbs.openhes.models.common.FieldDescriptor attributes = 2;
   */
  attributes?: FieldDescriptorJson[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ApplicationProtocolTemplate.
 * Use `create(ApplicationProtocolTemplateSchema)` to create a new message.
 */
export const ApplicationProtocolTemplateSchema: GenMessage<ApplicationProtocolTemplate, {jsonType: ApplicationProtocolTemplateJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 15);

/**
 * Defines the destription of a single data link protocol, for example `HDLC`.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DataLinkTemplate
 */
export type DataLinkTemplate = Message<"io.clbs.openhes.models.acquisition.DataLinkTemplate"> & {
  /**
   * The data link protocol.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.DataLinkProtocol link_protocol = 1;
   */
  linkProtocol: DataLinkProtocol;

  /**
   * The list of application protocol identifiers supported by the driver.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.ApplicationProtocol app_protocol_refs = 2;
   */
  appProtocolRefs: ApplicationProtocol[];

  /**
   * The list of attribute definitions related to the selected data link type (see l`ink_protocol` property). These field definitions are provided by the system and drivers must leave this field empty.
   *
   * @generated from field: repeated io.clbs.openhes.models.common.FieldDescriptor attributes = 3;
   */
  attributes: FieldDescriptor[];
};

/**
 * Defines the destription of a single data link protocol, for example `HDLC`.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DataLinkTemplate
 */
export type DataLinkTemplateJson = {
  /**
   * The data link protocol.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.DataLinkProtocol link_protocol = 1;
   */
  linkProtocol?: DataLinkProtocolJson;

  /**
   * The list of application protocol identifiers supported by the driver.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.ApplicationProtocol app_protocol_refs = 2;
   */
  appProtocolRefs?: ApplicationProtocolJson[];

  /**
   * The list of attribute definitions related to the selected data link type (see l`ink_protocol` property). These field definitions are provided by the system and drivers must leave this field empty.
   *
   * @generated from field: repeated io.clbs.openhes.models.common.FieldDescriptor attributes = 3;
   */
  attributes?: FieldDescriptorJson[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.DataLinkTemplate.
 * Use `create(DataLinkTemplateSchema)` to create a new message.
 */
export const DataLinkTemplateSchema: GenMessage<DataLinkTemplate, {jsonType: DataLinkTemplateJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 16);

/**
 * Defines the destription of a single communication type, for example `TCP/IP`.
 *
 * @generated from message io.clbs.openhes.models.acquisition.CommunicationTemplate
 */
export type CommunicationTemplate = Message<"io.clbs.openhes.models.acquisition.CommunicationTemplate"> & {
  /**
   * The communication type.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.CommunicationType type = 1;
   */
  type: CommunicationType;

  /**
   * The list of supprted data link protocols and their application protocols supported by the driver.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.DataLinkTemplate datalinks = 2;
   */
  datalinks: DataLinkTemplate[];
};

/**
 * Defines the destription of a single communication type, for example `TCP/IP`.
 *
 * @generated from message io.clbs.openhes.models.acquisition.CommunicationTemplate
 */
export type CommunicationTemplateJson = {
  /**
   * The communication type.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.CommunicationType type = 1;
   */
  type?: CommunicationTypeJson;

  /**
   * The list of supprted data link protocols and their application protocols supported by the driver.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.DataLinkTemplate datalinks = 2;
   */
  datalinks?: DataLinkTemplateJson[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.CommunicationTemplate.
 * Use `create(CommunicationTemplateSchema)` to create a new message.
 */
export const CommunicationTemplateSchema: GenMessage<CommunicationTemplate, {jsonType: CommunicationTemplateJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 17);

/**
 * Defines the access level configuration for a driver.
 *
 * @generated from message io.clbs.openhes.models.acquisition.AccessLevelTemplate
 */
export type AccessLevelTemplate = Message<"io.clbs.openhes.models.acquisition.AccessLevelTemplate"> & {
  /**
   * The unique identifier of the access level, such as `"1"`, `"G"`, or `"16"`.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The name of the access level. It must be unique and written in English (for example, `"Management"`, `"Public"`).
   *
   * @generated from field: string name = 2;
   */
  name: string;
};

/**
 * Defines the access level configuration for a driver.
 *
 * @generated from message io.clbs.openhes.models.acquisition.AccessLevelTemplate
 */
export type AccessLevelTemplateJson = {
  /**
   * The unique identifier of the access level, such as `"1"`, `"G"`, or `"16"`.
   *
   * @generated from field: string id = 1;
   */
  id?: string;

  /**
   * The name of the access level. It must be unique and written in English (for example, `"Management"`, `"Public"`).
   *
   * @generated from field: string name = 2;
   */
  name?: string;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.AccessLevelTemplate.
 * Use `create(AccessLevelTemplateSchema)` to create a new message.
 */
export const AccessLevelTemplateSchema: GenMessage<AccessLevelTemplate, {jsonType: AccessLevelTemplateJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 18);

/**
 * Defines the driver templates exchanged during driver negotiation.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DriverTemplates
 */
export type DriverTemplates = Message<"io.clbs.openhes.models.acquisition.DriverTemplates"> & {
  /**
   * The supported communication options templates. Each template represents one communication method. A driver can support multiple communication templates.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.CommunicationTemplate communication_templates = 1;
   */
  communicationTemplates: CommunicationTemplate[];

  /**
   * The supported application protocol templates.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.ApplicationProtocolTemplate app_protocols = 2;
   */
  appProtocols: ApplicationProtocolTemplate[];

  /**
   * The job action templates all supported action types. Each supported action type must appear onbly once.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.JobActionAttributes action_attributes = 3;
   */
  actionAttributes: JobActionAttributes[];

  /**
   * The supported access level templates.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.AccessLevelTemplate access_templates = 4;
   */
  accessTemplates: AccessLevelTemplate[];

  /**
   * The supported templates of the job actions constraints.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobActionContraints action_constraints = 5;
   */
  actionConstraints?: JobActionContraints;

  /**
   * The list of descriptors for uknown devices detected by the communication unit.
   * This applies only to drivers that communicate with devices like data concentrators that can provide information for unknown devices.
   * The descriptors must cover all data attributes used in the `SetUnknownDevicesRequest` message.
   *
   * @generated from field: repeated io.clbs.openhes.models.common.FieldDescriptor uknown_device_descriptors = 6;
   */
  uknownDeviceDescriptors: FieldDescriptor[];
};

/**
 * Defines the driver templates exchanged during driver negotiation.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DriverTemplates
 */
export type DriverTemplatesJson = {
  /**
   * The supported communication options templates. Each template represents one communication method. A driver can support multiple communication templates.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.CommunicationTemplate communication_templates = 1;
   */
  communicationTemplates?: CommunicationTemplateJson[];

  /**
   * The supported application protocol templates.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.ApplicationProtocolTemplate app_protocols = 2;
   */
  appProtocols?: ApplicationProtocolTemplateJson[];

  /**
   * The job action templates all supported action types. Each supported action type must appear onbly once.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.JobActionAttributes action_attributes = 3;
   */
  actionAttributes?: JobActionAttributesJson[];

  /**
   * The supported access level templates.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.AccessLevelTemplate access_templates = 4;
   */
  accessTemplates?: AccessLevelTemplateJson[];

  /**
   * The supported templates of the job actions constraints.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobActionContraints action_constraints = 5;
   */
  actionConstraints?: JobActionContraintsJson;

  /**
   * The list of descriptors for uknown devices detected by the communication unit.
   * This applies only to drivers that communicate with devices like data concentrators that can provide information for unknown devices.
   * The descriptors must cover all data attributes used in the `SetUnknownDevicesRequest` message.
   *
   * @generated from field: repeated io.clbs.openhes.models.common.FieldDescriptor uknown_device_descriptors = 6;
   */
  uknownDeviceDescriptors?: FieldDescriptorJson[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.DriverTemplates.
 * Use `create(DriverTemplatesSchema)` to create a new message.
 */
export const DriverTemplatesSchema: GenMessage<DriverTemplates, {jsonType: DriverTemplatesJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 19);

/**
 * Defines a progress update for an action within a job.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionProgressUpdate
 */
export type ActionProgressUpdate = Message<"io.clbs.openhes.models.acquisition.ActionProgressUpdate"> & {
  /**
   * The unique job identifier.
   *
   * @generated from field: string job_id = 1;
   */
  jobId: string;

  /**
   * The unique action identifier.
   *
   * @generated from field: string action_id = 2;
   */
  actionId: string;

  /**
   * The status code related to the action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionResultCode code = 3;
   */
  code: ActionResultCode;

  /**
   * The action result data. This field is empty if the code is not OK.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionProgressData data = 4;
   */
  data?: ActionProgressData;

  /**
   * The user-facing error message provided when the action ends with `ERROR_CODE_ACTION_ERROR`. The message provides details about the failure, can be multiline, and should be in English.
   *
   * @generated from field: io.clbs.openhes.models.common.FormattedMessage error_message = 5;
   */
  errorMessage?: FormattedMessage;
};

/**
 * Defines a progress update for an action within a job.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionProgressUpdate
 */
export type ActionProgressUpdateJson = {
  /**
   * The unique job identifier.
   *
   * @generated from field: string job_id = 1;
   */
  jobId?: string;

  /**
   * The unique action identifier.
   *
   * @generated from field: string action_id = 2;
   */
  actionId?: string;

  /**
   * The status code related to the action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionResultCode code = 3;
   */
  code?: ActionResultCodeJson;

  /**
   * The action result data. This field is empty if the code is not OK.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionProgressData data = 4;
   */
  data?: ActionProgressDataJson;

  /**
   * The user-facing error message provided when the action ends with `ERROR_CODE_ACTION_ERROR`. The message provides details about the failure, can be multiline, and should be in English.
   *
   * @generated from field: io.clbs.openhes.models.common.FormattedMessage error_message = 5;
   */
  errorMessage?: FormattedMessageJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionProgressUpdate.
 * Use `create(ActionProgressUpdateSchema)` to create a new message.
 */
export const ActionProgressUpdateSchema: GenMessage<ActionProgressUpdate, {jsonType: ActionProgressUpdateJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 20);

/**
 * Defines a progress update for a job.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobProgressUpdate
 */
export type JobProgressUpdate = Message<"io.clbs.openhes.models.acquisition.JobProgressUpdate"> & {
  /**
   * The unique job identifier.
   *
   * @generated from field: string job_id = 1;
   */
  jobId: string;

  /**
   * The status code related to the job or action update message.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobErrorCode code = 2;
   */
  code: JobErrorCode;

  /**
   * The time spent to handle the job.
   *
   * @generated from field: google.protobuf.Duration duration = 3;
   */
  duration?: Duration;

  /**
   * The user-facing error message for the job as a whole. This message related to the whole job. This message is used especially when no action is executed, to log a non-action related error.
   *
   * @generated from field: io.clbs.openhes.models.common.FormattedMessage error_message = 4;
   */
  errorMessage?: FormattedMessage;
};

/**
 * Defines a progress update for a job.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobProgressUpdate
 */
export type JobProgressUpdateJson = {
  /**
   * The unique job identifier.
   *
   * @generated from field: string job_id = 1;
   */
  jobId?: string;

  /**
   * The status code related to the job or action update message.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobErrorCode code = 2;
   */
  code?: JobErrorCodeJson;

  /**
   * The time spent to handle the job.
   *
   * @generated from field: google.protobuf.Duration duration = 3;
   */
  duration?: DurationJson;

  /**
   * The user-facing error message for the job as a whole. This message related to the whole job. This message is used especially when no action is executed, to log a non-action related error.
   *
   * @generated from field: io.clbs.openhes.models.common.FormattedMessage error_message = 4;
   */
  errorMessage?: FormattedMessageJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.JobProgressUpdate.
 * Use `create(JobProgressUpdateSchema)` to create a new message.
 */
export const JobProgressUpdateSchema: GenMessage<JobProgressUpdate, {jsonType: JobProgressUpdateJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 21);

/**
 * Defines the action-based variant of data values.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionProgressData
 */
export type ActionProgressData = Message<"io.clbs.openhes.models.acquisition.ActionProgressData"> & {
  /**
   * @generated from oneof io.clbs.openhes.models.acquisition.ActionProgressData.data
   */
  data: {
    /**
     * Indicates that no data was returned by the action.
     *
     * @generated from field: google.protobuf.Empty nodata = 1;
     */
    value: Empty;
    case: "nodata";
  } | {
    /**
     * The set of register values.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.RegisterValues registers = 2;
     */
    value: RegisterValues;
    case: "registers";
  } | {
    /**
     * The set of profile values. For efficiency, the profile values are binary-encoded, see acquisition/encoding.go.
     *
     * @generated from field: bytes profile = 3;
     */
    value: Uint8Array;
    case: "profile";
  } | {
    /**
     * The set of irregular (non-periodical) profile values, such as daily profiles.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.IrregularProfileValues irregular_profile = 4;
     */
    value: IrregularProfileValues;
    case: "irregularProfile";
  } | {
    /**
     * The device information.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.DeviceInfo device_info = 5;
     */
    value: DeviceInfo;
    case: "deviceInfo";
  } | {
    /**
     * The event records.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.EventRecords events = 6;
     */
    value: EventRecords;
    case: "events";
  } | {
    /**
     * The time-of-use (TOU) table.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.timeofuse.TimeOfUseTableSpec tou_table = 7;
     */
    value: TimeOfUseTableSpec;
    case: "touTable";
  } | { case: undefined; value?: undefined };
};

/**
 * Defines the action-based variant of data values.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionProgressData
 */
export type ActionProgressDataJson = {
  /**
   * Indicates that no data was returned by the action.
   *
   * @generated from field: google.protobuf.Empty nodata = 1;
   */
  nodata?: EmptyJson;

  /**
   * The set of register values.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.RegisterValues registers = 2;
   */
  registers?: RegisterValuesJson;

  /**
   * The set of profile values. For efficiency, the profile values are binary-encoded, see acquisition/encoding.go.
   *
   * @generated from field: bytes profile = 3;
   */
  profile?: string;

  /**
   * The set of irregular (non-periodical) profile values, such as daily profiles.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.IrregularProfileValues irregular_profile = 4;
   */
  irregularProfile?: IrregularProfileValuesJson;

  /**
   * The device information.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.DeviceInfo device_info = 5;
   */
  deviceInfo?: DeviceInfoJson;

  /**
   * The event records.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.EventRecords events = 6;
   */
  events?: EventRecordsJson;

  /**
   * The time-of-use (TOU) table.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.timeofuse.TimeOfUseTableSpec tou_table = 7;
   */
  touTable?: TimeOfUseTableSpecJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionProgressData.
 * Use `create(ActionProgressDataSchema)` to create a new message.
 */
export const ActionProgressDataSchema: GenMessage<ActionProgressData, {jsonType: ActionProgressDataJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 22);

/**
 * Defines the action-based variant of data values.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionData
 */
export type ActionData = Message<"io.clbs.openhes.models.acquisition.ActionData"> & {
  /**
   * @generated from oneof io.clbs.openhes.models.acquisition.ActionData.data
   */
  data: {
    /**
     * Indicates that no data was returned by the action.
     *
     * @generated from field: google.protobuf.Empty nodata = 1;
     */
    value: Empty;
    case: "nodata";
  } | {
    /**
     * The set of register values.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.RegisterValues registers = 2;
     */
    value: RegisterValues;
    case: "registers";
  } | {
    /**
     * The set of profile values.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ProfileValues profile = 3;
     */
    value: ProfileValues;
    case: "profile";
  } | {
    /**
     * The set of irregular (non-periodical) profile values, such as daily profiles.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.IrregularProfileValues irregular_profile = 4;
     */
    value: IrregularProfileValues;
    case: "irregularProfile";
  } | {
    /**
     * The device information.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.DeviceInfo device_info = 5;
     */
    value: DeviceInfo;
    case: "deviceInfo";
  } | {
    /**
     * The event records.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.EventRecords events = 6;
     */
    value: EventRecords;
    case: "events";
  } | {
    /**
     * The time-of-use (TOU) table.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.timeofuse.TimeOfUseTableSpec tou_table = 7;
     */
    value: TimeOfUseTableSpec;
    case: "touTable";
  } | { case: undefined; value?: undefined };
};

/**
 * Defines the action-based variant of data values.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionData
 */
export type ActionDataJson = {
  /**
   * Indicates that no data was returned by the action.
   *
   * @generated from field: google.protobuf.Empty nodata = 1;
   */
  nodata?: EmptyJson;

  /**
   * The set of register values.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.RegisterValues registers = 2;
   */
  registers?: RegisterValuesJson;

  /**
   * The set of profile values.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ProfileValues profile = 3;
   */
  profile?: ProfileValuesJson;

  /**
   * The set of irregular (non-periodical) profile values, such as daily profiles.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.IrregularProfileValues irregular_profile = 4;
   */
  irregularProfile?: IrregularProfileValuesJson;

  /**
   * The device information.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.DeviceInfo device_info = 5;
   */
  deviceInfo?: DeviceInfoJson;

  /**
   * The event records.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.EventRecords events = 6;
   */
  events?: EventRecordsJson;

  /**
   * The time-of-use (TOU) table.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.timeofuse.TimeOfUseTableSpec tou_table = 7;
   */
  touTable?: TimeOfUseTableSpecJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionData.
 * Use `create(ActionDataSchema)` to create a new message.
 */
export const ActionDataSchema: GenMessage<ActionData, {jsonType: ActionDataJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 23);

/**
 * Defines a list of event records.
 *
 * @generated from message io.clbs.openhes.models.acquisition.EventRecords
 */
export type EventRecords = Message<"io.clbs.openhes.models.acquisition.EventRecords"> & {
  /**
   * The list of event records.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.EventRecord values = 1;
   */
  values: EventRecord[];
};

/**
 * Defines a list of event records.
 *
 * @generated from message io.clbs.openhes.models.acquisition.EventRecords
 */
export type EventRecordsJson = {
  /**
   * The list of event records.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.EventRecord values = 1;
   */
  values?: EventRecordJson[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.EventRecords.
 * Use `create(EventRecordsSchema)` to create a new message.
 */
export const EventRecordsSchema: GenMessage<EventRecords, {jsonType: EventRecordsJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 24);

/**
 * Defines a single event reported by a device.
 *
 * @generated from message io.clbs.openhes.models.acquisition.EventRecord
 */
export type EventRecord = Message<"io.clbs.openhes.models.acquisition.EventRecord"> & {
  /**
   * The timestamp of the event.
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: Timestamp;

  /**
   * The identifier of the event.
   *
   * @generated from field: int64 event_id = 2;
   */
  eventId: bigint;

  /**
   * The event code generated by the device.
   *
   * @generated from field: int64 event_code = 3;
   */
  eventCode: bigint;

  /**
   * The source of the event.
   *
   * @generated from field: string event_source = 5;
   */
  eventSource: string;

  /**
   * The descriptive text of the event.
   *
   * @generated from field: string event_text = 4;
   */
  eventText: string;
};

/**
 * Defines a single event reported by a device.
 *
 * @generated from message io.clbs.openhes.models.acquisition.EventRecord
 */
export type EventRecordJson = {
  /**
   * The timestamp of the event.
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: TimestampJson;

  /**
   * The identifier of the event.
   *
   * @generated from field: int64 event_id = 2;
   */
  eventId?: string;

  /**
   * The event code generated by the device.
   *
   * @generated from field: int64 event_code = 3;
   */
  eventCode?: string;

  /**
   * The source of the event.
   *
   * @generated from field: string event_source = 5;
   */
  eventSource?: string;

  /**
   * The descriptive text of the event.
   *
   * @generated from field: string event_text = 4;
   */
  eventText?: string;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.EventRecord.
 * Use `create(EventRecordSchema)` to create a new message.
 */
export const EventRecordSchema: GenMessage<EventRecord, {jsonType: EventRecordJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 25);

/**
 * Defines a single event record associated with the specified device.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DeviceEventRecord
 */
export type DeviceEventRecord = Message<"io.clbs.openhes.models.acquisition.DeviceEventRecord"> & {
  /**
   * The unique device identifier.
   *
   * @generated from field: string device_id = 1;
   */
  deviceId: string;

  /**
   * The timestamp of the event.
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 2;
   */
  timestamp?: Timestamp;

  /**
   * The unique event identifier.
   *
   * @generated from field: int64 event_id = 3;
   */
  eventId: bigint;

  /**
   * The event code generated by the device.
   *
   * @generated from field: int64 event_code = 4;
   */
  eventCode: bigint;

  /**
   * The source of the event.
   *
   * @generated from field: string event_source = 5;
   */
  eventSource: string;

  /**
   * The descriptive text of the event.
   *
   * @generated from field: string event_text = 6;
   */
  eventText: string;
};

/**
 * Defines a single event record associated with the specified device.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DeviceEventRecord
 */
export type DeviceEventRecordJson = {
  /**
   * The unique device identifier.
   *
   * @generated from field: string device_id = 1;
   */
  deviceId?: string;

  /**
   * The timestamp of the event.
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 2;
   */
  timestamp?: TimestampJson;

  /**
   * The unique event identifier.
   *
   * @generated from field: int64 event_id = 3;
   */
  eventId?: string;

  /**
   * The event code generated by the device.
   *
   * @generated from field: int64 event_code = 4;
   */
  eventCode?: string;

  /**
   * The source of the event.
   *
   * @generated from field: string event_source = 5;
   */
  eventSource?: string;

  /**
   * The descriptive text of the event.
   *
   * @generated from field: string event_text = 6;
   */
  eventText?: string;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.DeviceEventRecord.
 * Use `create(DeviceEventRecordSchema)` to create a new message.
 */
export const DeviceEventRecordSchema: GenMessage<DeviceEventRecord, {jsonType: DeviceEventRecordJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 26);

/**
 * Defines a list of device event records.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DeviceEvents
 */
export type DeviceEvents = Message<"io.clbs.openhes.models.acquisition.DeviceEvents"> & {
  /**
   * The list of device event records.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.DeviceEventRecord events = 1;
   */
  events: DeviceEventRecord[];
};

/**
 * Defines a list of device event records.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DeviceEvents
 */
export type DeviceEventsJson = {
  /**
   * The list of device event records.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.DeviceEventRecord events = 1;
   */
  events?: DeviceEventRecordJson[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.DeviceEvents.
 * Use `create(DeviceEventsSchema)` to create a new message.
 */
export const DeviceEventsSchema: GenMessage<DeviceEvents, {jsonType: DeviceEventsJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 27);

/**
 * Defines common device information.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DeviceInfo
 */
export type DeviceInfo = Message<"io.clbs.openhes.models.acquisition.DeviceInfo"> & {
  /**
   * The timestamp when the values were read.
   *
   * @generated from field: google.protobuf.Timestamp info_timestamp = 1;
   */
  infoTimestamp?: Timestamp;

  /**
   * The serial number of the device assigned by the manufacturer. Typical source: `0-0:42.0.0.255`.
   *
   * @generated from field: string manufacturer_serial_number = 2;
   */
  manufacturerSerialNumber: string;

  /**
   * The device serial number.  Typical source: `0-0:96.1.0.255`.
   *
   * @generated from field: string device_serial_number = 3;
   */
  deviceSerialNumber: string;

  /**
   * The device firmware version identifier. Typical source: `0-0:0.2.0.255`.
   *
   * @generated from field: string firmware_version = 4;
   */
  firmwareVersion: string;

  /**
   * The time difference (delta) between the device clock and the acquisition server clock (driver). Positive values mean the device clock is ahead, negative values mean the device clock is behind.
   *
   * @generated from field: google.protobuf.Duration clock_delta = 5;
   */
  clockDelta?: Duration;

  /**
   * The device model.
   *
   * @generated from field: string device_model = 6;
   */
  deviceModel: string;

  /**
   * The error register (register `0`). Typical source: `0-0:97.97.1.255` (higher 32-bit) + `0-0:97.97.0.255` (lower 32-bit).
   *
   * @generated from field: uint64 error_register = 7;
   */
  errorRegister: bigint;

  /**
   * The list of relay states. The order of the relays is the same as in the device. The value is `true` if the relay is connected and `false` if the relay is disconnected.
   *
   * @generated from field: repeated bool relay_states = 8;
   */
  relayStates: boolean[];

  /**
   * The connection (disconnector) state. The value is `true` if the customer is connected and `false` if the customer is disconnected.
   *
   * @generated from field: bool connection_state = 9;
   */
  connectionState: boolean;
};

/**
 * Defines common device information.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DeviceInfo
 */
export type DeviceInfoJson = {
  /**
   * The timestamp when the values were read.
   *
   * @generated from field: google.protobuf.Timestamp info_timestamp = 1;
   */
  infoTimestamp?: TimestampJson;

  /**
   * The serial number of the device assigned by the manufacturer. Typical source: `0-0:42.0.0.255`.
   *
   * @generated from field: string manufacturer_serial_number = 2;
   */
  manufacturerSerialNumber?: string;

  /**
   * The device serial number.  Typical source: `0-0:96.1.0.255`.
   *
   * @generated from field: string device_serial_number = 3;
   */
  deviceSerialNumber?: string;

  /**
   * The device firmware version identifier. Typical source: `0-0:0.2.0.255`.
   *
   * @generated from field: string firmware_version = 4;
   */
  firmwareVersion?: string;

  /**
   * The time difference (delta) between the device clock and the acquisition server clock (driver). Positive values mean the device clock is ahead, negative values mean the device clock is behind.
   *
   * @generated from field: google.protobuf.Duration clock_delta = 5;
   */
  clockDelta?: DurationJson;

  /**
   * The device model.
   *
   * @generated from field: string device_model = 6;
   */
  deviceModel?: string;

  /**
   * The error register (register `0`). Typical source: `0-0:97.97.1.255` (higher 32-bit) + `0-0:97.97.0.255` (lower 32-bit).
   *
   * @generated from field: uint64 error_register = 7;
   */
  errorRegister?: string;

  /**
   * The list of relay states. The order of the relays is the same as in the device. The value is `true` if the relay is connected and `false` if the relay is disconnected.
   *
   * @generated from field: repeated bool relay_states = 8;
   */
  relayStates?: boolean[];

  /**
   * The connection (disconnector) state. The value is `true` if the customer is connected and `false` if the customer is disconnected.
   *
   * @generated from field: bool connection_state = 9;
   */
  connectionState?: boolean;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.DeviceInfo.
 * Use `create(DeviceInfoSchema)` to create a new message.
 */
export const DeviceInfoSchema: GenMessage<DeviceInfo, {jsonType: DeviceInfoJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 28);

/**
 * Defines the profile-type values.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ProfileValues
 */
export type ProfileValues = Message<"io.clbs.openhes.models.acquisition.ProfileValues"> & {
  /**
   * The period of the profile values.
   *
   * @generated from field: google.protobuf.Duration period = 1;
   */
  period?: Duration;

  /**
   * The unit of the profile values.
   *
   * @generated from field: string unit = 2;
   */
  unit: string;

  /**
   * The list of continuous profile blocks.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.ProfileBlock blocks = 3;
   */
  blocks: ProfileBlock[];
};

/**
 * Defines the profile-type values.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ProfileValues
 */
export type ProfileValuesJson = {
  /**
   * The period of the profile values.
   *
   * @generated from field: google.protobuf.Duration period = 1;
   */
  period?: DurationJson;

  /**
   * The unit of the profile values.
   *
   * @generated from field: string unit = 2;
   */
  unit?: string;

  /**
   * The list of continuous profile blocks.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.ProfileBlock blocks = 3;
   */
  blocks?: ProfileBlockJson[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ProfileValues.
 * Use `create(ProfileValuesSchema)` to create a new message.
 */
export const ProfileValuesSchema: GenMessage<ProfileValues, {jsonType: ProfileValuesJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 29);

/**
 * Defines the irregular (non-perioic) profile values.
 *
 * @generated from message io.clbs.openhes.models.acquisition.IrregularProfileValues
 */
export type IrregularProfileValues = Message<"io.clbs.openhes.models.acquisition.IrregularProfileValues"> & {
  /**
   * The unit of the profile values.
   *
   * @generated from field: string unit = 1;
   */
  unit: string;

  /**
   * The list of irregular values.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.IrregularValue values = 2;
   */
  values: IrregularValue[];
};

/**
 * Defines the irregular (non-perioic) profile values.
 *
 * @generated from message io.clbs.openhes.models.acquisition.IrregularProfileValues
 */
export type IrregularProfileValuesJson = {
  /**
   * The unit of the profile values.
   *
   * @generated from field: string unit = 1;
   */
  unit?: string;

  /**
   * The list of irregular values.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.IrregularValue values = 2;
   */
  values?: IrregularValueJson[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.IrregularProfileValues.
 * Use `create(IrregularProfileValuesSchema)` to create a new message.
 */
export const IrregularProfileValuesSchema: GenMessage<IrregularProfileValues, {jsonType: IrregularProfileValuesJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 30);

/**
 * Defines a single irregular (non-periodic) value with a timestamp.
 *
 * @generated from message io.clbs.openhes.models.acquisition.IrregularValue
 */
export type IrregularValue = Message<"io.clbs.openhes.models.acquisition.IrregularValue"> & {
  /**
   * The timestamp of the value.
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: Timestamp;

  /**
   * The value.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.MeasuredValue value = 2;
   */
  value?: MeasuredValue;
};

/**
 * Defines a single irregular (non-periodic) value with a timestamp.
 *
 * @generated from message io.clbs.openhes.models.acquisition.IrregularValue
 */
export type IrregularValueJson = {
  /**
   * The timestamp of the value.
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: TimestampJson;

  /**
   * The value.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.MeasuredValue value = 2;
   */
  value?: MeasuredValueJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.IrregularValue.
 * Use `create(IrregularValueSchema)` to create a new message.
 */
export const IrregularValueSchema: GenMessage<IrregularValue, {jsonType: IrregularValueJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 31);

/**
 * Defines a single profile block containing the measured values.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ProfileBlock
 */
export type ProfileBlock = Message<"io.clbs.openhes.models.acquisition.ProfileBlock"> & {
  /**
   * The start timestamp of the block.
   *
   * @generated from field: google.protobuf.Timestamp start_timestamp = 1;
   */
  startTimestamp?: Timestamp;

  /**
   * The list of profile values, ordered by the timestamp.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.MeasuredValue values = 2;
   */
  values: MeasuredValue[];
};

/**
 * Defines a single profile block containing the measured values.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ProfileBlock
 */
export type ProfileBlockJson = {
  /**
   * The start timestamp of the block.
   *
   * @generated from field: google.protobuf.Timestamp start_timestamp = 1;
   */
  startTimestamp?: TimestampJson;

  /**
   * The list of profile values, ordered by the timestamp.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.MeasuredValue values = 2;
   */
  values?: MeasuredValueJson[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ProfileBlock.
 * Use `create(ProfileBlockSchema)` to create a new message.
 */
export const ProfileBlockSchema: GenMessage<ProfileBlock, {jsonType: ProfileBlockJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 32);

/**
 * Defines the register-type values.
 *
 * @generated from message io.clbs.openhes.models.acquisition.RegisterValues
 */
export type RegisterValues = Message<"io.clbs.openhes.models.acquisition.RegisterValues"> & {
  /**
   * The list of register values.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.RegisterValue values = 1;
   */
  values: RegisterValue[];
};

/**
 * Defines the register-type values.
 *
 * @generated from message io.clbs.openhes.models.acquisition.RegisterValues
 */
export type RegisterValuesJson = {
  /**
   * The list of register values.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.RegisterValue values = 1;
   */
  values?: RegisterValueJson[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.RegisterValues.
 * Use `create(RegisterValuesSchema)` to create a new message.
 */
export const RegisterValuesSchema: GenMessage<RegisterValues, {jsonType: RegisterValuesJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 33);

/**
 * Defines a single register-type value.
 *
 * @generated from message io.clbs.openhes.models.acquisition.RegisterValue
 */
export type RegisterValue = Message<"io.clbs.openhes.models.acquisition.RegisterValue"> & {
  /**
   * The timestamp of the value.
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: Timestamp;

  /**
   * The unit of the value.
   *
   * @generated from field: string unit = 2;
   */
  unit: string;

  /**
   * The value.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.MeasuredValue value = 3;
   */
  value?: MeasuredValue;
};

/**
 * Defines a single register-type value.
 *
 * @generated from message io.clbs.openhes.models.acquisition.RegisterValue
 */
export type RegisterValueJson = {
  /**
   * The timestamp of the value.
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: TimestampJson;

  /**
   * The unit of the value.
   *
   * @generated from field: string unit = 2;
   */
  unit?: string;

  /**
   * The value.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.MeasuredValue value = 3;
   */
  value?: MeasuredValueJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.RegisterValue.
 * Use `create(RegisterValueSchema)` to create a new message.
 */
export const RegisterValueSchema: GenMessage<RegisterValue, {jsonType: RegisterValueJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 34);

/**
 * Defines a measured value.
 *
 * @generated from message io.clbs.openhes.models.acquisition.MeasuredValue
 */
export type MeasuredValue = Message<"io.clbs.openhes.models.acquisition.MeasuredValue"> & {
  /**
   * The status of the value.
   *
   * @generated from field: int64 status = 1;
   */
  status: bigint;

  /**
   * The exponent of the value. Used to calculate the real value as `value * 10^exponent` for double and integer values.
   *
   * @generated from field: int32 exponent = 2;
   */
  exponent: number;

  /**
   * @generated from oneof io.clbs.openhes.models.acquisition.MeasuredValue.kind
   */
  kind: {
    /**
     * The double-typed value.
     *
     * @generated from field: double double_value = 3;
     */
    value: number;
    case: "doubleValue";
  } | {
    /**
     * The integer-typed value.
     *
     * @generated from field: int64 integer_value = 4;
     */
    value: bigint;
    case: "integerValue";
  } | {
    /**
     * The string-typed value.
     *
     * @generated from field: string string_value = 5;
     */
    value: string;
    case: "stringValue";
  } | {
    /**
     * The timestamp-typed value.
     *
     * @generated from field: google.protobuf.Timestamp timestamp_value = 6;
     */
    value: Timestamp;
    case: "timestampValue";
  } | {
    /**
     * The timestamp with timezone-typed value, stored as an ISO-8601 string.
     *
     * @generated from field: string timestamp_tz_value = 7;
     */
    value: string;
    case: "timestampTzValue";
  } | {
    /**
     * The boolean-typed value.
     *
     * @generated from field: bool bool_value = 8;
     */
    value: boolean;
    case: "boolValue";
  } | { case: undefined; value?: undefined };

  /**
   * The normalized status of the value. See `StatusBits` enum for details.
   *
   * @generated from field: uint64 nstatus = 9;
   */
  nstatus: bigint;

  /**
   * The timestamp when the value (for example, peak) was recorded. Typically before the capture timestamp.
   *
   * @generated from field: google.protobuf.Timestamp peak_ts = 10;
   */
  peakTs?: Timestamp;
};

/**
 * Defines a measured value.
 *
 * @generated from message io.clbs.openhes.models.acquisition.MeasuredValue
 */
export type MeasuredValueJson = {
  /**
   * The status of the value.
   *
   * @generated from field: int64 status = 1;
   */
  status?: string;

  /**
   * The exponent of the value. Used to calculate the real value as `value * 10^exponent` for double and integer values.
   *
   * @generated from field: int32 exponent = 2;
   */
  exponent?: number;

  /**
   * The double-typed value.
   *
   * @generated from field: double double_value = 3;
   */
  doubleValue?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * The integer-typed value.
   *
   * @generated from field: int64 integer_value = 4;
   */
  integerValue?: string;

  /**
   * The string-typed value.
   *
   * @generated from field: string string_value = 5;
   */
  stringValue?: string;

  /**
   * The timestamp-typed value.
   *
   * @generated from field: google.protobuf.Timestamp timestamp_value = 6;
   */
  timestampValue?: TimestampJson;

  /**
   * The timestamp with timezone-typed value, stored as an ISO-8601 string.
   *
   * @generated from field: string timestamp_tz_value = 7;
   */
  timestampTzValue?: string;

  /**
   * The boolean-typed value.
   *
   * @generated from field: bool bool_value = 8;
   */
  boolValue?: boolean;

  /**
   * The normalized status of the value. See `StatusBits` enum for details.
   *
   * @generated from field: uint64 nstatus = 9;
   */
  nstatus?: string;

  /**
   * The timestamp when the value (for example, peak) was recorded. Typically before the capture timestamp.
   *
   * @generated from field: google.protobuf.Timestamp peak_ts = 10;
   */
  peakTs?: TimestampJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.MeasuredValue.
 * Use `create(MeasuredValueSchema)` to create a new message.
 */
export const MeasuredValueSchema: GenMessage<MeasuredValue, {jsonType: MeasuredValueJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 35);

/**
 * Defines the template for job action attributes.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobActionAttributes
 */
export type JobActionAttributes = Message<"io.clbs.openhes.models.acquisition.JobActionAttributes"> & {
  /**
   * The type of action for which this template template is defined.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionType type = 1;
   */
  type: ActionType;

  /**
   * TThe list attribute definitions for the action attributes template.
   *
   * @generated from field: repeated io.clbs.openhes.models.common.FieldDescriptor attributes = 2;
   */
  attributes: FieldDescriptor[];
};

/**
 * Defines the template for job action attributes.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobActionAttributes
 */
export type JobActionAttributesJson = {
  /**
   * The type of action for which this template template is defined.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionType type = 1;
   */
  type?: ActionTypeJson;

  /**
   * TThe list attribute definitions for the action attributes template.
   *
   * @generated from field: repeated io.clbs.openhes.models.common.FieldDescriptor attributes = 2;
   */
  attributes?: FieldDescriptorJson[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.JobActionAttributes.
 * Use `create(JobActionAttributesSchema)` to create a new message.
 */
export const JobActionAttributesSchema: GenMessage<JobActionAttributes, {jsonType: JobActionAttributesJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 36);

/**
 * Defines the connection infoformation for a controlled serial line over IP (for example, Moxa).
 *
 * @generated from message io.clbs.openhes.models.acquisition.ConnectionTypeControlledSerial
 */
export type ConnectionTypeControlledSerial = Message<"io.clbs.openhes.models.acquisition.ConnectionTypeControlledSerial"> & {
  /**
   * IP-to-serial converter description.
   *
   * @generated from oneof io.clbs.openhes.models.acquisition.ConnectionTypeControlledSerial.converter
   */
  converter: {
    /**
     * The simple direct serial connection type.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ConnectionTypeSerialDirect direct = 1;
     */
    value: ConnectionTypeSerialDirect;
    case: "direct";
  } | {
    /**
     * The Moxa connection type.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ConnectionTypeSerialMoxa moxa = 2;
     */
    value: ConnectionTypeSerialMoxa;
    case: "moxa";
  } | {
    /**
     * The RFC 2217 connection type.
     *
     * @generated from field: io.clbs.openhes.models.acquisition.ConnectionTypeSerialRfc2217 rfc2217 = 3;
     */
    value: ConnectionTypeSerialRfc2217;
    case: "rfc2217";
  } | { case: undefined; value?: undefined };

  /**
   * The serial port configuration.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.SerialConfig config = 4;
   */
  config?: SerialConfig;
};

/**
 * Defines the connection infoformation for a controlled serial line over IP (for example, Moxa).
 *
 * @generated from message io.clbs.openhes.models.acquisition.ConnectionTypeControlledSerial
 */
export type ConnectionTypeControlledSerialJson = {
  /**
   * The simple direct serial connection type.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ConnectionTypeSerialDirect direct = 1;
   */
  direct?: ConnectionTypeSerialDirectJson;

  /**
   * The Moxa connection type.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ConnectionTypeSerialMoxa moxa = 2;
   */
  moxa?: ConnectionTypeSerialMoxaJson;

  /**
   * The RFC 2217 connection type.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ConnectionTypeSerialRfc2217 rfc2217 = 3;
   */
  rfc2217?: ConnectionTypeSerialRfc2217Json;

  /**
   * The serial port configuration.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.SerialConfig config = 4;
   */
  config?: SerialConfigJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ConnectionTypeControlledSerial.
 * Use `create(ConnectionTypeControlledSerialSchema)` to create a new message.
 */
export const ConnectionTypeControlledSerialSchema: GenMessage<ConnectionTypeControlledSerial, {jsonType: ConnectionTypeControlledSerialJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 37);

/**
 * Defines the get register action specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionGetRegister
 */
export type ActionGetRegister = Message<"io.clbs.openhes.models.acquisition.ActionGetRegister"> & {
  /**
   * The data type of the target register, for example `integer`, `double`, `string`, `timestamp`. For proxy bulks, this value can be explicitely specified. For regular bulks, it is automatically taken from the register definition in the system.
   *
   * @generated from field: io.clbs.openhes.models.common.FieldDataType data_type = 1;
   */
  dataType: FieldDataType;
};

/**
 * Defines the get register action specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionGetRegister
 */
export type ActionGetRegisterJson = {
  /**
   * The data type of the target register, for example `integer`, `double`, `string`, `timestamp`. For proxy bulks, this value can be explicitely specified. For regular bulks, it is automatically taken from the register definition in the system.
   *
   * @generated from field: io.clbs.openhes.models.common.FieldDataType data_type = 1;
   */
  dataType?: FieldDataTypeJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionGetRegister.
 * Use `create(ActionGetRegisterSchema)` to create a new message.
 */
export const ActionGetRegisterSchema: GenMessage<ActionGetRegister, {jsonType: ActionGetRegisterJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 38);

/**
 * Defines the get periodical profile action specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionGetPeriodicalProfile
 */
export type ActionGetPeriodicalProfile = Message<"io.clbs.openhes.models.acquisition.ActionGetPeriodicalProfile"> & {
  /**
   * The start timestamp of the profile readout.
   *
   * @generated from field: google.protobuf.Timestamp range_start = 1;
   */
  rangeStart?: Timestamp;

  /**
   * The end timestamp of the profile readout.
   *
   * @generated from field: google.protobuf.Timestamp range_end = 2;
   */
  rangeEnd?: Timestamp;

  /**
   * The data type of the target register, for example `integer`, `double`, `string`, `timestamp`. For proxy bulks, this value can be explicitely specified. For regular bulks, it is automatically taken from the register definition in the system.
   *
   * @generated from field: io.clbs.openhes.models.common.FieldDataType data_type = 3;
   */
  dataType: FieldDataType;
};

/**
 * Defines the get periodical profile action specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionGetPeriodicalProfile
 */
export type ActionGetPeriodicalProfileJson = {
  /**
   * The start timestamp of the profile readout.
   *
   * @generated from field: google.protobuf.Timestamp range_start = 1;
   */
  rangeStart?: TimestampJson;

  /**
   * The end timestamp of the profile readout.
   *
   * @generated from field: google.protobuf.Timestamp range_end = 2;
   */
  rangeEnd?: TimestampJson;

  /**
   * The data type of the target register, for example `integer`, `double`, `string`, `timestamp`. For proxy bulks, this value can be explicitely specified. For regular bulks, it is automatically taken from the register definition in the system.
   *
   * @generated from field: io.clbs.openhes.models.common.FieldDataType data_type = 3;
   */
  dataType?: FieldDataTypeJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionGetPeriodicalProfile.
 * Use `create(ActionGetPeriodicalProfileSchema)` to create a new message.
 */
export const ActionGetPeriodicalProfileSchema: GenMessage<ActionGetPeriodicalProfile, {jsonType: ActionGetPeriodicalProfileJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 39);

/**
 * Defines the get irregular profile action.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionGetIrregularProfile
 */
export type ActionGetIrregularProfile = Message<"io.clbs.openhes.models.acquisition.ActionGetIrregularProfile"> & {
  /**
   * The start timestamp of the profile readout.
   *
   * @generated from field: google.protobuf.Timestamp range_start = 1;
   */
  rangeStart?: Timestamp;

  /**
   * The end timestamp of the profile readout.
   *
   * @generated from field: google.protobuf.Timestamp range_end = 2;
   */
  rangeEnd?: Timestamp;

  /**
   * The data type of the target register, for example `integer`, `double`, `string`, `timestamp`. For proxy bulks, this value can be explicitely specified. For regular bulks, it is automatically taken from the register definition in the system.
   *
   * @generated from field: io.clbs.openhes.models.common.FieldDataType data_type = 3;
   */
  dataType: FieldDataType;
};

/**
 * Defines the get irregular profile action.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionGetIrregularProfile
 */
export type ActionGetIrregularProfileJson = {
  /**
   * The start timestamp of the profile readout.
   *
   * @generated from field: google.protobuf.Timestamp range_start = 1;
   */
  rangeStart?: TimestampJson;

  /**
   * The end timestamp of the profile readout.
   *
   * @generated from field: google.protobuf.Timestamp range_end = 2;
   */
  rangeEnd?: TimestampJson;

  /**
   * The data type of the target register, for example `integer`, `double`, `string`, `timestamp`. For proxy bulks, this value can be explicitely specified. For regular bulks, it is automatically taken from the register definition in the system.
   *
   * @generated from field: io.clbs.openhes.models.common.FieldDataType data_type = 3;
   */
  dataType?: FieldDataTypeJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionGetIrregularProfile.
 * Use `create(ActionGetIrregularProfileSchema)` to create a new message.
 */
export const ActionGetIrregularProfileSchema: GenMessage<ActionGetIrregularProfile, {jsonType: ActionGetIrregularProfileJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 40);

/**
 * Defines the get events action specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionGetEvents
 */
export type ActionGetEvents = Message<"io.clbs.openhes.models.acquisition.ActionGetEvents"> & {
  /**
   * The start timestamp of the event readout.
   *
   * @generated from field: google.protobuf.Timestamp range_start = 1;
   */
  rangeStart?: Timestamp;

  /**
   * The end timestamp of the event readout.
   *
   * @generated from field: google.protobuf.Timestamp range_end = 2;
   */
  rangeEnd?: Timestamp;
};

/**
 * Defines the get events action specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionGetEvents
 */
export type ActionGetEventsJson = {
  /**
   * The start timestamp of the event readout.
   *
   * @generated from field: google.protobuf.Timestamp range_start = 1;
   */
  rangeStart?: TimestampJson;

  /**
   * The end timestamp of the event readout.
   *
   * @generated from field: google.protobuf.Timestamp range_end = 2;
   */
  rangeEnd?: TimestampJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionGetEvents.
 * Use `create(ActionGetEventsSchema)` to create a new message.
 */
export const ActionGetEventsSchema: GenMessage<ActionGetEvents, {jsonType: ActionGetEventsJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 41);

/**
 * Defines the get device info action specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionGetDeviceInfo
 */
export type ActionGetDeviceInfo = Message<"io.clbs.openhes.models.acquisition.ActionGetDeviceInfo"> & {
};

/**
 * Defines the get device info action specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionGetDeviceInfo
 */
export type ActionGetDeviceInfoJson = {
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionGetDeviceInfo.
 * Use `create(ActionGetDeviceInfoSchema)` to create a new message.
 */
export const ActionGetDeviceInfoSchema: GenMessage<ActionGetDeviceInfo, {jsonType: ActionGetDeviceInfoJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 42);

/**
 * Defines the sync clock action specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionSyncClock
 */
export type ActionSyncClock = Message<"io.clbs.openhes.models.acquisition.ActionSyncClock"> & {
};

/**
 * Defines the sync clock action specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionSyncClock
 */
export type ActionSyncClockJson = {
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionSyncClock.
 * Use `create(ActionSyncClockSchema)` to create a new message.
 */
export const ActionSyncClockSchema: GenMessage<ActionSyncClock, {jsonType: ActionSyncClockJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 43);

/**
 * Defines the set relay state action specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionSetRelayState
 */
export type ActionSetRelayState = Message<"io.clbs.openhes.models.acquisition.ActionSetRelayState"> & {
};

/**
 * Defines the set relay state action specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionSetRelayState
 */
export type ActionSetRelayStateJson = {
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionSetRelayState.
 * Use `create(ActionSetRelayStateSchema)` to create a new message.
 */
export const ActionSetRelayStateSchema: GenMessage<ActionSetRelayState, {jsonType: ActionSetRelayStateJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 44);

/**
 * Defines the set disconnector state action specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionSetDisconnectorState
 */
export type ActionSetDisconnectorState = Message<"io.clbs.openhes.models.acquisition.ActionSetDisconnectorState"> & {
};

/**
 * Defines the set disconnector state action specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionSetDisconnectorState
 */
export type ActionSetDisconnectorStateJson = {
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionSetDisconnectorState.
 * Use `create(ActionSetDisconnectorStateSchema)` to create a new message.
 */
export const ActionSetDisconnectorStateSchema: GenMessage<ActionSetDisconnectorState, {jsonType: ActionSetDisconnectorStateJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 45);

/**
 * Defines the get TOU action specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionGetTou
 */
export type ActionGetTou = Message<"io.clbs.openhes.models.acquisition.ActionGetTou"> & {
  /**
   * Specifies whether to read the passive TOU table. By default, it is set to `false`, meaning the active TOU table is read.
   *
   * @generated from field: bool passive = 1;
   */
  passive: boolean;
};

/**
 * Defines the get TOU action specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionGetTou
 */
export type ActionGetTouJson = {
  /**
   * Specifies whether to read the passive TOU table. By default, it is set to `false`, meaning the active TOU table is read.
   *
   * @generated from field: bool passive = 1;
   */
  passive?: boolean;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionGetTou.
 * Use `create(ActionGetTouSchema)` to create a new message.
 */
export const ActionGetTouSchema: GenMessage<ActionGetTou, {jsonType: ActionGetTouJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 46);

/**
 * Defines the set TOU action specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionSetTou
 */
export type ActionSetTou = Message<"io.clbs.openhes.models.acquisition.ActionSetTou"> & {
  /**
   * The TOU table to be set.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.timeofuse.TimeOfUseTableSpec table = 1;
   */
  table?: TimeOfUseTableSpec;
};

/**
 * Defines the set TOU action specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionSetTou
 */
export type ActionSetTouJson = {
  /**
   * The TOU table to be set.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.timeofuse.TimeOfUseTableSpec table = 1;
   */
  table?: TimeOfUseTableSpecJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionSetTou.
 * Use `create(ActionSetTouSchema)` to create a new message.
 */
export const ActionSetTouSchema: GenMessage<ActionSetTou, {jsonType: ActionSetTouJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 47);

/**
 * Defines the set limiter action specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionSetLimiter
 */
export type ActionSetLimiter = Message<"io.clbs.openhes.models.acquisition.ActionSetLimiter"> & {
};

/**
 * Defines the set limiter action specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionSetLimiter
 */
export type ActionSetLimiterJson = {
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionSetLimiter.
 * Use `create(ActionSetLimiterSchema)` to create a new message.
 */
export const ActionSetLimiterSchema: GenMessage<ActionSetLimiter, {jsonType: ActionSetLimiterJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 48);

/**
 * Defines the reset billing period action specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionResetBillingPeriod
 */
export type ActionResetBillingPeriod = Message<"io.clbs.openhes.models.acquisition.ActionResetBillingPeriod"> & {
};

/**
 * Defines the reset billing period action specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionResetBillingPeriod
 */
export type ActionResetBillingPeriodJson = {
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionResetBillingPeriod.
 * Use `create(ActionResetBillingPeriodSchema)` to create a new message.
 */
export const ActionResetBillingPeriodSchema: GenMessage<ActionResetBillingPeriod, {jsonType: ActionResetBillingPeriodJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 49);

/**
 * Defines the firmware update action specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionFwUpdate
 */
export type ActionFwUpdate = Message<"io.clbs.openhes.models.acquisition.ActionFwUpdate"> & {
};

/**
 * Defines the firmware update action specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionFwUpdate
 */
export type ActionFwUpdateJson = {
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionFwUpdate.
 * Use `create(ActionFwUpdateSchema)` to create a new message.
 */
export const ActionFwUpdateSchema: GenMessage<ActionFwUpdate, {jsonType: ActionFwUpdateJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 50);

/**
 * Defines the constraints for job actions.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobActionContraints
 */
export type JobActionContraints = Message<"io.clbs.openhes.models.acquisition.JobActionContraints"> & {
  /**
   * Contains all register types and their names in English.
   * Example: [gen]="Generic Register", [vqi]="Quality VQI Register"
   * Action: ACTION_TYPE_GET_REGISTER
   *
   * @generated from field: map<string, string> get_register_type_name = 1;
   */
  getRegisterTypeName: { [key: string]: string };

  /**
   * Contains all register types and their attributes.
   * Example: [gen]=["attribute1", "attribute2"], [vqi]=["attribute1", "attribute3"]
   * See `JobActionAttributes` for the attribute definitions.
   * Action: ACTION_TYPE_GET_REGISTER
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.ListOfString> get_register_type_attributes = 2;
   */
  getRegisterTypeAttributes: { [key: string]: ListOfString };
};

/**
 * Defines the constraints for job actions.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobActionContraints
 */
export type JobActionContraintsJson = {
  /**
   * Contains all register types and their names in English.
   * Example: [gen]="Generic Register", [vqi]="Quality VQI Register"
   * Action: ACTION_TYPE_GET_REGISTER
   *
   * @generated from field: map<string, string> get_register_type_name = 1;
   */
  getRegisterTypeName?: { [key: string]: string };

  /**
   * Contains all register types and their attributes.
   * Example: [gen]=["attribute1", "attribute2"], [vqi]=["attribute1", "attribute3"]
   * See `JobActionAttributes` for the attribute definitions.
   * Action: ACTION_TYPE_GET_REGISTER
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.ListOfString> get_register_type_attributes = 2;
   */
  getRegisterTypeAttributes?: { [key: string]: ListOfStringJson };
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.JobActionContraints.
 * Use `create(JobActionContraintsSchema)` to create a new message.
 */
export const JobActionContraintsSchema: GenMessage<JobActionContraints, {jsonType: JobActionContraintsJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 51);

/**
 * Defines the status information of a single job within a bulk.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobStatus
 */
export type JobStatus = Message<"io.clbs.openhes.models.acquisition.JobStatus"> & {
  /**
   * The status of the job.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobStatusCode status = 1;
   */
  status: JobStatusCode;

  /**
   * The error code of the job.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobErrorCode code = 2;
   */
  code: JobErrorCode;

  /**
   * The result data for all executed job actions.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.ActionResult results = 3;
   */
  results: ActionResult[];

  /**
   * The start timestamp of the job.
   *
   * @generated from field: google.protobuf.Timestamp started_at = 4;
   */
  startedAt?: Timestamp;

  /**
   * The finish timestamp of the job.
   *
   * @generated from field: google.protobuf.Timestamp finished_at = 5;
   */
  finishedAt?: Timestamp;

  /**
   * The number of attempts already done.
   *
   * @generated from field: int32 attempts_done = 6;
   */
  attemptsDone: number;

  /**
   * The device informatiom from the `ACTION_TYPE_GET_DEVICE_INFO` action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.DeviceInfo device_info = 7;
   */
  deviceInfo?: DeviceInfo;

  /**
   * The internal queue identifier set by the Taskmaster when the job is queued for processing.
   *
   * @generated from field: int64 queue_id = 8;
   */
  queueId: bigint;

  /**
   * The user-facing error message related to the whole job. This is used especially relevant when no action was executed, allowing to log non-action-related errors.
   *
   * @generated from field: io.clbs.openhes.models.common.FormattedMessage error_message = 9;
   */
  errorMessage?: FormattedMessage;
};

/**
 * Defines the status information of a single job within a bulk.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobStatus
 */
export type JobStatusJson = {
  /**
   * The status of the job.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobStatusCode status = 1;
   */
  status?: JobStatusCodeJson;

  /**
   * The error code of the job.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobErrorCode code = 2;
   */
  code?: JobErrorCodeJson;

  /**
   * The result data for all executed job actions.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.ActionResult results = 3;
   */
  results?: ActionResultJson[];

  /**
   * The start timestamp of the job.
   *
   * @generated from field: google.protobuf.Timestamp started_at = 4;
   */
  startedAt?: TimestampJson;

  /**
   * The finish timestamp of the job.
   *
   * @generated from field: google.protobuf.Timestamp finished_at = 5;
   */
  finishedAt?: TimestampJson;

  /**
   * The number of attempts already done.
   *
   * @generated from field: int32 attempts_done = 6;
   */
  attemptsDone?: number;

  /**
   * The device informatiom from the `ACTION_TYPE_GET_DEVICE_INFO` action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.DeviceInfo device_info = 7;
   */
  deviceInfo?: DeviceInfoJson;

  /**
   * The internal queue identifier set by the Taskmaster when the job is queued for processing.
   *
   * @generated from field: int64 queue_id = 8;
   */
  queueId?: string;

  /**
   * The user-facing error message related to the whole job. This is used especially relevant when no action was executed, allowing to log non-action-related errors.
   *
   * @generated from field: io.clbs.openhes.models.common.FormattedMessage error_message = 9;
   */
  errorMessage?: FormattedMessageJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.JobStatus.
 * Use `create(JobStatusSchema)` to create a new message.
 */
export const JobStatusSchema: GenMessage<JobStatus, {jsonType: JobStatusJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 52);

/**
 * Defines the progress status information of a single job within a bulk.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobProgressStatus
 */
export type JobProgressStatus = Message<"io.clbs.openhes.models.acquisition.JobProgressStatus"> & {
  /**
   * The status of the job.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobStatusCode status = 1;
   */
  status: JobStatusCode;

  /**
   * The error code of the job.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobErrorCode code = 2;
   */
  code: JobErrorCode;

  /**
   * The result data for all executed job actions.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.ActionProgressData results = 3;
   */
  results: ActionProgressData[];

  /**
   * The start timestamp of the job.
   *
   * @generated from field: google.protobuf.Timestamp started_at = 4;
   */
  startedAt?: Timestamp;

  /**
   * The finish timestamp of the job.
   *
   * @generated from field: google.protobuf.Timestamp finished_at = 5;
   */
  finishedAt?: Timestamp;

  /**
   * The number of attempts already done.
   *
   * @generated from field: int32 attempts_done = 6;
   */
  attemptsDone: number;

  /**
   * The device informatiom from the `ACTION_TYPE_GET_DEVICE_INFO` action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.DeviceInfo device_info = 7;
   */
  deviceInfo?: DeviceInfo;

  /**
   * The internal queue identifier set by the Taskmaster when the job is queued for processing.
   *
   * @generated from field: int64 queue_id = 8;
   */
  queueId: bigint;

  /**
   * The user-facing error message related to the whole job. This is used especially relevant when no action was executed, allowing to log non-action-related errors.
   *
   * @generated from field: io.clbs.openhes.models.common.FormattedMessage error_message = 9;
   */
  errorMessage?: FormattedMessage;
};

/**
 * Defines the progress status information of a single job within a bulk.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobProgressStatus
 */
export type JobProgressStatusJson = {
  /**
   * The status of the job.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobStatusCode status = 1;
   */
  status?: JobStatusCodeJson;

  /**
   * The error code of the job.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobErrorCode code = 2;
   */
  code?: JobErrorCodeJson;

  /**
   * The result data for all executed job actions.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.ActionProgressData results = 3;
   */
  results?: ActionProgressDataJson[];

  /**
   * The start timestamp of the job.
   *
   * @generated from field: google.protobuf.Timestamp started_at = 4;
   */
  startedAt?: TimestampJson;

  /**
   * The finish timestamp of the job.
   *
   * @generated from field: google.protobuf.Timestamp finished_at = 5;
   */
  finishedAt?: TimestampJson;

  /**
   * The number of attempts already done.
   *
   * @generated from field: int32 attempts_done = 6;
   */
  attemptsDone?: number;

  /**
   * The device informatiom from the `ACTION_TYPE_GET_DEVICE_INFO` action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.DeviceInfo device_info = 7;
   */
  deviceInfo?: DeviceInfoJson;

  /**
   * The internal queue identifier set by the Taskmaster when the job is queued for processing.
   *
   * @generated from field: int64 queue_id = 8;
   */
  queueId?: string;

  /**
   * The user-facing error message related to the whole job. This is used especially relevant when no action was executed, allowing to log non-action-related errors.
   *
   * @generated from field: io.clbs.openhes.models.common.FormattedMessage error_message = 9;
   */
  errorMessage?: FormattedMessageJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.JobProgressStatus.
 * Use `create(JobProgressStatusSchema)` to create a new message.
 */
export const JobProgressStatusSchema: GenMessage<JobProgressStatus, {jsonType: JobProgressStatusJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 53);

/**
 * Defines the job start request for a single device.
 *
 * @generated from message io.clbs.openhes.models.acquisition.StartJobData
 */
export type StartJobData = Message<"io.clbs.openhes.models.acquisition.StartJobData"> & {
  /**
   * The device attributes required by the driver. For example HDLC address, password, and other driver-specific attributes.
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.FieldValue> device_attributes = 1;
   */
  deviceAttributes: { [key: string]: FieldValue };

  /**
   * The unique job identifier.
   *
   * @generated from field: string job_id = 2;
   */
  jobId: string;

  /**
   * The job parameters.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobSettings job_settings = 3;
   */
  jobSettings?: JobSettings;

  /**
   * The list of actions to be executed.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.JobAction job_actions = 4;
   */
  jobActions: JobAction[];

  /**
   * The application protocol used for communication with the device.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ApplicationProtocol app_protocol = 5;
   */
  appProtocol: ApplicationProtocol;

  /**
   * The timezone associated with the device. For example, `"America/New_York"`, `"Europe/Prague"`, `"CET"`, `"GMT"`, `"Etc/GMT+2"`.
   *
   * @generated from field: string timezone = 6;
   */
  timezone: string;
};

/**
 * Defines the job start request for a single device.
 *
 * @generated from message io.clbs.openhes.models.acquisition.StartJobData
 */
export type StartJobDataJson = {
  /**
   * The device attributes required by the driver. For example HDLC address, password, and other driver-specific attributes.
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.FieldValue> device_attributes = 1;
   */
  deviceAttributes?: { [key: string]: FieldValueJson };

  /**
   * The unique job identifier.
   *
   * @generated from field: string job_id = 2;
   */
  jobId?: string;

  /**
   * The job parameters.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobSettings job_settings = 3;
   */
  jobSettings?: JobSettingsJson;

  /**
   * The list of actions to be executed.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.JobAction job_actions = 4;
   */
  jobActions?: JobActionJson[];

  /**
   * The application protocol used for communication with the device.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ApplicationProtocol app_protocol = 5;
   */
  appProtocol?: ApplicationProtocolJson;

  /**
   * The timezone associated with the device. For example, `"America/New_York"`, `"Europe/Prague"`, `"CET"`, `"GMT"`, `"Etc/GMT+2"`.
   *
   * @generated from field: string timezone = 6;
   */
  timezone?: string;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.StartJobData.
 * Use `create(StartJobDataSchema)` to create a new message.
 */
export const StartJobDataSchema: GenMessage<StartJobData, {jsonType: StartJobDataJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 54);

/**
 * Defines the cancel job request message sent from the Taskmaster to the driver.
 *
 * @generated from message io.clbs.openhes.models.acquisition.CancelJobRequest
 */
export type CancelJobRequest = Message<"io.clbs.openhes.models.acquisition.CancelJobRequest"> & {
  /**
   * The unique job identifier.
   *
   * @generated from field: string job_id = 1;
   */
  jobId: string;
};

/**
 * Defines the cancel job request message sent from the Taskmaster to the driver.
 *
 * @generated from message io.clbs.openhes.models.acquisition.CancelJobRequest
 */
export type CancelJobRequestJson = {
  /**
   * The unique job identifier.
   *
   * @generated from field: string job_id = 1;
   */
  jobId?: string;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.CancelJobRequest.
 * Use `create(CancelJobRequestSchema)` to create a new message.
 */
export const CancelJobRequestSchema: GenMessage<CancelJobRequest, {jsonType: CancelJobRequestJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 55);

/**
 * Defines the configuration of a register for a device.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DeviceConfigurationRegisterSpec
 */
export type DeviceConfigurationRegisterSpec = Message<"io.clbs.openhes.models.acquisition.DeviceConfigurationRegisterSpec"> & {
  /**
   * The device (driver) type.
   *
   * @generated from field: string driver_type = 1;
   */
  driverType: string;

  /**
   * The kind of device configuration register.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.DeviceConfigurationRegisterKind register_type = 2;
   */
  registerType: DeviceConfigurationRegisterKind;

  /**
   * The field values assigned to the register.
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.FieldValue> attributes = 3;
   */
  attributes: { [key: string]: FieldValue };

  /**
   * The data type of the register;
   *
   * @generated from field: io.clbs.openhes.models.common.FieldDataType data_type = 4;
   */
  dataType: FieldDataType;
};

/**
 * Defines the configuration of a register for a device.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DeviceConfigurationRegisterSpec
 */
export type DeviceConfigurationRegisterSpecJson = {
  /**
   * The device (driver) type.
   *
   * @generated from field: string driver_type = 1;
   */
  driverType?: string;

  /**
   * The kind of device configuration register.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.DeviceConfigurationRegisterKind register_type = 2;
   */
  registerType?: DeviceConfigurationRegisterKindJson;

  /**
   * The field values assigned to the register.
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.FieldValue> attributes = 3;
   */
  attributes?: { [key: string]: FieldValueJson };

  /**
   * The data type of the register;
   *
   * @generated from field: io.clbs.openhes.models.common.FieldDataType data_type = 4;
   */
  dataType?: FieldDataTypeJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.DeviceConfigurationRegisterSpec.
 * Use `create(DeviceConfigurationRegisterSpecSchema)` to create a new message.
 */
export const DeviceConfigurationRegisterSpecSchema: GenMessage<DeviceConfigurationRegisterSpec, {jsonType: DeviceConfigurationRegisterSpecJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 56);

/**
 * [ADDON] Defines the device register specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DeviceRegister
 */
export type DeviceRegister = Message<"io.clbs.openhes.models.acquisition.DeviceRegister"> & {
  /**
   * The unique register identifier.
   *
   * @generated from field: int64 register_id = 1;
   */
  registerId: bigint;

  /**
   * The public register identifier.
   *
   * @generated from field: string public_register_id = 2;
   */
  publicRegisterId: string;

  /**
   * The register specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.DeviceConfigurationRegisterSpec spec = 3;
   */
  spec?: DeviceConfigurationRegisterSpec;

  /**
   * The list of variable names if the register is assigned to any.
   *
   * @generated from field: repeated string variable_name = 4;
   */
  variableName: string[];
};

/**
 * [ADDON] Defines the device register specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DeviceRegister
 */
export type DeviceRegisterJson = {
  /**
   * The unique register identifier.
   *
   * @generated from field: int64 register_id = 1;
   */
  registerId?: string;

  /**
   * The public register identifier.
   *
   * @generated from field: string public_register_id = 2;
   */
  publicRegisterId?: string;

  /**
   * The register specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.DeviceConfigurationRegisterSpec spec = 3;
   */
  spec?: DeviceConfigurationRegisterSpecJson;

  /**
   * The list of variable names if the register is assigned to any.
   *
   * @generated from field: repeated string variable_name = 4;
   */
  variableName?: string[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.DeviceRegister.
 * Use `create(DeviceRegisterSchema)` to create a new message.
 */
export const DeviceRegisterSchema: GenMessage<DeviceRegister, {jsonType: DeviceRegisterJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 57);

/**
 * [ADDON] Defines the device connection information.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DeviceConnectionInfo
 */
export type DeviceConnectionInfo = Message<"io.clbs.openhes.models.acquisition.DeviceConnectionInfo"> & {
  /**
   * The unique communication unit identifier.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ConnectionInfo communication_unit = 1;
   */
  communicationUnit?: ConnectionInfo;

  /**
   * The application protocol to be used for communication over the communication unit.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ApplicationProtocol app_protocol = 2;
   */
  appProtocol: ApplicationProtocol;

  /**
   * The device attributes. For example HDLC address, password, and other driver-specific attributes.
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.FieldValue> device_attributes = 3;
   */
  deviceAttributes: { [key: string]: FieldValue };

  /**
   * The timezone associated with the device. For example, `"America/New_York"`, `"Europe/Prague"`, `"CET"`, `"GMT"`, `"Etc/GMT+2"`.
   *
   * @generated from field: string timezone = 4;
   */
  timezone: string;

  /**
   * The driver type identifier.
   *
   * @generated from field: string driver_type = 5;
   */
  driverType: string;

  /**
   * The driver version.
   *
   * @generated from field: string driver_version = 7;
   */
  driverVersion: string;

  /**
   * The list of registers defined for device according to its configuration template.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.DeviceRegister registers = 8;
   */
  registers: DeviceRegister[];
};

/**
 * [ADDON] Defines the device connection information.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DeviceConnectionInfo
 */
export type DeviceConnectionInfoJson = {
  /**
   * The unique communication unit identifier.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ConnectionInfo communication_unit = 1;
   */
  communicationUnit?: ConnectionInfoJson;

  /**
   * The application protocol to be used for communication over the communication unit.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ApplicationProtocol app_protocol = 2;
   */
  appProtocol?: ApplicationProtocolJson;

  /**
   * The device attributes. For example HDLC address, password, and other driver-specific attributes.
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.FieldValue> device_attributes = 3;
   */
  deviceAttributes?: { [key: string]: FieldValueJson };

  /**
   * The timezone associated with the device. For example, `"America/New_York"`, `"Europe/Prague"`, `"CET"`, `"GMT"`, `"Etc/GMT+2"`.
   *
   * @generated from field: string timezone = 4;
   */
  timezone?: string;

  /**
   * The driver type identifier.
   *
   * @generated from field: string driver_type = 5;
   */
  driverType?: string;

  /**
   * The driver version.
   *
   * @generated from field: string driver_version = 7;
   */
  driverVersion?: string;

  /**
   * The list of registers defined for device according to its configuration template.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.DeviceRegister registers = 8;
   */
  registers?: DeviceRegisterJson[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.DeviceConnectionInfo.
 * Use `create(DeviceConnectionInfoSchema)` to create a new message.
 */
export const DeviceConnectionInfoSchema: GenMessage<DeviceConnectionInfo, {jsonType: DeviceConnectionInfoJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 58);

/**
 * [ADDON for DB] Defines a list of modem information.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ListOfModemInfo
 */
export type ListOfModemInfo = Message<"io.clbs.openhes.models.acquisition.ListOfModemInfo"> & {
  /**
   * The list of modem information records.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.ModemInfo items = 1;
   */
  items: ModemInfo[];

  /**
   * The total number of items in the list.
   *
   * @generated from field: int32 total_count = 2;
   */
  totalCount: number;
};

/**
 * [ADDON for DB] Defines a list of modem information.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ListOfModemInfo
 */
export type ListOfModemInfoJson = {
  /**
   * The list of modem information records.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.ModemInfo items = 1;
   */
  items?: ModemInfoJson[];

  /**
   * The total number of items in the list.
   *
   * @generated from field: int32 total_count = 2;
   */
  totalCount?: number;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ListOfModemInfo.
 * Use `create(ListOfModemInfoSchema)` to create a new message.
 */
export const ListOfModemInfoSchema: GenMessage<ListOfModemInfo, {jsonType: ListOfModemInfoJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 59);

/**
 * [ADDON for DB] Defines a list of device connection information records.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ListOfConnectionInfo
 */
export type ListOfConnectionInfo = Message<"io.clbs.openhes.models.acquisition.ListOfConnectionInfo"> & {
  /**
   * The list of device connection information records.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.DeviceConnectionInfo items = 1;
   */
  items: DeviceConnectionInfo[];

  /**
   * The total number of items in the list.
   *
   * @generated from field: int32 total_count = 2;
   */
  totalCount: number;
};

/**
 * [ADDON for DB] Defines a list of device connection information records.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ListOfConnectionInfo
 */
export type ListOfConnectionInfoJson = {
  /**
   * The list of device connection information records.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.DeviceConnectionInfo items = 1;
   */
  items?: DeviceConnectionInfoJson[];

  /**
   * The total number of items in the list.
   *
   * @generated from field: int32 total_count = 2;
   */
  totalCount?: number;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ListOfConnectionInfo.
 * Use `create(ListOfConnectionInfoSchema)` to create a new message.
 */
export const ListOfConnectionInfoSchema: GenMessage<ListOfConnectionInfo, {jsonType: ListOfConnectionInfoJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 60);

/**
 * [ADDON for DB] The list of field values.
 *
 * @generated from message io.clbs.openhes.models.acquisition.FieldValuesList
 */
export type FieldValuesList = Message<"io.clbs.openhes.models.acquisition.FieldValuesList"> & {
  /**
   * The list of field values.
   *
   * @generated from field: repeated io.clbs.openhes.models.common.FieldValues items = 1;
   */
  items: FieldValues[];
};

/**
 * [ADDON for DB] The list of field values.
 *
 * @generated from message io.clbs.openhes.models.acquisition.FieldValuesList
 */
export type FieldValuesListJson = {
  /**
   * The list of field values.
   *
   * @generated from field: repeated io.clbs.openhes.models.common.FieldValues items = 1;
   */
  items?: FieldValuesJson[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.FieldValuesList.
 * Use `create(FieldValuesListSchema)` to create a new message.
 */
export const FieldValuesListSchema: GenMessage<FieldValuesList, {jsonType: FieldValuesListJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 61);

/**
 * Defines a generic attribute selector using field values.
 *
 * @generated from message io.clbs.openhes.models.acquisition.AttributeSelector
 */
export type AttributeSelector = Message<"io.clbs.openhes.models.acquisition.AttributeSelector"> & {
  /**
   * The field identifier
   *
   * @generated from field: string field_id = 1;
   */
  fieldId: string;

  /**
   * The filter operator.
   *
   * @generated from field: io.clbs.openhes.models.common.FilterOperator operator = 2;
   */
  operator: FilterOperator;

  /**
   * The data type of the field.
   *
   * @generated from field: io.clbs.openhes.models.common.FieldDataType data_type = 3;
   */
  dataType: FieldDataType;

  /**
   * The text-typed values used for filtering.
   *
   * @generated from field: repeated string text = 4;
   */
  text: string[];

  /**
   * The integer-typed values used for filtering.
   *
   * @generated from field: repeated sint64 integer = 5;
   */
  integer: bigint[];

  /**
   * The number-typed values used for filtering.
   *
   * @generated from field: repeated double number = 6;
   */
  number: number[];

  /**
   * The boolean-typed values used for filtering.
   *
   * @generated from field: repeated bool boolean = 7;
   */
  boolean: boolean[];

  /**
   * The date-typed values used for filtering.
   *
   * @generated from field: repeated google.protobuf.Timestamp date = 8;
   */
  date: Timestamp[];
};

/**
 * Defines a generic attribute selector using field values.
 *
 * @generated from message io.clbs.openhes.models.acquisition.AttributeSelector
 */
export type AttributeSelectorJson = {
  /**
   * The field identifier
   *
   * @generated from field: string field_id = 1;
   */
  fieldId?: string;

  /**
   * The filter operator.
   *
   * @generated from field: io.clbs.openhes.models.common.FilterOperator operator = 2;
   */
  operator?: FilterOperatorJson;

  /**
   * The data type of the field.
   *
   * @generated from field: io.clbs.openhes.models.common.FieldDataType data_type = 3;
   */
  dataType?: FieldDataTypeJson;

  /**
   * The text-typed values used for filtering.
   *
   * @generated from field: repeated string text = 4;
   */
  text?: string[];

  /**
   * The integer-typed values used for filtering.
   *
   * @generated from field: repeated sint64 integer = 5;
   */
  integer?: string[];

  /**
   * The number-typed values used for filtering.
   *
   * @generated from field: repeated double number = 6;
   */
  number?: (number | "NaN" | "Infinity" | "-Infinity")[];

  /**
   * The boolean-typed values used for filtering.
   *
   * @generated from field: repeated bool boolean = 7;
   */
  boolean?: boolean[];

  /**
   * The date-typed values used for filtering.
   *
   * @generated from field: repeated google.protobuf.Timestamp date = 8;
   */
  date?: TimestampJson[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.AttributeSelector.
 * Use `create(AttributeSelectorSchema)` to create a new message.
 */
export const AttributeSelectorSchema: GenMessage<AttributeSelector, {jsonType: AttributeSelectorJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 62);

/**
 * Defines the attribute selector using field values for devices.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DeviceAttributeSelector
 */
export type DeviceAttributeSelector = Message<"io.clbs.openhes.models.acquisition.DeviceAttributeSelector"> & {
  /**
   * The list of field values.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.AttributeSelector attributes = 2;
   */
  attributes: AttributeSelector[];
};

/**
 * Defines the attribute selector using field values for devices.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DeviceAttributeSelector
 */
export type DeviceAttributeSelectorJson = {
  /**
   * The list of field values.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.AttributeSelector attributes = 2;
   */
  attributes?: AttributeSelectorJson[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.DeviceAttributeSelector.
 * Use `create(DeviceAttributeSelectorSchema)` to create a new message.
 */
export const DeviceAttributeSelectorSchema: GenMessage<DeviceAttributeSelector, {jsonType: DeviceAttributeSelectorJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 63);

/**
 * Defines the attribute selector using field values for communication units.
 *
 * @generated from message io.clbs.openhes.models.acquisition.CommunicationUnitAttributeSelector
 */
export type CommunicationUnitAttributeSelector = Message<"io.clbs.openhes.models.acquisition.CommunicationUnitAttributeSelector"> & {
  /**
   * The data link protocol to be used for communication over the communication unit.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.DataLinkProtocol link_protocol = 1;
   */
  linkProtocol: DataLinkProtocol;

  /**
   * The list of field values.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.AttributeSelector attributes = 2;
   */
  attributes: AttributeSelector[];
};

/**
 * Defines the attribute selector using field values for communication units.
 *
 * @generated from message io.clbs.openhes.models.acquisition.CommunicationUnitAttributeSelector
 */
export type CommunicationUnitAttributeSelectorJson = {
  /**
   * The data link protocol to be used for communication over the communication unit.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.DataLinkProtocol link_protocol = 1;
   */
  linkProtocol?: DataLinkProtocolJson;

  /**
   * The list of field values.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.AttributeSelector attributes = 2;
   */
  attributes?: AttributeSelectorJson[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.CommunicationUnitAttributeSelector.
 * Use `create(CommunicationUnitAttributeSelectorSchema)` to create a new message.
 */
export const CommunicationUnitAttributeSelectorSchema: GenMessage<CommunicationUnitAttributeSelector, {jsonType: CommunicationUnitAttributeSelectorJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 64);

/**
 * Defines the result of a single action.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionResult
 */
export type ActionResult = Message<"io.clbs.openhes.models.acquisition.ActionResult"> & {
  /**
   * The unique action identifier.
   *
   * @generated from field: string action_id = 1;
   */
  actionId: string;

  /**
   * The status code of the action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionResultCode status = 2;
   */
  status: ActionResultCode;

  /**
   * The action result data.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionData data = 3;
   */
  data?: ActionData;

  /**
   * The unique register identifier. This is a read-only value and is set only if the action data relats to a register. Applicable only for results of regular bulks.
   *
   * @generated from field: string register_id = 4;
   */
  registerId: string;

  /**
   * The variable names. This is a read-only value and is set only if the action data relates to one or more variables based on device template mapping. Applicable only for results of regular bulks.
   *
   * @generated from field: repeated string variable_name = 5;
   */
  variableName: string[];

  /**
   * The user-facing error message provided when the action ends with `ERROR_CODE_ACTION_ERROR`. The message provides details about the failure, can be multiline, and should be in English.
   *
   * @generated from field: io.clbs.openhes.models.common.FormattedMessage error_message = 6;
   */
  errorMessage?: FormattedMessage;
};

/**
 * Defines the result of a single action.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ActionResult
 */
export type ActionResultJson = {
  /**
   * The unique action identifier.
   *
   * @generated from field: string action_id = 1;
   */
  actionId?: string;

  /**
   * The status code of the action.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionResultCode status = 2;
   */
  status?: ActionResultCodeJson;

  /**
   * The action result data.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ActionData data = 3;
   */
  data?: ActionDataJson;

  /**
   * The unique register identifier. This is a read-only value and is set only if the action data relats to a register. Applicable only for results of regular bulks.
   *
   * @generated from field: string register_id = 4;
   */
  registerId?: string;

  /**
   * The variable names. This is a read-only value and is set only if the action data relates to one or more variables based on device template mapping. Applicable only for results of regular bulks.
   *
   * @generated from field: repeated string variable_name = 5;
   */
  variableName?: string[];

  /**
   * The user-facing error message provided when the action ends with `ERROR_CODE_ACTION_ERROR`. The message provides details about the failure, can be multiline, and should be in English.
   *
   * @generated from field: io.clbs.openhes.models.common.FormattedMessage error_message = 6;
   */
  errorMessage?: FormattedMessageJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ActionResult.
 * Use `create(ActionResultSchema)` to create a new message.
 */
export const ActionResultSchema: GenMessage<ActionResult, {jsonType: ActionResultJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 65);

/**
 * Defines the job or action progress update message sent from Taskmaster to Dataproxy.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobEventData
 */
export type JobEventData = Message<"io.clbs.openhes.models.acquisition.JobEventData"> & {
  /**
   * The unique job identifier.
   *
   * @generated from field: bytes job_id = 1;
   */
  jobId: Uint8Array;
};

/**
 * Defines the job or action progress update message sent from Taskmaster to Dataproxy.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobEventData
 */
export type JobEventDataJson = {
  /**
   * The unique job identifier.
   *
   * @generated from field: bytes job_id = 1;
   */
  jobId?: string;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.JobEventData.
 * Use `create(JobEventDataSchema)` to create a new message.
 */
export const JobEventDataSchema: GenMessage<JobEventData, {jsonType: JobEventDataJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 66);

/**
 * Defines the device specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DeviceSpec
 */
export type DeviceSpec = Message<"io.clbs.openhes.models.acquisition.DeviceSpec"> & {
  /**
   * @gqltype: UUID
   *
   * The unique identifier of the device configuration template.
   *
   * @generated from field: string dct_id = 1;
   */
  dctId: string;

  /**
   * The external identifier of the device.
   *
   * @generated from field: string external_id = 2;
   */
  externalId: string;

  /**
   * The ordered list of communication units (with additional info) linked to the device. The first entry is the primary communication unit with the highest priority.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.DeviceCommunicationUnit communication_unit_link = 3;
   */
  communicationUnitLink: DeviceCommunicationUnit[];

  /**
   * The timezone associated with the device. For example, `"America/New_York"`, `"Europe/Prague"`, `"CET"`, `"GMT"`, `"Etc/GMT+2"`.
   *
   * @generated from field: string timezone = 4;
   */
  timezone: string;

  /**
   * The default communication unit link attributes used when the device is created without a communication unit link. Typically applicable for floating devices that are connected via data concentrators where the related driver dynamically assigns the communication unit. The list must not contain same application protocol more than once.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.DefaultDeviceCommunicationUnitAttributes default_link_attributes = 5;
   */
  defaultLinkAttributes: DefaultDeviceCommunicationUnitAttributes[];
};

/**
 * Defines the device specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DeviceSpec
 */
export type DeviceSpecJson = {
  /**
   * @gqltype: UUID
   *
   * The unique identifier of the device configuration template.
   *
   * @generated from field: string dct_id = 1;
   */
  dctId?: string;

  /**
   * The external identifier of the device.
   *
   * @generated from field: string external_id = 2;
   */
  externalId?: string;

  /**
   * The ordered list of communication units (with additional info) linked to the device. The first entry is the primary communication unit with the highest priority.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.DeviceCommunicationUnit communication_unit_link = 3;
   */
  communicationUnitLink?: DeviceCommunicationUnitJson[];

  /**
   * The timezone associated with the device. For example, `"America/New_York"`, `"Europe/Prague"`, `"CET"`, `"GMT"`, `"Etc/GMT+2"`.
   *
   * @generated from field: string timezone = 4;
   */
  timezone?: string;

  /**
   * The default communication unit link attributes used when the device is created without a communication unit link. Typically applicable for floating devices that are connected via data concentrators where the related driver dynamically assigns the communication unit. The list must not contain same application protocol more than once.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.DefaultDeviceCommunicationUnitAttributes default_link_attributes = 5;
   */
  defaultLinkAttributes?: DefaultDeviceCommunicationUnitAttributesJson[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.DeviceSpec.
 * Use `create(DeviceSpecSchema)` to create a new message.
 */
export const DeviceSpecSchema: GenMessage<DeviceSpec, {jsonType: DeviceSpecJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 67);

/**
 * Defines the current status of a device.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DeviceStatus
 */
export type DeviceStatus = Message<"io.clbs.openhes.models.acquisition.DeviceStatus"> & {
  /**
   * The device information.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.DeviceInfo info = 1;
   */
  info?: DeviceInfo;

  /**
   * The driver type selected according to the device configuration template.
   *
   * @generated from field: string driver_type = 2;
   */
  driverType: string;
};

/**
 * Defines the current status of a device.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DeviceStatus
 */
export type DeviceStatusJson = {
  /**
   * The device information.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.DeviceInfo info = 1;
   */
  info?: DeviceInfoJson;

  /**
   * The driver type selected according to the device configuration template.
   *
   * @generated from field: string driver_type = 2;
   */
  driverType?: string;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.DeviceStatus.
 * Use `create(DeviceStatusSchema)` to create a new message.
 */
export const DeviceStatusSchema: GenMessage<DeviceStatus, {jsonType: DeviceStatusJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 68);

/**
 * Defines the mapping between a device and its communication unit.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DeviceCommunicationUnit
 */
export type DeviceCommunicationUnit = Message<"io.clbs.openhes.models.acquisition.DeviceCommunicationUnit"> & {
  /**
   * The unique identifier of the communication unit.
   *
   * @generated from field: string communication_unit_id = 1;
   */
  communicationUnitId: string;

  /**
   * The application protocol used communication over the communication unit.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ApplicationProtocol app_protocol = 2;
   */
  appProtocol: ApplicationProtocol;

  /**
   * The application protocol related device attributes, represented as a list of attribute definitions.
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.FieldValue> attributes = 3;
   */
  attributes: { [key: string]: FieldValue };
};

/**
 * Defines the mapping between a device and its communication unit.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DeviceCommunicationUnit
 */
export type DeviceCommunicationUnitJson = {
  /**
   * The unique identifier of the communication unit.
   *
   * @generated from field: string communication_unit_id = 1;
   */
  communicationUnitId?: string;

  /**
   * The application protocol used communication over the communication unit.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ApplicationProtocol app_protocol = 2;
   */
  appProtocol?: ApplicationProtocolJson;

  /**
   * The application protocol related device attributes, represented as a list of attribute definitions.
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.FieldValue> attributes = 3;
   */
  attributes?: { [key: string]: FieldValueJson };
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.DeviceCommunicationUnit.
 * Use `create(DeviceCommunicationUnitSchema)` to create a new message.
 */
export const DeviceCommunicationUnitSchema: GenMessage<DeviceCommunicationUnit, {jsonType: DeviceCommunicationUnitJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 69);

/**
 * Defines the default attributes for mapping a device to its communication unit for a specific application protocol.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DefaultDeviceCommunicationUnitAttributes
 */
export type DefaultDeviceCommunicationUnitAttributes = Message<"io.clbs.openhes.models.acquisition.DefaultDeviceCommunicationUnitAttributes"> & {
  /**
   * The application protocol used.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ApplicationProtocol app_protocol = 1;
   */
  appProtocol: ApplicationProtocol;

  /**
   * The protocol-specific device attributes, represented as a list of attribute definitions.
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.FieldValue> attributes = 2;
   */
  attributes: { [key: string]: FieldValue };
};

/**
 * Defines the default attributes for mapping a device to its communication unit for a specific application protocol.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DefaultDeviceCommunicationUnitAttributes
 */
export type DefaultDeviceCommunicationUnitAttributesJson = {
  /**
   * The application protocol used.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ApplicationProtocol app_protocol = 1;
   */
  appProtocol?: ApplicationProtocolJson;

  /**
   * The protocol-specific device attributes, represented as a list of attribute definitions.
   *
   * @generated from field: map<string, io.clbs.openhes.models.common.FieldValue> attributes = 2;
   */
  attributes?: { [key: string]: FieldValueJson };
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.DefaultDeviceCommunicationUnitAttributes.
 * Use `create(DefaultDeviceCommunicationUnitAttributesSchema)` to create a new message.
 */
export const DefaultDeviceCommunicationUnitAttributesSchema: GenMessage<DefaultDeviceCommunicationUnitAttributes, {jsonType: DefaultDeviceCommunicationUnitAttributesJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 70);

/**
 * Defines the job specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobSpec
 */
export type JobSpec = Message<"io.clbs.openhes.models.acquisition.JobSpec"> & {
  /**
   * The device information.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobDevice device = 2;
   */
  device?: JobDevice;

  /**
   * The job parameters.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobSettings job_settings = 3;
   */
  jobSettings?: JobSettings;

  /**
   * The device (driver) type.
   *
   * @generated from field: string driver_type = 4;
   */
  driverType: string;

  /**
   * The list of actions to be executed within the job.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.JobAction job_actions = 5;
   */
  jobActions: JobAction[];

  /**
   * The mapping data for all job actions.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.JobActionMapRecord job_action_info = 6;
   */
  jobActionInfo: JobActionMapRecord[];
};

/**
 * Defines the job specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobSpec
 */
export type JobSpecJson = {
  /**
   * The device information.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobDevice device = 2;
   */
  device?: JobDeviceJson;

  /**
   * The job parameters.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobSettings job_settings = 3;
   */
  jobSettings?: JobSettingsJson;

  /**
   * The device (driver) type.
   *
   * @generated from field: string driver_type = 4;
   */
  driverType?: string;

  /**
   * The list of actions to be executed within the job.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.JobAction job_actions = 5;
   */
  jobActions?: JobActionJson[];

  /**
   * The mapping data for all job actions.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.JobActionMapRecord job_action_info = 6;
   */
  jobActionInfo?: JobActionMapRecordJson[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.JobSpec.
 * Use `create(JobSpecSchema)` to create a new message.
 */
export const JobSpecSchema: GenMessage<JobSpec, {jsonType: JobSpecJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 71);

/**
 * Defines the mapping information for the specified job action.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobActionMapRecord
 */
export type JobActionMapRecord = Message<"io.clbs.openhes.models.acquisition.JobActionMapRecord"> & {
  /**
   * The index of the action in the `job_actions` list.
   *
   * @generated from field: int32 action_index = 1;
   */
  actionIndex: number;

  /**
   * The internal register identifier.
   *
   * @generated from field: int64 register_id = 3;
   */
  registerId: bigint;

  /**
   * The public register identifier.
   *
   * @generated from field: string public_register_id = 2;
   */
  publicRegisterId: string;

  /**
   * The names of variables, if the register is assigned to any.
   *
   * @generated from field: repeated string variable_name = 4;
   */
  variableName: string[];
};

/**
 * Defines the mapping information for the specified job action.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobActionMapRecord
 */
export type JobActionMapRecordJson = {
  /**
   * The index of the action in the `job_actions` list.
   *
   * @generated from field: int32 action_index = 1;
   */
  actionIndex?: number;

  /**
   * The internal register identifier.
   *
   * @generated from field: int64 register_id = 3;
   */
  registerId?: string;

  /**
   * The public register identifier.
   *
   * @generated from field: string public_register_id = 2;
   */
  publicRegisterId?: string;

  /**
   * The names of variables, if the register is assigned to any.
   *
   * @generated from field: repeated string variable_name = 4;
   */
  variableName?: string[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.JobActionMapRecord.
 * Use `create(JobActionMapRecordSchema)` to create a new message.
 */
export const JobActionMapRecordSchema: GenMessage<JobActionMapRecord, {jsonType: JobActionMapRecordJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 72);

/**
 * Defines the notification sent by the Taskmaster to Dataproxy that a job has been completed.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobDoneNotification
 */
export type JobDoneNotification = Message<"io.clbs.openhes.models.acquisition.JobDoneNotification"> & {
  /**
   * The job specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobSpec spec = 1;
   */
  spec?: JobSpec;

  /**
   * The progress status of the job.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobProgressStatus status = 2;
   */
  status?: JobProgressStatus;
};

/**
 * Defines the notification sent by the Taskmaster to Dataproxy that a job has been completed.
 *
 * @generated from message io.clbs.openhes.models.acquisition.JobDoneNotification
 */
export type JobDoneNotificationJson = {
  /**
   * The job specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobSpec spec = 1;
   */
  spec?: JobSpecJson;

  /**
   * The progress status of the job.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.JobProgressStatus status = 2;
   */
  status?: JobProgressStatusJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.JobDoneNotification.
 * Use `create(JobDoneNotificationSchema)` to create a new message.
 */
export const JobDoneNotificationSchema: GenMessage<JobDoneNotification, {jsonType: JobDoneNotificationJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 73);

/**
 * Defines the driver information.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DriverInfo
 */
export type DriverInfo = Message<"io.clbs.openhes.models.acquisition.DriverInfo"> & {
  /**
   * The unique driver identifier.
   *
   * @generated from field: string driver_type = 1;
   */
  driverType: string;

  /**
   * The version of the driver.
   *
   * @generated from field: string version = 2;
   */
  version: string;
};

/**
 * Defines the driver information.
 *
 * @generated from message io.clbs.openhes.models.acquisition.DriverInfo
 */
export type DriverInfoJson = {
  /**
   * The unique driver identifier.
   *
   * @generated from field: string driver_type = 1;
   */
  driverType?: string;

  /**
   * The version of the driver.
   *
   * @generated from field: string version = 2;
   */
  version?: string;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.DriverInfo.
 * Use `create(DriverInfoSchema)` to create a new message.
 */
export const DriverInfoSchema: GenMessage<DriverInfo, {jsonType: DriverInfoJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 74);

/**
 * Defines the communication unit information.
 *
 * @generated from message io.clbs.openhes.models.acquisition.CommunicationUnit
 */
export type CommunicationUnit = Message<"io.clbs.openhes.models.acquisition.CommunicationUnit"> & {
  /**
   * The communication unit specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.CommunicationUnitSpec spec = 1;
   */
  spec?: CommunicationUnitSpec;

  /**
   * The metadata fields.
   *
   * @generated from field: io.clbs.openhes.models.common.MetadataFields metadata = 3;
   */
  metadata?: MetadataFields;
};

/**
 * Defines the communication unit information.
 *
 * @generated from message io.clbs.openhes.models.acquisition.CommunicationUnit
 */
export type CommunicationUnitJson = {
  /**
   * The communication unit specification.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.CommunicationUnitSpec spec = 1;
   */
  spec?: CommunicationUnitSpecJson;

  /**
   * The metadata fields.
   *
   * @generated from field: io.clbs.openhes.models.common.MetadataFields metadata = 3;
   */
  metadata?: MetadataFieldsJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.CommunicationUnit.
 * Use `create(CommunicationUnitSchema)` to create a new message.
 */
export const CommunicationUnitSchema: GenMessage<CommunicationUnit, {jsonType: CommunicationUnitJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 75);

/**
 * Defines the communication unit specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.CommunicationUnitSpec
 */
export type CommunicationUnitSpec = Message<"io.clbs.openhes.models.acquisition.CommunicationUnitSpec"> & {
  /**
   * The external identifier of the communication unit.
   *
   * @generated from field: string external_id = 1;
   */
  externalId: string;

  /**
   * The connection parameters.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ConnectionInfo connection_info = 2;
   */
  connectionInfo?: ConnectionInfo;
};

/**
 * Defines the communication unit specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.CommunicationUnitSpec
 */
export type CommunicationUnitSpecJson = {
  /**
   * The external identifier of the communication unit.
   *
   * @generated from field: string external_id = 1;
   */
  externalId?: string;

  /**
   * The connection parameters.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.ConnectionInfo connection_info = 2;
   */
  connectionInfo?: ConnectionInfoJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.CommunicationUnitSpec.
 * Use `create(CommunicationUnitSpecSchema)` to create a new message.
 */
export const CommunicationUnitSpecSchema: GenMessage<CommunicationUnitSpec, {jsonType: CommunicationUnitSpecJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 76);

/**
 * Defines the the communication bus information.
 *
 * @generated from message io.clbs.openhes.models.acquisition.CommunicationBus
 */
export type CommunicationBus = Message<"io.clbs.openhes.models.acquisition.CommunicationBus"> & {
  /**
   * The communication bus status.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.CommunicationBusStatus status = 2;
   */
  status?: CommunicationBusStatus;

  /**
   * The metadata fields.
   *
   * @generated from field: io.clbs.openhes.models.common.MetadataFields metadata = 3;
   */
  metadata?: MetadataFields;
};

/**
 * Defines the the communication bus information.
 *
 * @generated from message io.clbs.openhes.models.acquisition.CommunicationBus
 */
export type CommunicationBusJson = {
  /**
   * The communication bus status.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.CommunicationBusStatus status = 2;
   */
  status?: CommunicationBusStatusJson;

  /**
   * The metadata fields.
   *
   * @generated from field: io.clbs.openhes.models.common.MetadataFields metadata = 3;
   */
  metadata?: MetadataFieldsJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.CommunicationBus.
 * Use `create(CommunicationBusSchema)` to create a new message.
 */
export const CommunicationBusSchema: GenMessage<CommunicationBus, {jsonType: CommunicationBusJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 77);

/**
 * Defines the communication bus status.
 *
 * @generated from message io.clbs.openhes.models.acquisition.CommunicationBusStatus
 */
export type CommunicationBusStatus = Message<"io.clbs.openhes.models.acquisition.CommunicationBusStatus"> & {
  /**
   * The list of communication unit identifiers connected to the communication bus.
   *
   * @generated from field: repeated string communication_unit_id = 1;
   */
  communicationUnitId: string[];
};

/**
 * Defines the communication bus status.
 *
 * @generated from message io.clbs.openhes.models.acquisition.CommunicationBusStatus
 */
export type CommunicationBusStatusJson = {
  /**
   * The list of communication unit identifiers connected to the communication bus.
   *
   * @generated from field: repeated string communication_unit_id = 1;
   */
  communicationUnitId?: string[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.CommunicationBusStatus.
 * Use `create(CommunicationBusStatusSchema)` to create a new message.
 */
export const CommunicationBusStatusSchema: GenMessage<CommunicationBusStatus, {jsonType: CommunicationBusStatusJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 78);

/**
 * Defines a node in the network topology.
 *
 * @generated from message io.clbs.openhes.models.acquisition.TopologyNode
 */
export type TopologyNode = Message<"io.clbs.openhes.models.acquisition.TopologyNode"> & {
  /**
   * The unique node identifier.
   *
   * @generated from field: int64 x_id = 1;
   */
  xId: bigint;

  /**
   * The type of the node, for example "device", "communication_unit".
   *
   * @generated from field: io.clbs.openhes.models.acquisition.TopologyNodeType type = 2;
   */
  type: TopologyNodeType;

  /**
   * The node attributes.
   *
   * @generated from field: io.clbs.openhes.models.common.FieldValues attributes = 3;
   */
  attributes?: FieldValues;
};

/**
 * Defines a node in the network topology.
 *
 * @generated from message io.clbs.openhes.models.acquisition.TopologyNode
 */
export type TopologyNodeJson = {
  /**
   * The unique node identifier.
   *
   * @generated from field: int64 x_id = 1;
   */
  xId?: string;

  /**
   * The type of the node, for example "device", "communication_unit".
   *
   * @generated from field: io.clbs.openhes.models.acquisition.TopologyNodeType type = 2;
   */
  type?: TopologyNodeTypeJson;

  /**
   * The node attributes.
   *
   * @generated from field: io.clbs.openhes.models.common.FieldValues attributes = 3;
   */
  attributes?: FieldValuesJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.TopologyNode.
 * Use `create(TopologyNodeSchema)` to create a new message.
 */
export const TopologyNodeSchema: GenMessage<TopologyNode, {jsonType: TopologyNodeJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 79);

/**
 * Defines an edge between two nodes in the network topology.
 *
 * @generated from message io.clbs.openhes.models.acquisition.TopologyEdge
 */
export type TopologyEdge = Message<"io.clbs.openhes.models.acquisition.TopologyEdge"> & {
  /**
   * The unique identifier of source edge.
   *
   * @generated from field: int64 from_x_id = 1;
   */
  fromXId: bigint;

  /**
   * The unique identifier of the target edge.
   *
   * @generated from field: int64 to_x_id = 2;
   */
  toXId: bigint;

  /**
   * The edge attributes.
   *
   * @generated from field: io.clbs.openhes.models.common.FieldValues attributes = 3;
   */
  attributes?: FieldValues;
};

/**
 * Defines an edge between two nodes in the network topology.
 *
 * @generated from message io.clbs.openhes.models.acquisition.TopologyEdge
 */
export type TopologyEdgeJson = {
  /**
   * The unique identifier of source edge.
   *
   * @generated from field: int64 from_x_id = 1;
   */
  fromXId?: string;

  /**
   * The unique identifier of the target edge.
   *
   * @generated from field: int64 to_x_id = 2;
   */
  toXId?: string;

  /**
   * The edge attributes.
   *
   * @generated from field: io.clbs.openhes.models.common.FieldValues attributes = 3;
   */
  attributes?: FieldValuesJson;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.TopologyEdge.
 * Use `create(TopologyEdgeSchema)` to create a new message.
 */
export const TopologyEdgeSchema: GenMessage<TopologyEdge, {jsonType: TopologyEdgeJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 80);

/**
 * Defines the network map specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.NetworkMap
 */
export type NetworkMap = Message<"io.clbs.openhes.models.acquisition.NetworkMap"> & {
  /**
   * The list of topology nodes. Can represent a flat or hierarchical structure.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.TopologyNode nodes = 1;
   */
  nodes: TopologyNode[];

  /**
   * The list of edges between the devices.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.TopologyEdge edges = 2;
   */
  edges: TopologyEdge[];
};

/**
 * Defines the network map specification.
 *
 * @generated from message io.clbs.openhes.models.acquisition.NetworkMap
 */
export type NetworkMapJson = {
  /**
   * The list of topology nodes. Can represent a flat or hierarchical structure.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.TopologyNode nodes = 1;
   */
  nodes?: TopologyNodeJson[];

  /**
   * The list of edges between the devices.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.TopologyEdge edges = 2;
   */
  edges?: TopologyEdgeJson[];
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.NetworkMap.
 * Use `create(NetworkMapSchema)` to create a new message.
 */
export const NetworkMapSchema: GenMessage<NetworkMap, {jsonType: NetworkMapJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 81);

/**
 * Defines a single log record of a communication unit.
 *
 * @generated from message io.clbs.openhes.models.acquisition.CommunicationUnitLogRecord
 */
export type CommunicationUnitLogRecord = Message<"io.clbs.openhes.models.acquisition.CommunicationUnitLogRecord"> & {
  /**
   * The unique identifier of the log record. If not provided, a hash of the log data is auto-generated.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The unique identifier of the communication unit to which the log record belongs. May be empty and the relation can be set at a higher object level.
   *
   * @generated from field: string communication_unit_id = 2;
   */
  communicationUnitId: string;

  /**
   * The timestamp of the log record. Must not be empty.
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 3;
   */
  timestamp?: Timestamp;

  /**
   * The severity level of the log record.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.LogRecordLevel level = 4;
   */
  level: LogRecordLevel;

  /**
   * The log message. Must not be empty.
   *
   * @generated from field: string message = 5;
   */
  message: string;
};

/**
 * Defines a single log record of a communication unit.
 *
 * @generated from message io.clbs.openhes.models.acquisition.CommunicationUnitLogRecord
 */
export type CommunicationUnitLogRecordJson = {
  /**
   * The unique identifier of the log record. If not provided, a hash of the log data is auto-generated.
   *
   * @generated from field: string id = 1;
   */
  id?: string;

  /**
   * The unique identifier of the communication unit to which the log record belongs. May be empty and the relation can be set at a higher object level.
   *
   * @generated from field: string communication_unit_id = 2;
   */
  communicationUnitId?: string;

  /**
   * The timestamp of the log record. Must not be empty.
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 3;
   */
  timestamp?: TimestampJson;

  /**
   * The severity level of the log record.
   *
   * @generated from field: io.clbs.openhes.models.acquisition.LogRecordLevel level = 4;
   */
  level?: LogRecordLevelJson;

  /**
   * The log message. Must not be empty.
   *
   * @generated from field: string message = 5;
   */
  message?: string;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.CommunicationUnitLogRecord.
 * Use `create(CommunicationUnitLogRecordSchema)` to create a new message.
 */
export const CommunicationUnitLogRecordSchema: GenMessage<CommunicationUnitLogRecord, {jsonType: CommunicationUnitLogRecordJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 82);

/**
 * Defines a list of communication unit log records.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ListOfCommunicationUnitLogRecord
 */
export type ListOfCommunicationUnitLogRecord = Message<"io.clbs.openhes.models.acquisition.ListOfCommunicationUnitLogRecord"> & {
  /**
   * The list of communication unit log records.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.CommunicationUnitLogRecord items = 1;
   */
  items: CommunicationUnitLogRecord[];

  /**
   * The total number of items in the list.
   *
   * @generated from field: int32 total_count = 2;
   */
  totalCount: number;
};

/**
 * Defines a list of communication unit log records.
 *
 * @generated from message io.clbs.openhes.models.acquisition.ListOfCommunicationUnitLogRecord
 */
export type ListOfCommunicationUnitLogRecordJson = {
  /**
   * The list of communication unit log records.
   *
   * @generated from field: repeated io.clbs.openhes.models.acquisition.CommunicationUnitLogRecord items = 1;
   */
  items?: CommunicationUnitLogRecordJson[];

  /**
   * The total number of items in the list.
   *
   * @generated from field: int32 total_count = 2;
   */
  totalCount?: number;
};

/**
 * Describes the message io.clbs.openhes.models.acquisition.ListOfCommunicationUnitLogRecord.
 * Use `create(ListOfCommunicationUnitLogRecordSchema)` to create a new message.
 */
export const ListOfCommunicationUnitLogRecordSchema: GenMessage<ListOfCommunicationUnitLogRecord, {jsonType: ListOfCommunicationUnitLogRecordJson}> = /*@__PURE__*/
  messageDesc(file_acquisition_shared, 83);

/**
 * Defines the available job priority levels.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.JobPriority
 */
export enum JobPriority {
  /**
   * Unspecified priority.
   *
   * @generated from enum value: JOB_PRIORITY_UNSPECIFIED = 0;
   */
  JOB_PRIORITY_UNSPECIFIED = 0,

  /**
   * Lowest priority.
   *
   * @generated from enum value: JOB_PRIORITY_0 = 1;
   */
  JOB_PRIORITY_0 = 1,

  /**
   * Priority 1.
   *
   * @generated from enum value: JOB_PRIORITY_1 = 2;
   */
  JOB_PRIORITY_1 = 2,

  /**
   * Priority 2.
   *
   * @generated from enum value: JOB_PRIORITY_2 = 3;
   */
  JOB_PRIORITY_2 = 3,

  /**
   * Priority 3.
   *
   * @generated from enum value: JOB_PRIORITY_3 = 4;
   */
  JOB_PRIORITY_3 = 4,

  /**
   * Priority 4.
   *
   * @generated from enum value: JOB_PRIORITY_4 = 5;
   */
  JOB_PRIORITY_4 = 5,

  /**
   * Priority 5.
   *
   * @generated from enum value: JOB_PRIORITY_5 = 6;
   */
  JOB_PRIORITY_5 = 6,

  /**
   * Priority 6.
   *
   * @generated from enum value: JOB_PRIORITY_6 = 7;
   */
  JOB_PRIORITY_6 = 7,

  /**
   * Priority 7.
   *
   * @generated from enum value: JOB_PRIORITY_7 = 8;
   */
  JOB_PRIORITY_7 = 8,

  /**
   * Highest priority.
   *
   * @generated from enum value: JOB_PRIORITY_8 = 9;
   */
  JOB_PRIORITY_8 = 9,
}

/**
 * Defines the available job priority levels.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.JobPriority
 */
export type JobPriorityJson = "JOB_PRIORITY_UNSPECIFIED" | "JOB_PRIORITY_0" | "JOB_PRIORITY_1" | "JOB_PRIORITY_2" | "JOB_PRIORITY_3" | "JOB_PRIORITY_4" | "JOB_PRIORITY_5" | "JOB_PRIORITY_6" | "JOB_PRIORITY_7" | "JOB_PRIORITY_8";

/**
 * Describes the enum io.clbs.openhes.models.acquisition.JobPriority.
 */
export const JobPrioritySchema: GenEnum<JobPriority, JobPriorityJson> = /*@__PURE__*/
  enumDesc(file_acquisition_shared, 0);

/**
 * Defines the read path policies for retrieving data from devices.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.ReadPathPolicy
 */
export enum ReadPathPolicy {
  /**
   * Keeps the current behavior (typically data-concentrator first).
   *
   * @generated from enum value: READ_PATH_POLICY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Attempts to read directly from the meter and falls back to the data concentrator if needed and supported.
   *
   * @generated from enum value: READ_PATH_POLICY_METER_FIRST = 1;
   */
  METER_FIRST = 1,

  /**
   * Attempts to read from the data concentrator first and falls back to the meter if needed and supported.
   *
   * @generated from enum value: READ_PATH_POLICY_DC_FIRST = 2;
   */
  DC_FIRST = 2,
}

/**
 * Defines the read path policies for retrieving data from devices.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.ReadPathPolicy
 */
export type ReadPathPolicyJson = "READ_PATH_POLICY_UNSPECIFIED" | "READ_PATH_POLICY_METER_FIRST" | "READ_PATH_POLICY_DC_FIRST";

/**
 * Describes the enum io.clbs.openhes.models.acquisition.ReadPathPolicy.
 */
export const ReadPathPolicySchema: GenEnum<ReadPathPolicy, ReadPathPolicyJson> = /*@__PURE__*/
  enumDesc(file_acquisition_shared, 1);

/**
 * Defines the available serial port parity types.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.SerialConfigParity
 */
export enum SerialConfigParity {
  /**
   * Unspecified parity.
   *
   * @generated from enum value: PARITY_UNSPECIFIED = 0;
   */
  PARITY_UNSPECIFIED = 0,

  /**
   * No parity.
   *
   * @generated from enum value: PARITY_NONE = 1;
   */
  PARITY_NONE = 1,

  /**
   * Even parity.
   *
   * @generated from enum value: PARITY_EVEN = 2;
   */
  PARITY_EVEN = 2,

  /**
   * Odd parity.
   *
   * @generated from enum value: PARITY_ODD = 3;
   */
  PARITY_ODD = 3,

  /**
   * Mark parity.
   *
   * @generated from enum value: PARITY_MARK = 4;
   */
  PARITY_MARK = 4,

  /**
   * Space parity.
   *
   * @generated from enum value: PARITY_SPACE = 5;
   */
  PARITY_SPACE = 5,
}

/**
 * Defines the available serial port parity types.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.SerialConfigParity
 */
export type SerialConfigParityJson = "PARITY_UNSPECIFIED" | "PARITY_NONE" | "PARITY_EVEN" | "PARITY_ODD" | "PARITY_MARK" | "PARITY_SPACE";

/**
 * Describes the enum io.clbs.openhes.models.acquisition.SerialConfigParity.
 */
export const SerialConfigParitySchema: GenEnum<SerialConfigParity, SerialConfigParityJson> = /*@__PURE__*/
  enumDesc(file_acquisition_shared, 2);

/**
 * Defines the available serial port data bit types.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.SerialConfigDataBits
 */
export enum SerialConfigDataBits {
  /**
   * Unspecified data bits.
   *
   * @generated from enum value: DATA_BITS_UNSPECIFIED = 0;
   */
  DATA_BITS_UNSPECIFIED = 0,

  /**
   * 5 data bits.
   *
   * @generated from enum value: DATA_BITS_5 = 1;
   */
  DATA_BITS_5 = 1,

  /**
   * 6 data bits.
   *
   * @generated from enum value: DATA_BITS_6 = 2;
   */
  DATA_BITS_6 = 2,

  /**
   * 7 data bits.
   *
   * @generated from enum value: DATA_BITS_7 = 3;
   */
  DATA_BITS_7 = 3,

  /**
   * 8 data bits.
   *
   * @generated from enum value: DATA_BITS_8 = 4;
   */
  DATA_BITS_8 = 4,
}

/**
 * Defines the available serial port data bit types.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.SerialConfigDataBits
 */
export type SerialConfigDataBitsJson = "DATA_BITS_UNSPECIFIED" | "DATA_BITS_5" | "DATA_BITS_6" | "DATA_BITS_7" | "DATA_BITS_8";

/**
 * Describes the enum io.clbs.openhes.models.acquisition.SerialConfigDataBits.
 */
export const SerialConfigDataBitsSchema: GenEnum<SerialConfigDataBits, SerialConfigDataBitsJson> = /*@__PURE__*/
  enumDesc(file_acquisition_shared, 3);

/**
 * Defines the available serial port stop bit types.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.SerialConfigStopBits
 */
export enum SerialConfigStopBits {
  /**
   * Unspecified stop bits.
   *
   * @generated from enum value: STOP_BITS_UNSPECIFIED = 0;
   */
  STOP_BITS_UNSPECIFIED = 0,

  /**
   * 1 stop bit.
   *
   * @generated from enum value: STOP_BITS_1 = 1;
   */
  STOP_BITS_1 = 1,

  /**
   * 1.5 stop bits.
   *
   * @generated from enum value: STOP_BITS_1_5 = 2;
   */
  STOP_BITS_1_5 = 2,

  /**
   * 2 stop bits.
   *
   * @generated from enum value: STOP_BITS_2 = 3;
   */
  STOP_BITS_2 = 3,
}

/**
 * Defines the available serial port stop bit types.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.SerialConfigStopBits
 */
export type SerialConfigStopBitsJson = "STOP_BITS_UNSPECIFIED" | "STOP_BITS_1" | "STOP_BITS_1_5" | "STOP_BITS_2";

/**
 * Describes the enum io.clbs.openhes.models.acquisition.SerialConfigStopBits.
 */
export const SerialConfigStopBitsSchema: GenEnum<SerialConfigStopBits, SerialConfigStopBitsJson> = /*@__PURE__*/
  enumDesc(file_acquisition_shared, 4);

/**
 * Defines the available serial port parity types.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.SerialConfigFLowControler
 */
export enum SerialConfigFLowControler {
  /**
   * Unspecified flow control.
   *
   * @generated from enum value: FLOW_CONTROL_UNSPECIFIED = 0;
   */
  FLOW_CONTROL_UNSPECIFIED = 0,

  /**
   * No flow control.
   *
   * @generated from enum value: FLOW_CONTROL_NONE = 1;
   */
  FLOW_CONTROL_NONE = 1,

  /**
   * Hardware flow control (RTS/CTS).
   *
   * @generated from enum value: FLOW_CONTROL_HARDWARE = 2;
   */
  FLOW_CONTROL_HARDWARE = 2,

  /**
   * Software flow control (XON/XOFF).
   *
   * @generated from enum value: FLOW_CONTROL_SOFTWARE = 3;
   */
  FLOW_CONTROL_SOFTWARE = 3,
}

/**
 * Defines the available serial port parity types.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.SerialConfigFLowControler
 */
export type SerialConfigFLowControlerJson = "FLOW_CONTROL_UNSPECIFIED" | "FLOW_CONTROL_NONE" | "FLOW_CONTROL_HARDWARE" | "FLOW_CONTROL_SOFTWARE";

/**
 * Describes the enum io.clbs.openhes.models.acquisition.SerialConfigFLowControler.
 */
export const SerialConfigFLowControlerSchema: GenEnum<SerialConfigFLowControler, SerialConfigFLowControlerJson> = /*@__PURE__*/
  enumDesc(file_acquisition_shared, 5);

/**
 * Defines the supported communication types for device connections.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.CommunicationType
 */
export enum CommunicationType {
  /**
   * Unspecified communication type.
   *
   * @generated from enum value: COMMUNICATION_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The communication is established via direct TCP/IP.
   *
   * @generated from enum value: COMMUNICATION_TYPE_TCPIP = 1;
   */
  TCPIP = 1,

  /**
   * The communication is established via a phone line (modem).
   *
   * @generated from enum value: COMMUNICATION_TYPE_MODEM_POOL = 2;
   */
  MODEM_POOL = 2,

  /**
   * The communication is established via a direct serial line.
   *
   * @generated from enum value: COMMUNICATION_TYPE_SERIAL_LINE_DIRECT = 3;
   */
  SERIAL_LINE_DIRECT = 3,

  /**
   * The communication is established via a controlled  serial line (Moxa).
   *
   * @generated from enum value: COMMUNICATION_TYPE_SERIAL_LINE_MOXA = 4;
   */
  SERIAL_LINE_MOXA = 4,

  /**
   * The communication is passive. The driver listens on a port (for example, DLMS devices in push mode) or subscribes to a message queue (for example, MQTT).
   *
   * @generated from enum value: COMMUNICATION_TYPE_LISTENING = 99;
   */
  LISTENING = 99,
}

/**
 * Defines the supported communication types for device connections.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.CommunicationType
 */
export type CommunicationTypeJson = "COMMUNICATION_TYPE_UNSPECIFIED" | "COMMUNICATION_TYPE_TCPIP" | "COMMUNICATION_TYPE_MODEM_POOL" | "COMMUNICATION_TYPE_SERIAL_LINE_DIRECT" | "COMMUNICATION_TYPE_SERIAL_LINE_MOXA" | "COMMUNICATION_TYPE_LISTENING";

/**
 * Describes the enum io.clbs.openhes.models.acquisition.CommunicationType.
 */
export const CommunicationTypeSchema: GenEnum<CommunicationType, CommunicationTypeJson> = /*@__PURE__*/
  enumDesc(file_acquisition_shared, 6);

/**
 * Defines the supported data link protocols.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.DataLinkProtocol
 */
export enum DataLinkProtocol {
  /**
   * Unspecified data link protocol.
   *
   * @generated from enum value: LINTPROTO_UNSPECIFIED = 0;
   */
  LINTPROTO_UNSPECIFIED = 0,

  /**
   * The VDEW (IEC 62056-21, IEC-61107) protocol. When combined with the DLMS protocol, the driver initiates communication via IEC and then switches to the mode E (HDLC+DLMS). Supports multiple devices on the same line.
   *
   * @generated from enum value: LINKPROTO_IEC_62056_21 = 1;
   */
  LINKPROTO_IEC_62056_21 = 1,

  /**
   * The HDLC (ISO/IEC-3309) framing. Used with various application protocols, such as DLMS or MODBUS. Supports client/server addressing for multiple devices on the same line.
   *
   * @generated from enum value: LINKPROTO_HDLC = 2;
   */
  LINKPROTO_HDLC = 2,

  /**
   * The COSEM wrapper. Used with the DLMS application protocol. Supports client/server addressing for multiple devices on the same line.
   *
   * @generated from enum value: LINKPROTO_COSEM_WRAPPER = 3;
   */
  LINKPROTO_COSEM_WRAPPER = 3,

  /**
   * The Modbus protocol. Used with the Modbus application protocol where no other data link is used.
   *
   * @generated from enum value: LINKPROTO_MODBUS = 4;
   */
  LINKPROTO_MODBUS = 4,

  /**
   * The M-Bus protocol. Used with the M-Bus application protocol.
   *
   * @generated from enum value: LINKPROTO_MBUS = 5;
   */
  LINKPROTO_MBUS = 5,

  /**
   * The Viktor protocol. A proprietary protocol used by Viktor-based devices, such as DC450 Viktor.
   *
   * @generated from enum value: LINKPROTO_VIKTOR = 6;
   */
  LINKPROTO_VIKTOR = 6,

  /**
   * No data link protocol is applicable. Used with listening communication types.
   *
   * @generated from enum value: LINKPROTO_NOT_APPLICABLE = 99;
   */
  LINKPROTO_NOT_APPLICABLE = 99,
}

/**
 * Defines the supported data link protocols.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.DataLinkProtocol
 */
export type DataLinkProtocolJson = "LINTPROTO_UNSPECIFIED" | "LINKPROTO_IEC_62056_21" | "LINKPROTO_HDLC" | "LINKPROTO_COSEM_WRAPPER" | "LINKPROTO_MODBUS" | "LINKPROTO_MBUS" | "LINKPROTO_VIKTOR" | "LINKPROTO_NOT_APPLICABLE";

/**
 * Describes the enum io.clbs.openhes.models.acquisition.DataLinkProtocol.
 */
export const DataLinkProtocolSchema: GenEnum<DataLinkProtocol, DataLinkProtocolJson> = /*@__PURE__*/
  enumDesc(file_acquisition_shared, 7);

/**
 * Defines the supported application protocols.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.ApplicationProtocol
 */
export enum ApplicationProtocol {
  /**
   * Unspecified application protocol.
   *
   * @generated from enum value: APPPROTO_UNSPECIFIED = 0;
   */
  APPPROTO_UNSPECIFIED = 0,

  /**
   * The IEC 62056-21 (IEC-61107, VDEW) protocol.
   *
   * @generated from enum value: APPPROTO_IEC_62056_21 = 1;
   */
  APPPROTO_IEC_62056_21 = 1,

  /**
   * The DLMS short-name protocol.
   *
   * @generated from enum value: APPPROTO_DLMS_SN = 2;
   */
  APPPROTO_DLMS_SN = 2,

  /**
   * The DLMS logical-name protocol.
   *
   * @generated from enum value: APPPROTO_DLMS_LN = 3;
   */
  APPPROTO_DLMS_LN = 3,

  /**
   * The SCTM protocol.
   *
   * @generated from enum value: APPPROTO_SCTM = 4;
   */
  APPPROTO_SCTM = 4,

  /**
   * The LIS200 protocol.
   *
   * @generated from enum value: APPPROTO_LIS200 = 5;
   */
  APPPROTO_LIS200 = 5,

  /**
   * The ANSI C12 protocol.
   *
   * @generated from enum value: APPPROTO_ANSI_C12 = 6;
   */
  APPPROTO_ANSI_C12 = 6,

  /**
   * The MQTT protocol.
   *
   * @generated from enum value: APPPROTO_MQTT = 7;
   */
  APPPROTO_MQTT = 7,

  /**
   * The MODBUS protocol.
   *
   * @generated from enum value: APPPROTO_MODBUS = 8;
   */
  APPPROTO_MODBUS = 8,

  /**
   * The MBUS protocol.
   *
   * @generated from enum value: APPPROTO_MBUS = 9;
   */
  APPPROTO_MBUS = 9,
}

/**
 * Defines the supported application protocols.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.ApplicationProtocol
 */
export type ApplicationProtocolJson = "APPPROTO_UNSPECIFIED" | "APPPROTO_IEC_62056_21" | "APPPROTO_DLMS_SN" | "APPPROTO_DLMS_LN" | "APPPROTO_SCTM" | "APPPROTO_LIS200" | "APPPROTO_ANSI_C12" | "APPPROTO_MQTT" | "APPPROTO_MODBUS" | "APPPROTO_MBUS";

/**
 * Describes the enum io.clbs.openhes.models.acquisition.ApplicationProtocol.
 */
export const ApplicationProtocolSchema: GenEnum<ApplicationProtocol, ApplicationProtocolJson> = /*@__PURE__*/
  enumDesc(file_acquisition_shared, 8);

/**
 * Defines the supported action types. Each action type corresponds to a specific operation that can be performed on a device.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.ActionType
 */
export enum ActionType {
  /**
   * Unspecified action type.
   *
   * @generated from enum value: ACTION_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Get a register value, for example an instantaneous value. The action covers a specific register.
   *
   * @generated from enum value: ACTION_TYPE_GET_REGISTER = 1;
   */
  GET_REGISTER = 1,

  /**
   * Get a periodical profile, for example a load profile. The action covers a specific profile column.
   *
   * @generated from enum value: ACTION_TYPE_GET_PERIODICAL_PROFILE = 2;
   */
  GET_PERIODICAL_PROFILE = 2,

  /**
   * Get a non-periodical profile, for example a daily profile or monthly billing registers. The action covers a specific profile column and/or billing register.
   *
   * @generated from enum value: ACTION_TYPE_GET_IRREGULAR_PROFILE = 3;
   */
  GET_IRREGULAR_PROFILE = 3,

  /**
   * Get an event log. The action covers a specific event log.
   *
   * @generated from enum value: ACTION_TYPE_GET_EVENTS = 4;
   */
  GET_EVENTS = 4,

  /**
   * Get device information. The action returns detailed information data about the remote device.
   *
   * @generated from enum value: ACTION_TYPE_GET_DEVICE_INFO = 10;
   */
  GET_DEVICE_INFO = 10,

  /**
   * Synchronize the device clock. The action sets the time and can forcefully update it if `force` attribute is set.
   *
   * @generated from enum value: ACTION_TYPE_SYNC_CLOCK = 11;
   */
  SYNC_CLOCK = 11,

  /**
   * Set relay state. The action covers a single relay.
   *
   * @generated from enum value: ACTION_TYPE_SET_RELAY_STATE = 21;
   */
  SET_RELAY_STATE = 21,

  /**
   * Get the disconnector state.
   *
   * @generated from enum value: ACTION_TYPE_GET_DISCONNECTOR_STATE = 22;
   */
  GET_DISCONNECTOR_STATE = 22,

  /**
   * Set the disconnector state.
   *
   * @generated from enum value: ACTION_TYPE_SET_DISCONNECTOR_STATE = 23;
   */
  SET_DISCONNECTOR_STATE = 23,

  /**
   * Get time-of-use table.
   *
   * @generated from enum value: ACTION_TYPE_GET_TOU = 24;
   */
  GET_TOU = 24,

  /**
   * Set time-of-use table.
   *
   * @generated from enum value: ACTION_TYPE_SET_TOU = 25;
   */
  SET_TOU = 25,

  /**
   * Set limiter settings. The action covers single limiter.
   *
   * @generated from enum value: ACTION_TYPE_SET_LIMITER = 27;
   */
  SET_LIMITER = 27,

  /**
   * Reset the billing period.
   *
   * @generated from enum value: ACTION_TYPE_RESET_BILLING_PERIOD = 40;
   */
  RESET_BILLING_PERIOD = 40,

  /**
   * Start a firmware update.
   *
   * @generated from enum value: ACTION_TYPE_FW_UPDATE = 50;
   */
  FW_UPDATE = 50,
}

/**
 * Defines the supported action types. Each action type corresponds to a specific operation that can be performed on a device.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.ActionType
 */
export type ActionTypeJson = "ACTION_TYPE_UNSPECIFIED" | "ACTION_TYPE_GET_REGISTER" | "ACTION_TYPE_GET_PERIODICAL_PROFILE" | "ACTION_TYPE_GET_IRREGULAR_PROFILE" | "ACTION_TYPE_GET_EVENTS" | "ACTION_TYPE_GET_DEVICE_INFO" | "ACTION_TYPE_SYNC_CLOCK" | "ACTION_TYPE_SET_RELAY_STATE" | "ACTION_TYPE_GET_DISCONNECTOR_STATE" | "ACTION_TYPE_SET_DISCONNECTOR_STATE" | "ACTION_TYPE_GET_TOU" | "ACTION_TYPE_SET_TOU" | "ACTION_TYPE_SET_LIMITER" | "ACTION_TYPE_RESET_BILLING_PERIOD" | "ACTION_TYPE_FW_UPDATE";

/**
 * Describes the enum io.clbs.openhes.models.acquisition.ActionType.
 */
export const ActionTypeSchema: GenEnum<ActionType, ActionTypeJson> = /*@__PURE__*/
  enumDesc(file_acquisition_shared, 9);

/**
 * Defines the result codes related to job actions.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.ActionResultCode
 */
export enum ActionResultCode {
  /**
   * Unspecified action result code.
   *
   * @generated from enum value: ERROR_CODE_ACTION_UNSPECIFIED = 0;
   */
  ERROR_CODE_ACTION_UNSPECIFIED = 0,

  /**
   * The action has been completed successfully.
   *
   * @generated from enum value: ERROR_CODE_ACTION_OK = 1;
   */
  ERROR_CODE_ACTION_OK = 1,

  /**
   * The action is not supported by the driver or device.
   *
   * @generated from enum value: ERROR_CODE_ACTION_UNSUPPORTED = 2;
   */
  ERROR_CODE_ACTION_UNSUPPORTED = 2,

  /**
   * The action is pending.
   *
   * @generated from enum value: ERROR_CODE_ACTION_PENDING = 3;
   */
  ERROR_CODE_ACTION_PENDING = 3,

  /**
   * The action has failed.
   *
   * @generated from enum value: ERROR_CODE_ACTION_ERROR = 5;
   */
  ERROR_CODE_ACTION_ERROR = 5,
}

/**
 * Defines the result codes related to job actions.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.ActionResultCode
 */
export type ActionResultCodeJson = "ERROR_CODE_ACTION_UNSPECIFIED" | "ERROR_CODE_ACTION_OK" | "ERROR_CODE_ACTION_UNSUPPORTED" | "ERROR_CODE_ACTION_PENDING" | "ERROR_CODE_ACTION_ERROR";

/**
 * Describes the enum io.clbs.openhes.models.acquisition.ActionResultCode.
 */
export const ActionResultCodeSchema: GenEnum<ActionResultCode, ActionResultCodeJson> = /*@__PURE__*/
  enumDesc(file_acquisition_shared, 10);

/**
 * Defines the error codes related to jobs.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.JobErrorCode
 */
export enum JobErrorCode {
  /**
   * Unspecified job error code.
   *
   * @generated from enum value: JOB_ERROR_CODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The job has been completed successfully.
   *
   * @generated from enum value: JOB_ERROR_CODE_NONE = 1;
   */
  NONE = 1,

  /**
   * There is no free slot in the driver to handle the job; the job shall be send again later.
   *
   * @generated from enum value: JOB_ERROR_CODE_BUSY = 2;
   */
  BUSY = 2,

  /**
   * The job has failed; a retry will be attempted.
   *
   * @generated from enum value: JOB_ERROR_CODE_ERROR = 5;
   */
  ERROR = 5,

  /**
   * This should never happen! It indicates that the same job is currently being processed by the driver and was sent multiple times to the driver, which would point to a bug.
   *
   * @generated from enum value: JOB_ERROR_CODE_ALREADY_EXISTS = 8;
   */
  ALREADY_EXISTS = 8,

  /**
   * The job failed, not retry will be attempted.
   *
   * @generated from enum value: JOB_ERROR_CODE_FATAL = 9;
   */
  FATAL = 9,
}

/**
 * Defines the error codes related to jobs.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.JobErrorCode
 */
export type JobErrorCodeJson = "JOB_ERROR_CODE_UNSPECIFIED" | "JOB_ERROR_CODE_NONE" | "JOB_ERROR_CODE_BUSY" | "JOB_ERROR_CODE_ERROR" | "JOB_ERROR_CODE_ALREADY_EXISTS" | "JOB_ERROR_CODE_FATAL";

/**
 * Describes the enum io.clbs.openhes.models.acquisition.JobErrorCode.
 */
export const JobErrorCodeSchema: GenEnum<JobErrorCode, JobErrorCodeJson> = /*@__PURE__*/
  enumDesc(file_acquisition_shared, 11);

/**
 * Defines the status information of an entire bulk.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.BulkStatusCode
 */
export enum BulkStatusCode {
  /**
   * Unspecified bulk status.
   *
   * @generated from enum value: BULK_STATUS_UNSPECIFIED = 0;
   */
  BULK_STATUS_UNSPECIFIED = 0,

  /**
   * The bulk is being prepared.
   *
   * @generated from enum value: BULK_STATUS_PREPARING = 1;
   */
  BULK_STATUS_PREPARING = 1,

  /**
   * The bulk is waiting in the queue and ready to be started.
   *
   * @generated from enum value: BULK_STATUS_QUEUED = 2;
   */
  BULK_STATUS_QUEUED = 2,

  /**
   * The bulk is currently running.
   *
   * @generated from enum value: BULK_STATUS_RUNNING = 3;
   */
  BULK_STATUS_RUNNING = 3,

  /**
   * The bulk has been completed.
   *
   * @generated from enum value: BULK_STATUS_COMPLETED = 4;
   */
  BULK_STATUS_COMPLETED = 4,

  /**
   * The bulk has expired.
   *
   * @generated from enum value: BULK_STATUS_EXPIRED = 5;
   */
  BULK_STATUS_EXPIRED = 5,
}

/**
 * Defines the status information of an entire bulk.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.BulkStatusCode
 */
export type BulkStatusCodeJson = "BULK_STATUS_UNSPECIFIED" | "BULK_STATUS_PREPARING" | "BULK_STATUS_QUEUED" | "BULK_STATUS_RUNNING" | "BULK_STATUS_COMPLETED" | "BULK_STATUS_EXPIRED";

/**
 * Describes the enum io.clbs.openhes.models.acquisition.BulkStatusCode.
 */
export const BulkStatusCodeSchema: GenEnum<BulkStatusCode, BulkStatusCodeJson> = /*@__PURE__*/
  enumDesc(file_acquisition_shared, 12);

/**
 * Defines the possible register types.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.DeviceConfigurationRegisterKind
 */
export enum DeviceConfigurationRegisterKind {
  /**
   * Unspecified register kind.
   *
   * @generated from enum value: KIND_UNSPECIFIED = 0;
   */
  KIND_UNSPECIFIED = 0,

  /**
   * The object represents a generic register.
   *
   * @generated from enum value: KIND_REGISTER = 1;
   */
  KIND_REGISTER = 1,

  /**
   * The object represents a periodical profile.
   *
   * @generated from enum value: KIND_PERIODICAL_PROFILE = 2;
   */
  KIND_PERIODICAL_PROFILE = 2,

  /**
   * The object represents an irregular profile.
   *
   * @generated from enum value: KIND_IRREGULAR_PROFILE = 3;
   */
  KIND_IRREGULAR_PROFILE = 3,

  /**
   * The object represents a synthetic register, not visible to drivers. It can be defined to store derived or external data.
   *
   * @generated from enum value: KIND_SYNTHETIC = 99;
   */
  KIND_SYNTHETIC = 99,
}

/**
 * Defines the possible register types.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.DeviceConfigurationRegisterKind
 */
export type DeviceConfigurationRegisterKindJson = "KIND_UNSPECIFIED" | "KIND_REGISTER" | "KIND_PERIODICAL_PROFILE" | "KIND_IRREGULAR_PROFILE" | "KIND_SYNTHETIC";

/**
 * Describes the enum io.clbs.openhes.models.acquisition.DeviceConfigurationRegisterKind.
 */
export const DeviceConfigurationRegisterKindSchema: GenEnum<DeviceConfigurationRegisterKind, DeviceConfigurationRegisterKindJson> = /*@__PURE__*/
  enumDesc(file_acquisition_shared, 13);

/**
 * Defines the possible statuses of jobs.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.JobStatusCode
 */
export enum JobStatusCode {
  /**
   * Unspecified job status.
   *
   * @generated from enum value: JOB_STATUS_UNSPECIFIED = 0;
   */
  JOB_STATUS_UNSPECIFIED = 0,

  /**
   * The job is waiting in the queue for execution.
   *
   * @generated from enum value: JOB_STATUS_QUEUED = 1;
   */
  JOB_STATUS_QUEUED = 1,

  /**
   * The job is currently running.
   *
   * @generated from enum value: JOB_STATUS_RUNNING = 2;
   */
  JOB_STATUS_RUNNING = 2,

  /**
   * The job has finished acquiring data and is now processing it.
   *
   * @generated from enum value: JOB_STATUS_PROCESSING_DATA = 3;
   */
  JOB_STATUS_PROCESSING_DATA = 3,

  /**
   * The job has been completed.
   *
   * @generated from enum value: JOB_STATUS_COMPLETED = 4;
   */
  JOB_STATUS_COMPLETED = 4,

  /**
   * The job has failed.
   *
   * @generated from enum value: JOB_STATUS_FAILED = 5;
   */
  JOB_STATUS_FAILED = 5,

  /**
   * The job is being cancelled. This is a transient state when the parent bulk or the job itself has been requested to be cancelled. When the cancellation is completed, the job status changes to `CANCELLED`.
   *
   * @generated from enum value: JOB_STATUS_CANCELLING = 6;
   */
  JOB_STATUS_CANCELLING = 6,

  /**
   * The job has been cancelled.
   *
   * @generated from enum value: JOB_STATUS_CANCELLED = 7;
   */
  JOB_STATUS_CANCELLED = 7,

  /**
   * The job has expired.
   *
   * @generated from enum value: JOB_STATUS_EXPIRED = 8;
   */
  JOB_STATUS_EXPIRED = 8,
}

/**
 * Defines the possible statuses of jobs.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.JobStatusCode
 */
export type JobStatusCodeJson = "JOB_STATUS_UNSPECIFIED" | "JOB_STATUS_QUEUED" | "JOB_STATUS_RUNNING" | "JOB_STATUS_PROCESSING_DATA" | "JOB_STATUS_COMPLETED" | "JOB_STATUS_FAILED" | "JOB_STATUS_CANCELLING" | "JOB_STATUS_CANCELLED" | "JOB_STATUS_EXPIRED";

/**
 * Describes the enum io.clbs.openhes.models.acquisition.JobStatusCode.
 */
export const JobStatusCodeSchema: GenEnum<JobStatusCode, JobStatusCodeJson> = /*@__PURE__*/
  enumDesc(file_acquisition_shared, 14);

/**
 * Defines the types of nodes in the network topology.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.TopologyNodeType
 */
export enum TopologyNodeType {
  /**
   * Unspecified node type.
   *
   * @generated from enum value: TOPOLOGY_NODE_UNSPECIFIED = 0;
   */
  TOPOLOGY_NODE_UNSPECIFIED = 0,

  /**
   * The node is a device, such as an electricity meter.
   *
   * @generated from enum value: TOPOLOGY_NODE_DEVICE = 1;
   */
  TOPOLOGY_NODE_DEVICE = 1,

  /**
   * The node is a communication unit, such as a modem or a data concentrator.
   *
   * @generated from enum value: TOPOLOGY_NODE_COMMUNICATION_UNIT = 2;
   */
  TOPOLOGY_NODE_COMMUNICATION_UNIT = 2,
}

/**
 * Defines the types of nodes in the network topology.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.TopologyNodeType
 */
export type TopologyNodeTypeJson = "TOPOLOGY_NODE_UNSPECIFIED" | "TOPOLOGY_NODE_DEVICE" | "TOPOLOGY_NODE_COMMUNICATION_UNIT";

/**
 * Describes the enum io.clbs.openhes.models.acquisition.TopologyNodeType.
 */
export const TopologyNodeTypeSchema: GenEnum<TopologyNodeType, TopologyNodeTypeJson> = /*@__PURE__*/
  enumDesc(file_acquisition_shared, 15);

/**
 * Defines the severity levels for communication unit log records.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.LogRecordLevel
 */
export enum LogRecordLevel {
  /**
   * Debug log record.
   *
   * @generated from enum value: LOG_RECORD_LEVEL_DEBUG = 0;
   */
  DEBUG = 0,

  /**
   * Information log record.
   *
   * @generated from enum value: LOG_RECORD_LEVEL_INFO = 1;
   */
  INFO = 1,

  /**
   * Warning log record.
   *
   * @generated from enum value: LOG_RECORD_LEVEL_WARNING = 2;
   */
  WARNING = 2,

  /**
   * Error log record.
   *
   * @generated from enum value: LOG_RECORD_LEVEL_ERROR = 3;
   */
  ERROR = 3,

  /**
   * Fatal log record.
   *
   * @generated from enum value: LOG_RECORD_LEVEL_FATAL = 4;
   */
  FATAL = 4,
}

/**
 * Defines the severity levels for communication unit log records.
 *
 * @generated from enum io.clbs.openhes.models.acquisition.LogRecordLevel
 */
export type LogRecordLevelJson = "LOG_RECORD_LEVEL_DEBUG" | "LOG_RECORD_LEVEL_INFO" | "LOG_RECORD_LEVEL_WARNING" | "LOG_RECORD_LEVEL_ERROR" | "LOG_RECORD_LEVEL_FATAL";

/**
 * Describes the enum io.clbs.openhes.models.acquisition.LogRecordLevel.
 */
export const LogRecordLevelSchema: GenEnum<LogRecordLevel, LogRecordLevelJson> = /*@__PURE__*/
  enumDesc(file_acquisition_shared, 16);

