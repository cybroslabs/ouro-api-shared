// @generated by protoc-gen-es v2.10.1 with parameter "target=ts,json_types=true"
// @generated from file crypto/management.proto (package io.clbs.openhes.models.crypto, edition 2023)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { Timestamp, TimestampJson } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { ObjectType, ObjectTypeJson } from "../common/objects_pb";
import { file_common_objects } from "../common/objects_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file crypto/management.proto.
 */
export const file_crypto_management: GenFile = /*@__PURE__*/
  fileDesc("ChdjcnlwdG8vbWFuYWdlbWVudC5wcm90bxIdaW8uY2xicy5vcGVuaGVzLm1vZGVscy5jcnlwdG8igAEKFkdldENyeXB0b1NlY3JldFJlcXVlc3QSPgoLb2JqZWN0X3R5cGUYASABKA4yKS5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmNvbW1vbi5PYmplY3RUeXBlEhMKC2RyaXZlcl90eXBlGAIgASgJEhEKCWNyeXB0b19pZBgDIAEoCSJNCg1DcnlwdG9TZWNyZXRzEjwKB3NlY3JldHMYASADKAsyKy5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmNyeXB0by5DcnlwdG9TZWNyZXQi3gEKDENyeXB0b1NlY3JldBIUCgxhY2Nlc3NfbGV2ZWwYASABKAkSDgoGa2V5X2lkGAIgASgJEi4KCmNyZWF0ZWRfYXQYAyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEi4KCnVwZGF0ZWRfYXQYBCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEgwKBGRhdGEYDyABKAxKBAgFEAZKBAgGEAdKBAgHEAhKBAgIEAlKBAgJEApKBAgKEAtKBAgLEAxKBAgMEA1KBAgNEA5KBAgOEA8i3gMKFlNldENyeXB0b1NlY3JldFJlcXVlc3QSPgoLb2JqZWN0X3R5cGUYASABKA4yKS5pby5jbGJzLm9wZW5oZXMubW9kZWxzLmNvbW1vbi5PYmplY3RUeXBlEhMKC2RyaXZlcl90eXBlGAIgASgJEhEKCWNyeXB0b19pZBgDIAEoCRIUCgxhY2Nlc3NfbGV2ZWwYBCABKAkSDgoGa2V5X2lkGAUgASgJEhwKFGRlY3J5cHRpb25fc2VjcmV0X2lkGAYgASgJEmYKHXNlc3Npb25fa2V5X2RlY3J5cHRpb25fbWV0aG9kGAcgASgOMj8uaW8uY2xicy5vcGVuaGVzLm1vZGVscy5jcnlwdG8uU2VjcmV0U2Vzc2lvbktleURlY3J5cHRpb25NZXRob2QSEwoLc2Vzc2lvbl9rZXkYCCABKAwSWQoWZGF0YV9kZWNyeXB0aW9uX21ldGhvZBgJIAEoDjI5LmlvLmNsYnMub3Blbmhlcy5tb2RlbHMuY3J5cHRvLlNlY3JldERhdGFEZWNyeXB0aW9uTWV0aG9kEhoKEmRhdGFfZGVjcnlwdGlvbl9pdhgKIAEoDBIMCgRkYXRhGA8gASgMSgQICxAMSgQIDBANSgQIDRAOSgQIDhAPKmsKGlNlY3JldERhdGFEZWNyeXB0aW9uTWV0aG9kEhsKF1NFQ1JFVF9EQVRBX1VOU1BFQ0lGSUVEEAASFQoRU0VDUkVUX0RBVEFfUExBSU4QARIZChVTRUNSRVRfREFUQV9BRVMyNTZDQkMQAip/CiBTZWNyZXRTZXNzaW9uS2V5RGVjcnlwdGlvbk1ldGhvZBIeChpTRUNSRVRfU0VTU0lPTl9VTlNQRUNJRklFRBAAEhgKFFNFQ1JFVF9TRVNTSU9OX1BMQUlOEAESIQodU0VDUkVUX1NFU1NJT05fUlNBX09BRVBNX0dGMVAQAkI1WjNnaXRodWIuY29tL2N5YnJvc2xhYnMvb3Vyby1hcGktc2hhcmVkL2dlbi9nby9jcnlwdG9iCGVkaXRpb25zcOgH", [file_google_protobuf_timestamp, file_common_objects]);

/**
 * Defines a specification for retrieving crypto secrets.
 *
 * @generated from message io.clbs.openhes.models.crypto.GetCryptoSecretRequest
 */
export type GetCryptoSecretRequest = Message<"io.clbs.openhes.models.crypto.GetCryptoSecretRequest"> & {
  /**
   * The resource type for which the secret is defined.
   * @example: OBJECT_TYPE_BULK
   * @example: OBJECT_TYPE_DEVICE
   *
   * @generated from field: io.clbs.openhes.models.common.ObjectType object_type = 1;
   */
  objectType: ObjectType;

  /**
   * The driver type for which the secret is requested.
   * @example: "METERCONTROL_ST402D_DLMS"
   * @example: "LANDISGYR_E650_DLMS_SN"
   *
   * @generated from field: string driver_type = 2;
   */
  driverType: string;

  /**
   * The crypto identifier of the secret to retrieve.
   * @gqltype: UUID
   *
   * @generated from field: string crypto_id = 3;
   */
  cryptoId: string;
};

/**
 * Defines a specification for retrieving crypto secrets.
 *
 * @generated from message io.clbs.openhes.models.crypto.GetCryptoSecretRequest
 */
export type GetCryptoSecretRequestJson = {
  /**
   * The resource type for which the secret is defined.
   * @example: OBJECT_TYPE_BULK
   * @example: OBJECT_TYPE_DEVICE
   *
   * @generated from field: io.clbs.openhes.models.common.ObjectType object_type = 1;
   */
  objectType?: ObjectTypeJson;

  /**
   * The driver type for which the secret is requested.
   * @example: "METERCONTROL_ST402D_DLMS"
   * @example: "LANDISGYR_E650_DLMS_SN"
   *
   * @generated from field: string driver_type = 2;
   */
  driverType?: string;

  /**
   * The crypto identifier of the secret to retrieve.
   * @gqltype: UUID
   *
   * @generated from field: string crypto_id = 3;
   */
  cryptoId?: string;
};

/**
 * Describes the message io.clbs.openhes.models.crypto.GetCryptoSecretRequest.
 * Use `create(GetCryptoSecretRequestSchema)` to create a new message.
 */
export const GetCryptoSecretRequestSchema: GenMessage<GetCryptoSecretRequest, {jsonType: GetCryptoSecretRequestJson}> = /*@__PURE__*/
  messageDesc(file_crypto_management, 0);

/**
 * Defines a list of crypto secrets.
 *
 * @generated from message io.clbs.openhes.models.crypto.CryptoSecrets
 */
export type CryptoSecrets = Message<"io.clbs.openhes.models.crypto.CryptoSecrets"> & {
  /**
   * A list of crypto secrets.
   *
   * @generated from field: repeated io.clbs.openhes.models.crypto.CryptoSecret secrets = 1;
   */
  secrets: CryptoSecret[];
};

/**
 * Defines a list of crypto secrets.
 *
 * @generated from message io.clbs.openhes.models.crypto.CryptoSecrets
 */
export type CryptoSecretsJson = {
  /**
   * A list of crypto secrets.
   *
   * @generated from field: repeated io.clbs.openhes.models.crypto.CryptoSecret secrets = 1;
   */
  secrets?: CryptoSecretJson[];
};

/**
 * Describes the message io.clbs.openhes.models.crypto.CryptoSecrets.
 * Use `create(CryptoSecretsSchema)` to create a new message.
 */
export const CryptoSecretsSchema: GenMessage<CryptoSecrets, {jsonType: CryptoSecretsJson}> = /*@__PURE__*/
  messageDesc(file_crypto_management, 1);

/**
 * Defines a cryptographic secret containing sensitive credentials for device communication.
 * Secrets include authentication keys, encryption keys, and passwords used to establish secure connections with devices.
 *
 * @generated from message io.clbs.openhes.models.crypto.CryptoSecret
 */
export type CryptoSecret = Message<"io.clbs.openhes.models.crypto.CryptoSecret"> & {
  /**
   * The security access level this secret relates to. Maps to DLMS/COSEM association levels or similar concepts in other protocols.
   * @example: "1"
   * @example: "2"
   * @example: "G"
   * @example: "cert"
   *
   * @generated from field: string access_level = 1;
   */
  accessLevel: string;

  /**
   * The unique identifier for this secret value. Used to distinguish between multiple crypto secrets within the same device.
   * @example: "AK"
   * @example: "EK"
   * @example: "PW"
   * @example: "CERT"
   *
   * @generated from field: string key_id = 2;
   */
  keyId: string;

  /**
   * The timestamp when this secret was initially created in the system.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 3;
   */
  createdAt?: Timestamp;

  /**
   * The timestamp when this secret was last modified or rotated.
   *
   * @generated from field: google.protobuf.Timestamp updated_at = 4;
   */
  updatedAt?: Timestamp;

  /**
   * The actual secret data (e.g., encryption key, password). This field contains the decrypted value ready for use.
   *
   * @generated from field: bytes data = 15;
   */
  data: Uint8Array;
};

/**
 * Defines a cryptographic secret containing sensitive credentials for device communication.
 * Secrets include authentication keys, encryption keys, and passwords used to establish secure connections with devices.
 *
 * @generated from message io.clbs.openhes.models.crypto.CryptoSecret
 */
export type CryptoSecretJson = {
  /**
   * The security access level this secret relates to. Maps to DLMS/COSEM association levels or similar concepts in other protocols.
   * @example: "1"
   * @example: "2"
   * @example: "G"
   * @example: "cert"
   *
   * @generated from field: string access_level = 1;
   */
  accessLevel?: string;

  /**
   * The unique identifier for this secret value. Used to distinguish between multiple crypto secrets within the same device.
   * @example: "AK"
   * @example: "EK"
   * @example: "PW"
   * @example: "CERT"
   *
   * @generated from field: string key_id = 2;
   */
  keyId?: string;

  /**
   * The timestamp when this secret was initially created in the system.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 3;
   */
  createdAt?: TimestampJson;

  /**
   * The timestamp when this secret was last modified or rotated.
   *
   * @generated from field: google.protobuf.Timestamp updated_at = 4;
   */
  updatedAt?: TimestampJson;

  /**
   * The actual secret data (e.g., encryption key, password). This field contains the decrypted value ready for use.
   *
   * @generated from field: bytes data = 15;
   */
  data?: string;
};

/**
 * Describes the message io.clbs.openhes.models.crypto.CryptoSecret.
 * Use `create(CryptoSecretSchema)` to create a new message.
 */
export const CryptoSecretSchema: GenMessage<CryptoSecret, {jsonType: CryptoSecretJson}> = /*@__PURE__*/
  messageDesc(file_crypto_management, 2);

/**
 * Defines a specification for creating or updating crypto secrets.
 *
 * @generated from message io.clbs.openhes.models.crypto.SetCryptoSecretRequest
 */
export type SetCryptoSecretRequest = Message<"io.clbs.openhes.models.crypto.SetCryptoSecretRequest"> & {
  /**
   * The resource type for which the secret is defined.
   * @example: OBJECT_TYPE_BULK
   * @example: OBJECT_TYPE_DEVICE
   *
   * @generated from field: io.clbs.openhes.models.common.ObjectType object_type = 1;
   */
  objectType: ObjectType;

  /**
   * The driver type for which the secret is created or updated.
   * @example: "METERCONTROL_ST402D_DLMS"
   * @example: "LANDISGYR_E650_DLMS_SN"
   *
   * @generated from field: string driver_type = 2;
   */
  driverType: string;

  /**
   * The crypto identifier of the secret to create or update.
   * @gqltype: UUID
   *
   * @generated from field: string crypto_id = 3;
   */
  cryptoId: string;

  /**
   * The security access level for this secret value. Maps to DLMS/COSEM association levels or similar concepts in other protocols.
   * @example: "1"
   * @example: "2"
   * @example: "G"
   * @example: "cert"
   *
   * @generated from field: string access_level = 4;
   */
  accessLevel: string;

  /**
   * The unique identifier for this secret value. Used to distinguish between multiple crypto secrets within the same device.
   * @example: "AK"
   * @example: "EK"
   * @example: "PW"
   * @example: "CERT"
   *
   * @generated from field: string key_id = 5;
   */
  keyId: string;

  /**
   * The unique identifier for the key used to decrypt either the session key or the data directly.
   * @gqltype: UUID
   *
   * @generated from field: string decryption_secret_id = 6;
   */
  decryptionSecretId: string;

  /**
   * The method used to decrypt the session key. May be unset if the session key is not set or not used.
   *
   * @generated from field: io.clbs.openhes.models.crypto.SecretSessionKeyDecryptionMethod session_key_decryption_method = 7;
   */
  sessionKeyDecryptionMethod: SecretSessionKeyDecryptionMethod;

  /**
   * The session key (usually encrypted) used to decrypt the data.
   *
   * @generated from field: bytes session_key = 8;
   */
  sessionKey: Uint8Array;

  /**
   * The method used to decrypt the secret data. May be unset if the data is not encrypted.
   *
   * @generated from field: io.clbs.openhes.models.crypto.SecretDataDecryptionMethod data_decryption_method = 9;
   */
  dataDecryptionMethod: SecretDataDecryptionMethod;

  /**
   * The initialization vector for the decryption method, if applicable.
   *
   * @generated from field: bytes data_decryption_iv = 10;
   */
  dataDecryptionIv: Uint8Array;

  /**
   * The secret data.
   *
   * @generated from field: bytes data = 15;
   */
  data: Uint8Array;
};

/**
 * Defines a specification for creating or updating crypto secrets.
 *
 * @generated from message io.clbs.openhes.models.crypto.SetCryptoSecretRequest
 */
export type SetCryptoSecretRequestJson = {
  /**
   * The resource type for which the secret is defined.
   * @example: OBJECT_TYPE_BULK
   * @example: OBJECT_TYPE_DEVICE
   *
   * @generated from field: io.clbs.openhes.models.common.ObjectType object_type = 1;
   */
  objectType?: ObjectTypeJson;

  /**
   * The driver type for which the secret is created or updated.
   * @example: "METERCONTROL_ST402D_DLMS"
   * @example: "LANDISGYR_E650_DLMS_SN"
   *
   * @generated from field: string driver_type = 2;
   */
  driverType?: string;

  /**
   * The crypto identifier of the secret to create or update.
   * @gqltype: UUID
   *
   * @generated from field: string crypto_id = 3;
   */
  cryptoId?: string;

  /**
   * The security access level for this secret value. Maps to DLMS/COSEM association levels or similar concepts in other protocols.
   * @example: "1"
   * @example: "2"
   * @example: "G"
   * @example: "cert"
   *
   * @generated from field: string access_level = 4;
   */
  accessLevel?: string;

  /**
   * The unique identifier for this secret value. Used to distinguish between multiple crypto secrets within the same device.
   * @example: "AK"
   * @example: "EK"
   * @example: "PW"
   * @example: "CERT"
   *
   * @generated from field: string key_id = 5;
   */
  keyId?: string;

  /**
   * The unique identifier for the key used to decrypt either the session key or the data directly.
   * @gqltype: UUID
   *
   * @generated from field: string decryption_secret_id = 6;
   */
  decryptionSecretId?: string;

  /**
   * The method used to decrypt the session key. May be unset if the session key is not set or not used.
   *
   * @generated from field: io.clbs.openhes.models.crypto.SecretSessionKeyDecryptionMethod session_key_decryption_method = 7;
   */
  sessionKeyDecryptionMethod?: SecretSessionKeyDecryptionMethodJson;

  /**
   * The session key (usually encrypted) used to decrypt the data.
   *
   * @generated from field: bytes session_key = 8;
   */
  sessionKey?: string;

  /**
   * The method used to decrypt the secret data. May be unset if the data is not encrypted.
   *
   * @generated from field: io.clbs.openhes.models.crypto.SecretDataDecryptionMethod data_decryption_method = 9;
   */
  dataDecryptionMethod?: SecretDataDecryptionMethodJson;

  /**
   * The initialization vector for the decryption method, if applicable.
   *
   * @generated from field: bytes data_decryption_iv = 10;
   */
  dataDecryptionIv?: string;

  /**
   * The secret data.
   *
   * @generated from field: bytes data = 15;
   */
  data?: string;
};

/**
 * Describes the message io.clbs.openhes.models.crypto.SetCryptoSecretRequest.
 * Use `create(SetCryptoSecretRequestSchema)` to create a new message.
 */
export const SetCryptoSecretRequestSchema: GenMessage<SetCryptoSecretRequest, {jsonType: SetCryptoSecretRequestJson}> = /*@__PURE__*/
  messageDesc(file_crypto_management, 3);

/**
 * Defines the supported decryption methods for cryptographic secret data.
 * These methods are used to decrypt device authentication keys and other sensitive credentials.
 *
 * @generated from enum io.clbs.openhes.models.crypto.SecretDataDecryptionMethod
 */
export enum SecretDataDecryptionMethod {
  /**
   * Unspecified decryption method (invalid, should not be used).
   *
   * @generated from enum value: SECRET_DATA_UNSPECIFIED = 0;
   */
  SECRET_DATA_UNSPECIFIED = 0,

  /**
   * Data is stored in plain text without encryption (not recommended for production).
   *
   * @generated from enum value: SECRET_DATA_PLAIN = 1;
   */
  SECRET_DATA_PLAIN = 1,

  /**
   * Data is encrypted using AES-256 in CBC mode. Requires an initialization vector.
   *
   * @generated from enum value: SECRET_DATA_AES256CBC = 2;
   */
  SECRET_DATA_AES256CBC = 2,
}

/**
 * Defines the supported decryption methods for cryptographic secret data.
 * These methods are used to decrypt device authentication keys and other sensitive credentials.
 *
 * @generated from enum io.clbs.openhes.models.crypto.SecretDataDecryptionMethod
 */
export type SecretDataDecryptionMethodJson = "SECRET_DATA_UNSPECIFIED" | "SECRET_DATA_PLAIN" | "SECRET_DATA_AES256CBC";

/**
 * Describes the enum io.clbs.openhes.models.crypto.SecretDataDecryptionMethod.
 */
export const SecretDataDecryptionMethodSchema: GenEnum<SecretDataDecryptionMethod, SecretDataDecryptionMethodJson> = /*@__PURE__*/
  enumDesc(file_crypto_management, 0);

/**
 * Defines the supported decryption methods for session keys used in key wrapping scenarios.
 * Session keys provide an additional layer of security for protecting cryptographic secrets.
 *
 * @generated from enum io.clbs.openhes.models.crypto.SecretSessionKeyDecryptionMethod
 */
export enum SecretSessionKeyDecryptionMethod {
  /**
   * No session key is used. The secret data is encrypted directly with the master key.
   *
   * @generated from enum value: SECRET_SESSION_UNSPECIFIED = 0;
   */
  SECRET_SESSION_UNSPECIFIED = 0,

  /**
   * Session key is stored in plain text (used when the session key itself is not sensitive).
   *
   * @generated from enum value: SECRET_SESSION_PLAIN = 1;
   */
  SECRET_SESSION_PLAIN = 1,

  /**
   * Session key is encrypted using RSA-OAEP with MGF1 and SHA-1. Used for secure key transport.
   *
   * @generated from enum value: SECRET_SESSION_RSA_OAEPM_GF1P = 2;
   */
  SECRET_SESSION_RSA_OAEPM_GF1P = 2,
}

/**
 * Defines the supported decryption methods for session keys used in key wrapping scenarios.
 * Session keys provide an additional layer of security for protecting cryptographic secrets.
 *
 * @generated from enum io.clbs.openhes.models.crypto.SecretSessionKeyDecryptionMethod
 */
export type SecretSessionKeyDecryptionMethodJson = "SECRET_SESSION_UNSPECIFIED" | "SECRET_SESSION_PLAIN" | "SECRET_SESSION_RSA_OAEPM_GF1P";

/**
 * Describes the enum io.clbs.openhes.models.crypto.SecretSessionKeyDecryptionMethod.
 */
export const SecretSessionKeyDecryptionMethodSchema: GenEnum<SecretSessionKeyDecryptionMethod, SecretSessionKeyDecryptionMethodJson> = /*@__PURE__*/
  enumDesc(file_crypto_management, 1);

