# Code generated, DO NOT EDIT.

# `NullValue` is a singleton enumeration to represent the null value for the
#  `Value` type union.
#
#  The JSON representation for `NullValue` is JSON `null`.
enum NullValue {
  # Null value.
  NULL_VALUE
}

# Result codes related to job actions
enum ActionResultCode {
  # The action has been completed successfully.
  ERROR_CODE_ACTION_OK
  # The action is not supported by the driver (or device).
  ERROR_CODE_ACTION_UNSUPPORTED
  # The action is pending.
  ERROR_CODE_ACTION_PENDING
  # The action failed.
  ERROR_CODE_ACTION_ERROR
}

# Action types
enum ActionType {
  # Get register value, for example instantaneous values. The action covers specific register.
  ACTION_TYPE_GET_REGISTER
  # Get periodical profile, for example load-profile. The action covers specific profile column.
  ACTION_TYPE_GET_PERIODICAL_PROFILE
  # Get non-periodical profile, for example daily profile or monthly billing registers. The action covers specific profile column and or specific billing register.
  ACTION_TYPE_GET_IRREGULAR_PROFILE
  # Get event log. The action covers specific event log.
  ACTION_TYPE_GET_EVENTS
  # Get device info. The action returns info data about remote device.
  ACTION_TYPE_GET_DEVICE_INFO
  # Synchronize clock. The action synchronizes the time in the device, it can forcefully set it if force attribute is set.
  ACTION_TYPE_SYNC_CLOCK
  # Set relay state. The action covers single relay.
  ACTION_TYPE_SET_RELAY_STATE
  # Get disconnector state. The action covers single disconnector if multiple disconnectors are present in the device.
  ACTION_TYPE_GET_DISCONNECTOR_STATE
  # Set disconnector state. The action covers single relay. The action covers single disconnector if multiple disconnectors are present in the device.
  ACTION_TYPE_SET_DISCONNECTOR_STATE
  # Get time-of-use table.
  ACTION_TYPE_GET_TOU
  # Set time-of-use table.
  ACTION_TYPE_SET_TOU
  # Set limiter settings. The action covers single limiter.
  ACTION_TYPE_SET_LIMITER
  # Reset billing period.
  ACTION_TYPE_RESET_BILLING_PERIOD
  # Start firmware update. The action updates starts FW upgrade procedure.
  ACTION_TYPE_FW_UPDATE
}

# Application protocols
enum ApplicationProtocol {
  # The IEC 62056-21 (IEC-61107, VDEW) protocol.
  APPPROTO_IEC_62056_21
  # The DLMS short-name protocol.
  APPPROTO_DLMS_SN
  # The DLMS logical-name protocol.
  APPPROTO_DLMS_LN
  # The SCTM protocol.
  APPPROTO_SCTM
  # The LIS200 protocol.
  APPPROTO_LIS200
  # The ANSI C12 protocol.
  APPPROTO_ANSI_C12
  # The MQTT protocol.
  APPPROTO_MQTT
  # The MODBUS procotocol.
  APPPROTO_MODBUS
  # The MBUS protocol.
  APPPROTO_MBUS
}

# Bulk statuses
enum BulkStatusCode {
  # The job is waiting in the queue
  BULK_STATUS_QUEUED
  # The job is running
  BULK_STATUS_RUNNING
  # The job is completed
  BULK_STATUS_COMPLETED
  # The job is cancelled
  BULK_STATUS_CANCELLED
  # The job has expired
  BULK_STATUS_EXPIRED
}

# Connection types
enum CommunicationType {
  # The communication is done via direct TCP/IP.
  COMMUNICATION_TYPE_TCPIP
  # The communication is done via phone line (modem).
  COMMUNICATION_TYPE_MODEM_POOL
  # The communication is done via direct serial line.
  COMMUNICATION_TYPE_SERIAL_LINE_DIRECT
  # The communication is done via controller-serial line (Moxa).
  COMMUNICATION_TYPE_SERIAL_LINE_MOXA
  # The communication is passive, the driver is a service that listens on a port (DLMS devices in push mode) or a service that implements a subscriber to a message queue (e.g. MQTT).
  COMMUNICATION_TYPE_LISTENING
}

# Data link protocols
enum DataLinkProtocol {
  # The VDEW (IEC 62056-21, IEC-61107) protocol. In combination with DLMS protocol the driver initiates the communication by IEC and switches to the mode E to the HDLC+DLMS protocol. Supports addressing = multiple devices on the same line.
  LINKPROTO_IEC_62056_21
  # The HDLC (ISO/IEC-3309) framing. It can be used for various application protocols, such as DLMS or MODBUS. Supports client/server addressing = multiple devices on the same line.
  LINKPROTO_HDLC
  # The COSEM wrapper. It can be used for DLMS application protocol. Supports client/server addressing = multiple devices on the same line.
  LINKPROTO_COSEM_WRAPPER
  # The Modbus protocol. It shall be used for Modbus application protocol where no other data link layer, such as HDLC, is used.
  LINKPROTO_MODBUS
  # The M-Bus protocol. It shall be used for M-Bus application protocol.
  LINKPROTO_MBUS
  # The Viktor protocol. It is a proprietary protocol used by Viktor-based devices, such as DC450 Vitkor.
  LINKPROTO_VIKTOR
  # The data link protocol is not applicable. It's useful for listening communication type.
  LINKPROTO_NOT_APPLICABLE
}

# Error codes related to jobs
enum JobErrorCode {
  # The job has been completed successfully.
  JOB_ERROR_CODE_NONE
  # There is no free slot in the driver to handle the job; the job shall be send again later.
  JOB_ERROR_CODE_BUSY
  # The job failed, the retry will be attempted.
  JOB_ERROR_CODE_ERROR
  # This should never happen! It means that the same job is currently being processed by the driver and it was sent to the driver mutliple times which would mean that there is a bug.
  JOB_ERROR_CODE_ALREADY_EXISTS
  # The job failed, the retry will NOT be attempted.
  JOB_ERROR_CODE_FATAL
}

# Job priorities
enum JobPriority {
  # The lowest priority
  JOB_PRIORITY_0
  # The priority 1
  JOB_PRIORITY_1
  # The priority 2
  JOB_PRIORITY_2
  # The priority 3
  JOB_PRIORITY_3
  # The priority 4
  JOB_PRIORITY_4
  # The priority 5
  JOB_PRIORITY_5
  # The priority 6
  JOB_PRIORITY_6
  # The priority 7
  JOB_PRIORITY_7
  # The highest priority
  JOB_PRIORITY_8
}

# Job statuses
enum JobStatusCode {
  # The job is waiting in the queue
  JOB_STATUS_QUEUED
  # The job is running
  JOB_STATUS_RUNNING
  # The data has been fully acquired and is being processed
  JOB_STATUS_PROCESSING_DATA
  # The job is completed
  JOB_STATUS_COMPLETED
  # The job is failed
  JOB_STATUS_FAILED
  # The job is cancelled
  JOB_STATUS_CANCELLED
  # The job has expired
  JOB_STATUS_EXPIRED
}

enum RegisterType {
  # The register is a generic register.
  Register
  # The register is part of a periodical profile.
  PeriodicalProfile
  # The register is part of an irregular profile.
  IrregularProfile
  # Synthetic register, not visible by drivers. It can be defined to store derived or external data.
  Synthetic
}

enum TopologyNodeType {
  # The node is a device, such as an electricity meter.
  TOPOLOGY_NODE_DEVICE
  # The node is a communication unit, such as a modem or a data concentrator.
  TOPOLOGY_NODE_COMMUNICATION_UNIT
}

# Enumeration for Relay State
enum RelayState {
  # Relay state is ignored (no action)
  NOOP
  # Relay connects
  CONNECT
  # Relay disconnects
  DISCONNECT
}

# Enum representing the field data type.
enum FieldDataType {
  # The text data type.
  TEXT
  # The integer data type.
  INTEGER
  # The double data type.
  DOUBLE
  # The binary data type.
  BINARY
  # The boolean data type.
  BOOLEAN
  # The timestamp data type, represented by google.protobuf.Timestamp.
  TIMESTAMP
  # The duration data type, represented by google.protobuf.Duration.
  DURATION
}

# Enum representing the field display format.
enum FieldDisplayFormat {
  # The default display format. The GUI shows text, int, double, date-time or duration in the default format.
  DEFAULT
  # The date-only display format of local date-time. Data type must be TIMESTAMP or string.
  DATE_ONLY
  # The date-time display format with in UTC timezone. Data type must be TIMESTAMP or string.
  UTC_DATETIME
  # The date display format with in UTC timezone. Data type must be TIMESTAMP or string.
  UTC_DATE_ONLY
  # The time of day display format hh:mm:ss, e.g. 12:30:00. Data type must be INTEGER in milliseconds.
  TIMEOFDAY
  # The money display format. The unit must be set to the currency code, ISO 4217 standard (e.g. USD, EUR, ...). Data type must be DOUBLE or INTEGER.
  MONEY
  # The password display format. Data type must be TEXT. The GUI must always display six starts (******) not to reveal the actual password length.
  PASSWORD
  # The multiline-string display format. Data type must be TEXT.
  MULTILINE
  # The combo-box display style & format. Data type must be TEXT. The GUI must display the value as a combo-box with the list of options.
  COMBO
}

# The filter operator.
enum FilterOperator {
  # Single operand operator for text, integer, number, boolean, date fields.
  EQUAL
  # Single operand operator for text, integer, number, boolean, date fields.
  NOT_EQUAL
  # Single operand operator for integer, number, date fields.
  GREATER_THAN
  # Single operand operator for integer, number, date fields.
  GREATER_THAN_OR_EQUAL
  # Single operand operator for integer, number, date fields.
  LESS_THAN
  # Single operand operator for integer, number, date fields.
  LESS_THAN_OR_EQUAL
  # Single operand operator for text fields.
  CONTAINS
  # Single operand operator for text fields.
  NOT_CONTAINS
  # Single operand operator for text fields.
  STARTS_WITH
  # Single operand operator for text fields.
  ENDS_WITH
  # Multiple operand operator for text, integer, number, boolean fields.
  IN
  # Multiple operand operator for text, integer, number, boolean fields.
  NOT_IN
  # Two operand operator for integer, number, date fields.
  BETWEEN
  # No operand operator. For both null and empty string.
  IS_NULL
  # No operand operator. For both null and empty string.
  IS_NOT_NULL
}

# Enum representing the object type.
enum ObjectType {
  # The bulk.
  BULK
  # The bulk job.
  BULK_JOB
  # The communication unit.
  COMMUNICATION_UNIT
  # The device.
  DEVICE
  # The register.
  REGISTER
  # The variable.
  VARIABLE
  # The device template.
  DEVICE_TEMPLATE
  # The communication bus.
  COMMUNICATION_BUS
  # The modem pool.
  MODEM_POOL
  # The device group.
  DEVICE_GROUP
  # The time-of-use table.
  TIME_OF_USE_TABLE
  # The driver.
  DRIVER
  # The cron job.
  CRON_JOB
}

enum CronJobTypeEnum {
  # Cron job to start an acquistion bulk.
  CRON_JOB_TYPE_START_BULK
  # Cron job to start a proxy bulk.
  CRON_JOB_TYPE_START_PROXY_BULK
}

# A Duration represents a signed, fixed-length span of time represented
#  as a count of seconds and fractions of seconds at nanosecond
#  resolution. It is independent of any calendar and concepts like "day"
#  or "month". It is related to Timestamp in that the difference between
#  two Timestamp values is a Duration and it can be added or subtracted
#  from a Timestamp. Range is approximately +-10,000 years.
#
#  # Examples
#
#  Example 1: Compute Duration from two Timestamps in pseudo code.
#
#      Timestamp start = ...;
#      Timestamp end = ...;
#      Duration duration = ...;
#
#      duration.seconds = end.seconds - start.seconds;
#      duration.nanos = end.nanos - start.nanos;
#
#      if (duration.seconds < 0 && duration.nanos > 0) {
#        duration.seconds += 1;
#        duration.nanos -= 1000000000;
#      } else if (duration.seconds > 0 && duration.nanos < 0) {
#        duration.seconds -= 1;
#        duration.nanos += 1000000000;
#      }
#
#  Example 2: Compute Timestamp from Timestamp + Duration in pseudo code.
#
#      Timestamp start = ...;
#      Duration duration = ...;
#      Timestamp end = ...;
#
#      end.seconds = start.seconds + duration.seconds;
#      end.nanos = start.nanos + duration.nanos;
#
#      if (end.nanos < 0) {
#        end.seconds -= 1;
#        end.nanos += 1000000000;
#      } else if (end.nanos >= 1000000000) {
#        end.seconds += 1;
#        end.nanos -= 1000000000;
#      }
#
#  Example 3: Compute Duration from datetime.timedelta in Python.
#
#      td = datetime.timedelta(days=3, minutes=10)
#      duration = Duration()
#      duration.FromTimedelta(td)
#
#  # JSON Mapping
#
#  In JSON format, the Duration type is encoded as a string rather than an
#  object, where the string ends in the suffix "s" (indicating seconds) and
#  is preceded by the number of seconds, with nanoseconds expressed as
#  fractional seconds. For example, 3 seconds with 0 nanoseconds should be
#  encoded in JSON format as "3s", while 3 seconds and 1 nanosecond should
#  be expressed in JSON format as "3.000000001s", and 3 seconds and 1
#  microsecond should be expressed in JSON format as "3.000001s".
type Duration {
  # Signed seconds of the span of time. Must be from -315,576,000,000
  #  to +315,576,000,000 inclusive. Note: these bounds are computed from:
  #  60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
  seconds: Int64
  # Signed fractions of a second at nanosecond resolution of the span
  #  of time. Durations less than one second are represented with a 0
  #  `seconds` field and a positive or negative `nanos` field. For durations
  #  of one second or more, a non-zero value for the `nanos` field must be
  #  of the same sign as the `seconds` field. Must be from -999,999,999
  #  to +999,999,999 inclusive.
  nanos: Int
}

# A generic empty message that you can re-use to avoid defining duplicated
#  empty messages in your APIs. A typical example is to use it as the request
#  or the response type of an API method. For instance:
#
#      service Foo {
#        rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
#      }
type Empty {
  _empty: Boolean
}

# `ListValue` is a wrapper around a repeated field of values.
#
#  The JSON representation for `ListValue` is JSON array.
type ListValue {
  # Repeated field of dynamically typed values.
  values: [Value]
}

# Wrapper message for `string`.
#
#  The JSON representation for `StringValue` is JSON string.
#
#  Not recommended for use in new APIs, but still useful for legacy APIs and
#  has no plan to be removed.
type StringValue {
  # The string value.
  value: String
}

# `Struct` represents a structured data value, consisting of fields
#  which map to dynamically typed values. In some languages, `Struct`
#  might be supported by a native representation. For example, in
#  scripting languages like JS a struct is represented as an
#  object. The details of that representation are described together
#  with the proto support for the language.
#
#  The JSON representation for `Struct` is JSON object.
type Struct {
  # Unordered map of dynamically typed values.
  fields: [_mapValue]
}

# `Value` represents a dynamically typed value which can be either
#  null, a number, a string, a boolean, a recursive struct value, or a
#  list of values. A producer of value is expected to set one of these
#  variants. Absence of any variant indicates an error.
#
#  The JSON representation for `Value` is JSON value.
type Value {
  # Represents a null value.
  nullValue: NullValue
  # Represents a double value.
  numberValue: Float
  # Represents a string value.
  stringValue: String
  # Represents a boolean value.
  boolValue: Boolean
  # Represents a structured value.
  structValue: Struct
  # Represents a repeated `Value`.
  listValue: ListValue
}

# Represents a whole or partial calendar date, such as a birthday. The time of
#  day and time zone are either specified elsewhere or are insignificant. The
#  date is relative to the Gregorian Calendar. This can represent one of the
#  following:
#
#  * A full date, with non-zero year, month, and day values
#  * A month and day value, with a zero year, such as an anniversary
#  * A year on its own, with zero month and day values
#  * A year and month value, with a zero day, such as a credit card expiration
#  date
#
#  Related types are [google.type.TimeOfDay][google.type.TimeOfDay] and
#  `google.protobuf.Timestamp`.
type Date {
  # Year of the date. Must be from 1 to 9999, or 0 to specify a date without
  #  a year.
  year: Int
  # Month of a year. Must be from 1 to 12, or 0 to specify a year without a
  #  month and day.
  month: Int
  # Day of a month. Must be from 1 to 31 and valid for the year and month, or 0
  #  to specify a year by itself or a year and month where the day isn't
  #  significant.
  day: Int
}

# Sub-message containing access level definition
type AccessLevelTemplate {
  # The access level identifier, such as "1", "G", "16" or similar.
  id: String
  # The access level name. Should be in English and unique for given driver, e.g. "Management", "Public".
  name: String
}

# Sub-message containing action-based variant of data values
type ActionData {
  # No data
  nodata: Empty
  # Register values
  registers: RegisterValues
  # Profile values
  profile: ProfileValues
  # Irregular (non-periodical) profile values, e.g. daily profile
  irregularProfile: IrregularProfileValues
  # Device info
  deviceInfo: DeviceInfo
  # Event records
  events: EventRecords
  # The time-of-use table.
  touTable: TimeOfUseTableSpec
}

# Sub-message containing firmware update action specification
type ActionFwUpdate {
  _empty: Boolean
}

# Sub-message containing get device info action specification
type ActionGetDeviceInfo {
  _empty: Boolean
}

# Sub-message containing get events action specification
type ActionGetEvents {
  # The start timestamp of the profile.
  from: Timestamp
  # The end timestamp of the profile.
  to: Timestamp
}

# Sub-message containing get irregular profile action specification
type ActionGetIrregularProfile {
  # The start timestamp of the profile.
  from: Timestamp
  # The end timestamp of the profile.
  to: Timestamp
  # The data type of the target register, e.g. integer, double, string, timestamp, etc. This value can be specified for proxy bulk, while it's automatically taken from the register definition in the system for bulks.
  dataType: FieldDataType
}

# Sub-message containing get periodical profile action specification
type ActionGetPeriodicalProfile {
  # The start timestamp of the profile.
  from: Timestamp
  # The end timestamp of the profile.
  to: Timestamp
  # The data type of the target register, e.g. integer, double, string, timestamp, etc. This value can be specified for proxy bulk, while it's automatically taken from the register definition in the system for bulks.
  dataType: FieldDataType
}

# Sub-message containing get register action specification
type ActionGetRegister {
  # The data type of the target register, e.g. integer, double, string, timestamp, etc. This value can be specified for proxy bulk, while it's automatically taken from the register definition in the system for bulks.
  dataType: FieldDataType
}

# Sub-message containing get tou action specification
type ActionGetTou {
  # Identifies whether to read passive TOU table. By default it is set to false to read active TOU table.
  passive: Boolean
}

# Sub-message containing reset billing period action specification
type ActionResetBillingPeriod {
  _empty: Boolean
}

# Sub-message containing action result for a single action.
type ActionResult {
  # The action identifier.
  actionId: String
  # The status of the action.
  status: ActionResultCode
  # The action result data.
  data: ActionData
  # The register identifier. It is a read-only value, set only if the action data are related to a register. The value is applicable only and only for results for regular bulks.
  registerId: String
  # The variable name(s). It is a read-only value, set only if the action data are related to one or more variables based on device template mapping. The value is applicable only and only for results for regular bulks.
  variableName: [String]
}

# Sub-message containing set disconnector state action specification
type ActionSetDisconnectorState {
  _empty: Boolean
}

# Sub-message containing set limiter action specification
type ActionSetLimiter {
  _empty: Boolean
}

# Sub-message containing set relay state action specification
type ActionSetRelayState {
  _empty: Boolean
}

# Sub-message containing set tou action specification
type ActionSetTou {
  # The time-of-use table to be set.
  table: TimeOfUseTableSpec
}

# Sub-message containing sync clock action specification
type ActionSyncClock {
  _empty: Boolean
}

type AddCommunicationUnitsToCommunicationBusRequest {
  # The unique identifier of the communication bus.
  communicationBusId: String
  # The unique identifier of the communication unit.
  communicationUnitId: [String]
}

type AddDeviceConfigurationRegisterToDeviceConfigurationTemplateRequest {
  # The identifier of the device configuration template.
  dctId: String
  # The list of register identifiers to be linked to the template.
  registerId: [String]
}

type AddDevicesToGroupRequest {
  # The unique identifier of the device group.
  groupId: String
  # The unique identifier of the device.
  deviceId: [String]
}

type AddRegisterToVariableRequest {
  # The unique identifier of the variable.
  variableId: String
  # The list of register identifiers to be linked to the variable.
  registerId: [String]
}

# Sub-message containing destription for one application protocol, e.g. DLMS_SN.
type ApplicationProtocolTemplate {
  # The application protocol.
  protocol: ApplicationProtocol
  # The list of attribute definitions for the application protocol and those will be instantiated for each device & communication unit pair.
  attributes: [FieldDescriptor]
}

type Bulk {
  # The bulk-job spec.
  spec: BulkSpec
  # The bulk-job status/data.
  status: BulkStatus
  # The metadata fields.
  metadata: MetadataFields
}

type BulkJob {
  # The job spec.
  spec: BulkJobSpec
  # The job status.
  status: JobStatus
  # The metadata fields.
  metadata: MetadataFields
}

type BulkJobSpec {
  # The device info.
  device: JobDevice
}

type BulkSpec {
  # The correlation identifier, e.g. to define relation to non-homogenous group.
  correlationId: UUID
  # The list of devices in the bulk.
  devices: ListOfJobDeviceId
  # The device group identifier.
  deviceGroupId: String
  # The bulk-shared job settings.
  settings: JobSettings
  # The list actions to be executed.
  actions: [JobActionSet]
  # The webhook URL to call when the bulk is completed.
  webhookUrl: String
}

type BulkStatus {
  # The job status.
  status: BulkStatusCode
  # The number of jobs in the bulk.
  jobsCount: Int
  # The number of jobs finished.
  jobsFinished: Int
  # The number of jobs successful.
  jobsSuccessful: Int
  # The creation timestamp of the bulk.
  createdAt: Timestamp
  # The start timestamp of the bulk.
  startedAt: Timestamp
  # The finish timestamp of the bulk.
  finishedAt: Timestamp
}

type CommunicationBus {
  # The communication bus status.
  status: CommunicationBusStatus
  # The metadata fields.
  metadata: MetadataFields
}

type CommunicationBusStatus {
  # The list of communication unit identifiers.
  communicationUnitId: [String]
}

# Sub-message containing destription for one communication type, e.g. TCP/IP.
type CommunicationTemplate {
  # The type of the communication.
  type: CommunicationType
  # The list of data link protocols and their app protocols supported by the driver.
  datalinks: [DataLinkTemplate]
}

type CommunicationUnit {
  # The communication unit specification.
  spec: CommunicationUnitSpec
  # The metadata fields.
  metadata: MetadataFields
}

type CommunicationUnitSpec {
  # The external identifier of the communication unit.
  externalId: String
  # The connection info.
  connectionInfo: ConnectionInfo
}

# Sub-message containing connection info
type ConnectionInfo {
  # The TCP connection type.
  tcpip: ConnectionTypeDirectTcpIp
  # The phone connection type.
  modemPool: ConnectionTypeModemPool
  # The serial over IP connection type.
  serialOverIp: ConnectionTypeControlledSerial
  # The data link protocol.
  linkProtocol: DataLinkProtocol
  # The communication bus identifier. It behaves as a custom grouping key to link jobs together across multiple communication units. It shall be used in a situation when multiple entry points share single communication bus, e.g. multi-master RS-485 (primary and backup master). If not set then jobs are grouped by group-key defined based on the connection type.
  communicationBusId: String
  # The connection attributes, see GetDataLinkFields in the acquisition package.
  attributes: [_mapFieldValue]
}

# Sub-message containing connection info for controlled-serial line over IP (e.g. Moxa) connection type
type ConnectionTypeControlledSerial {
  # The simple direct serial connection type.
  direct: ConnectionTypeSerialDirect
  # The Moxa connection type.
  moxa: ConnectionTypeSerialMoxa
  # The RFC 2217 connection type.
  rfc2217: ConnectionTypeSerialRfc2217
}

# Sub-message containing connection info for TCP connection type
type ConnectionTypeDirectTcpIp {
  # The host name or IP address of the device to connect to.
  host: String
  # The TCP port number of the device to connect to.
  port: Int
  # The timeout for TCP/IP connection.
  timeout: Duration
}

# Sub-message containing connection info for phone line (modem) connection type
type ConnectionTypeModemPool {
  # The phone number of the device to connect to.
  number: String
  # The modem pool identifier. The pool is a group of modems that can be used to connect to the device. Final modem is selected by the Taskmaster at the time of the job start.
  poolId: String
  # The modem device assigned to the job. This is filled only and only when the connection type is modem. The value is assigned by the Taskmaster when to job is being started. Driver is required to use this modem device to connect to the meter only and only for the time of this job!
  modem: ModemInfo
}

type ConnectionTypeSerialDirect {
  # The host name or IP address of the device to connect to.
  host: String
  # The TCP port number of the device to connect to.
  port: Int
  # The timeout for direct serial port connection.
  timeout: Duration
}

# Sub-message containing connection info for controlled-serial line (Moxa) connection type
type ConnectionTypeSerialMoxa {
  # The host name or IP address of the device to connect to.
  host: String
  # The TCP port number of the device to connect to - data port.
  dataPort: Int
  # The TCP port number of the device to connect to - command port.
  commandPort: Int
  # The timeout for serial port connection that implements the Moxa protocol.
  timeout: Duration
}

# Sub-message containing connection info for controlled-serial line (RFC 2217) connection type
type ConnectionTypeSerialRfc2217 {
  # The host name or IP address of the device to connect to.
  host: String
  # The TCP port number of the device to connect to.
  port: Int
  # The timeout for serial port connection that implements the RFC 2217 protocol.
  timeout: Duration
}

type CreateBulkRequest {
  # The bulk-job spec.
  spec: BulkSpec
  # The metadata fields.
  metadata: MetadataFields
}

type CreateCommunicationBusRequest {
  # The metadata fields.
  metadata: MetadataFields
}

type CreateCommunicationUnitRequest {
  # The communication unit specification.
  spec: CommunicationUnitSpec
  # The metadata fields.
  metadata: MetadataFields
}

type CreateDeviceConfigurationRegisterRequest {
  # The register specification.
  spec: DeviceConfigurationRegisterSpec
  # The metadata fields.
  metadata: MetadataFields
}

type CreateDeviceConfigurationTemplateRequest {
  # The device configuration template specification.
  spec: DeviceConfigurationTemplateSpec
  # The metadata fields.
  metadata: MetadataFields
}

type CreateDeviceGroupRequest {
  # The device group specification.
  spec: DeviceGroupSpec
  # The metadata fields.
  metadata: MetadataFields
}

type CreateDeviceRequest {
  # The device specification.
  spec: DeviceSpec
  # The metadata fields.
  metadata: MetadataFields
}

type CreateProxyBulkRequest {
  # The proxy bulk-job spec.
  spec: ProxyBulkSpec
  # The metadata fields.
  metadata: MetadataFields
}

type CreateTimeOfUseTableRequest {
  # The time-of-use table specification.
  spec: TimeOfUseTableSpec
  # The metadata fields.
  metadata: MetadataFields
}

type CreateVariableRequest {
  # The variable specification.
  spec: VariableSpec
  # The metadata fields.
  metadata: MetadataFields
}

# Sub-message containing destription for one data link protocol, e.g. HDLC.
type DataLinkTemplate {
  # The data link protocol.
  linkProtocol: DataLinkProtocol
  # The list of application protocol identifiers supported by the driver.
  appProtocolRefs: [ApplicationProtocol]
  # The list of attribute definitions related to given data link type (see link_protocol property). The field definitions are taken from the system, drivers must leave this empty.
  attributes: [FieldDescriptor]
}

type Device {
  # The device specification.
  spec: DeviceSpec
  # The device status.
  status: DeviceStatus
  # The metadata fields.
  metadata: MetadataFields
}

type DeviceCommunicationUnit {
  # The unique identifier of the communication unit.
  communicationUnitId: String
  # The application protocol to be used for the communication over the communication unit.
  appProtocol: ApplicationProtocol
  # The app-protocol related device attributes. It is represented as a list of attribute definitions.
  attributes: [_mapFieldValue]
}

type DeviceCommunicationUnitChange {
  # The device communication unit changes status.
  status: DeviceCommunicationUnitChangeStatus
}

type DeviceCommunicationUnitChangeStatus {
  # The timestamp of the change.
  changeAt: Timestamp
  # The unique identifier of the communication unit.
  communicationUnitId: String
  # The unique identifier of the device.
  deviceId: String
}

type DeviceConfigurationRegister {
  # The register specification.
  spec: DeviceConfigurationRegisterSpec
  # The metadata fields.
  metadata: MetadataFields
}

type DeviceConfigurationRegisterSpec {
  # The device (driver) type.
  driverType: String
  # The type of action for which the register is defined.
  registerType: RegisterType
  # The field values.
  attributes: [_mapFieldValue]
  # The data type of the register;
  dataType: FieldDataType
}

type DeviceConfigurationTemplate {
  # The device configuration template specification.
  spec: DeviceConfigurationTemplateSpec
  # The metadata fields.
  metadata: MetadataFields
}

type DeviceConfigurationTemplateSpec {
  # The device (driver) type.
  driverType: String
  # The list of device configuration register identifiers.
  registerId: [String]
}

type DeviceData {
  # The list of device data items.
  devices: [DeviceDeviceData]
}

type DeviceDeviceData {
  # The unique identifier of the device.
  deviceId: String
  # The list of variable data items.
  data: [VariableDeviceData]
}

type DeviceGroup {
  # The device group specification.
  spec: DeviceGroupSpec
  # The metadata fields.
  metadata: MetadataFields
}

type DeviceGroupSpec {
  # The external identifier of the communication unit.
  externalId: String
}

# Message holds common device information.
type DeviceInfo {
  # The timestamp when the values were read.
  infoTimestamp: Timestamp
  # The serial number of the device set by manufacturer. Typical source: 0-0:42.0.0.255
  manufacturerSerialNumber: String
  # The device serial number of the device.  Typical source: 0-0:96.1.0.255
  deviceSerialNumber: String
  # The firmware version identifier of the device. Typical source: 0-0:0.2.0.255
  firmwareVersion: String
  # The clock delta against acquisition server clock (got by a driver) where positive value means that the device clock is ahead of local clock and vice versa.
  clockDelta: Duration
  # The model of the device.
  deviceModel: String
  # The error register 0. Typical source: 0-0:97.97.1.255 (higher 32-bit) + 0-0:97.97.0.255 (lower 32-bit)
  errorRegister: BigInt
  # The list of relay states. The order of the relays is the same as in the device. The value is true if the relay is connected and false if the relay is disconnected.
  relayStates: [Boolean]
  # The state of the connection. It represents the disconnector state where true means that the customer is connected and false means that the customer is disconnected.
  connectionState: Boolean
}

# Sub-message - the device specification.
type DeviceSpec {
  # The device configuration template identifier.
  dctId: UUID
  # The external identifier of the device.
  externalId: String
  # The list of communication unit identifiers (and additional info) that set CUs usable to communicate with the device. It's an ordered set where the first element is the primary communication unit with the highest priority.
  communicationUnitLink: [DeviceCommunicationUnit]
  # The timezone related to the device, e.g. "America/New_York", "Europe/Prague", "CET", "GMT", "Etc/GMT+2".
  timezone: String
}

type DeviceStatus {
  # The device info.
  info: DeviceInfo
  # The driver type selecte by it's device configuration template.
  driverType: String
}

type Driver {
  # The driver specification.
  spec: DriverSpec
  # The driver status.
  status: DriverStatus
}

type DriverSpec {
  # The driver version. The format is not defined. The driver itself is versioned by the docker image tags so this value shall be either the same (set during the image build) or any useful user-readable version string.
  version: String
  # The port the driver's gRPC will listen on.
  listeningPort: Int
  # The technical/internal ID of the driver.
  driverType: String
  # The maximum number of concurrent jobs the driver can handle. The value 0 is not allowed, the maximum number respect typical_mem_usage not to overgrow the memory resources!
  maxConcurrentJobs: Int
  # The maximum cascade depth the driver can handle. Number 1 means that the driver cannot handle cascading jobs, 2 means that the driver can handle cascading jobs with one level of depth, etc.
  #  The value 0 means that the driver can handle any number of cascading jobs.
  maxCascadeDepth: Int
  # The typical memory usage of the driver in MB.
  typicalMemUsage: Int
  # The connection and action templates.
  templates: DriverTemplates
  # The display name of the driver. Must be in format '<manufacturer> <device_type> [<device_type_version>]'.
  #  It must respect upper/lower characters.
  #  The generic drivers, such as 'cybros labs generic', must be named as '<driver_company_name> generic'.
  #
  #  Examples: 'Addax NP73E', 'cybros labs generic', 'Landis+Gyr S650 v2'
  displayName: String
}

type DriverStatus {
  # Whether the driver is the latest installed version in the system. Note that this does not mean that the driver is the latest released version!
  isLatest: Boolean
  # Whether the driver update from previous version (if any) has been finished.
  updateFinished: Boolean
}

# Sub-message in driver negotiation request
type DriverTemplates {
  # The templates of the communication options. Every template represents an option how the drivers allows to communicate. The driver can support multiple communication templates.
  communicationTemplates: [CommunicationTemplate]
  # The templates of the application protocols supported by the driver.
  appProtocols: [ApplicationProtocolTemplate]
  # The templates of the job actions for all supported action types. It must contain every action type supported by the driver once and only once.
  actionAttributes: [JobActionAttributes]
  # The templates of the access levels supported by the driver.
  accessTemplates: [AccessLevelTemplate]
  # The templates of the job actions constraints.
  actionConstraints: JobActionContraints
  # The list of descriptors related to the uknown devices visible to the communication unit.
  #  This relates only to the drivers that communications with a device like data-concentrator that can provide information for unknown devices.
  #  The descripts must cover all data attributes which drivers sets in the SetUnknownDevicesRequest message.
  uknownDeviceDescriptors: [FieldDescriptor]
}

# Sub-message describing a single event.
type EventRecord {
  # The timestamp of the event.
  timestamp: Timestamp
  # The identifier of the event.
  eventId: Int64
  # The code of the event as generated by the device.
  eventCode: Int64
  # The text of the event.
  eventText: String
  # The event source.
  eventSource: String
}

# Sub-message containing event records
type EventRecords {
  # The list of events.
  values: [EventRecord]
}

type GetDeviceDataRequest {
  # The start timestamp of the data.
  from: Timestamp
  # The end timestamp of the data.
  to: Timestamp
  # One or more identifiers of the devices.
  series: [GetDeviceDataSeriesSelector]
  # The filter status bits, only values with these status bits will be returned in the response.
  filterIncludeStatus: Int64
  # The filter status bits, only values without these status bits will be returned in the response.
  filterExcludeStatus: Int64
  # If set, the system will return a snapshot from the given point in time, e.g. what has been stored in the system yesterday.
  snapshot: Timestamp
}

type GetDeviceDataSeriesSelector {
  # The unique identifier of the device.
  deviceId: String
  # The unique identifier of the variable.
  variableId: String
}

type GetDeviceEventsRequest {
  # The start timestamp of the data.
  from: Timestamp
  # The end timestamp of the data.
  to: Timestamp
}

type IrregularProfileValues {
  # The unit of the profile values.
  unit: String
  # The list of continuous profile blocks.
  values: [IrregularValue]
}

type IrregularValue {
  # The timestamp of the value.
  timestamp: Timestamp
  # The value.
  value: MeasuredValue
}

# Sub-message containing job action specification.
#  The JobAction is used to define a single action to be performed on a single device.
#  For example, if the JobAction is of the ActionGetRegister type then it specifies single register to be read from the devices.
type JobAction {
  # The action identifier.
  actionId: String
  # The action attributes.
  attributes: [_mapFieldValue]
  # The get register action specification.
  getRegister: ActionGetRegister
  # The get periodical profile action specification.
  getPeriodicalProfile: ActionGetPeriodicalProfile
  # The get irregular profile action specification.
  getIrregularProfile: ActionGetIrregularProfile
  # The get events action specification.
  getEvents: ActionGetEvents
  # The get device info action specification.
  getDeviceInfo: ActionGetDeviceInfo
  # The sync clock action specification.
  syncClock: ActionSyncClock
  # The set relay state action specification.
  setRelayState: ActionSetRelayState
  # The set disconnector state action specification.
  setDisconnectorState: ActionSetDisconnectorState
  # The get tou action specification.
  getTou: ActionGetTou
  # The set tou action specification.
  setTou: ActionSetTou
  # The set limiter action specification.
  setLimiter: ActionSetLimiter
  # The reset billing period action specification.
  resetBillingPeriod: ActionResetBillingPeriod
  # The firmware update action specification.
  fwUpdate: ActionFwUpdate
}

# Sub-message containing job action attributes
type JobActionAttributes {
  # The type of action for which this instance of the template is defined.
  type: ActionType
  # The template of the action attributes. It is represented as a list of attribute definitions.
  attributes: [FieldDescriptor]
}

# Sub-message containing constraints for job actions.
type JobActionContraints {
  # Contains all the register types & their names in the English language. For example: [gen]="Generic Register", [vqi]="Quality VQI Register"
  #  Action: ACTION_TYPE_GET_REGISTER
  getRegisterTypeName: [_mapstring]
  # Contains all the register types & their attributes. For example: [gen]=["attribute1", "attribute2"], [vqi]=["attribute1", "attribute3"]
  #  See JobActionAttributes for the attribute definitions.
  #  Action: ACTION_TYPE_GET_REGISTER
  getRegisterTypeAttributes: [_mapListOfString]
}

# Sub-message containing job action set specification.
#  In comparison the JobAction shall be used only once per bulk but internally it may cover multiple JobActions.
#  For example, if the JobActionSet is of the ActionGetRegister type and no variables filter is set
#  then then system gets all registers defined for active device configuration template and reads them all.
type JobActionSet {
  # The filter, meaning depends on the action.
  #  - GetRegister, GetPeriodicalProfile and GetIrregularProfile: It's the list of variable identifiers, e.g. "A+" defined in the system. If not set then all variables are read.
  #  - Others: Not applicable, ignored.
  variables: [String]
  # The get register action specification.
  getRegister: ActionGetRegister
  # The get periodical profile action specification.
  getPeriodicalProfile: ActionGetPeriodicalProfile
  # The get irregular profile action specification.
  getIrregularProfile: ActionGetIrregularProfile
  # The get events action specification.
  getEvents: ActionGetEvents
  # The get device info action specification.
  getDeviceInfo: ActionGetDeviceInfo
  # The sync clock action specification.
  syncClock: ActionSyncClock
  # The set relay state action specification.
  setRelayState: ActionSetRelayState
  # The set disconnector state action specification.
  setDisconnectorState: ActionSetDisconnectorState
  # The get tou action specification.
  getTou: ActionGetTou
  # The set tou action specification.
  setTou: ActionSetTou
  # The set limiter action specification.
  setLimiter: ActionSetLimiter
  # The reset billing period action specification.
  resetBillingPeriod: ActionResetBillingPeriod
  # The firmware update action specification.
  fwUpdate: ActionFwUpdate
}

# Sub-message representing a single job-device info.
type JobDevice {
  # The device's job identifier within the parent bulk.
  jobId: String
  # The device identifier. If set then all below is loaded from the device registry.
  deviceId: String
  # The external identifier.
  externalId: String
  # The connection attributes to the device, see options in the ApplicationProtocolTemplate for given application protocol (see app_protocol property).
  deviceAttributes: [_mapFieldValue]
  # The connection (device) parameters.
  connectionInfo: [ConnectionInfo]
  # The application protocol.
  appProtocol: ApplicationProtocol
  # The timezone related to the device, e.g. "America/New_York", "Europe/Prague", "CET", "GMT", "Etc/GMT+2".
  timezone: String
}

type JobDeviceId {
  # The device's job identifier within the parent bulk.
  jobId: String
  # The device identifier.
  deviceId: String
}

# Sub-message containing job parameters
type JobSettings {
  # Maximum duration of the job attempt. This is related to the real time for the driver.
  maxDuration: Duration
  # Priority of the job.
  priority: JobPriority
  # Maximum number of attempts, 1 is the minimum.
  attempts: [Int]
  # Delay between two attempts.
  retryDelay: Duration
  # Time to wait before starting the job.
  deferStart: Duration
  # The timestamp when the job expires.
  expiresAt: Timestamp
}

# Sub-message containing job status info
type JobStatus {
  # The status of the job.
  status: JobStatusCode
  # The error code of the job.
  code: JobErrorCode
  # The result data for all job actions.
  results: [ActionResult]
  # The start timestamp of the job.
  startedAt: Timestamp
  # The finish timestamp of the job.
  finishedAt: Timestamp
  # The number of attempts already done.
  attemptsDone: Int
  # The device info. It contains the data from the action ACTION_TYPE_GET_DEVICE_INFO.
  deviceInfo: DeviceInfo
  # The internal queue identifier set by the Taskmaster when the job is queued to process.
  queueId: Int64
}

type ListBulkJobsRequest {
  # The bulk identifier.
  bulkId: String
  # The list selector.
  selector: ListSelector
}

type ListDeviceGroupDevicesRequest {
  # The unique identifier of the device group.
  groupId: String
  # The list selector.
  selector: ListSelector
}

type ListOfBulk {
  # The list of bulks.
  items: [Bulk]
  # The total number of items.
  totalCount: Int
}

type ListOfBulkJob {
  # The list of jobs.
  items: [BulkJob]
  # The total number of items.
  totalCount: Int
}

type ListOfCommunicationBus {
  # The list of communication unit buses.
  items: [CommunicationBus]
  # The total number of items.
  totalCount: Int
}

type ListOfCommunicationUnit {
  # The communication unit specification.
  items: [CommunicationUnit]
  # The total number of items.
  totalCount: Int
}

type ListOfDevice {
  # The list of devices.
  items: [Device]
  # The total number of items.
  totalCount: Int
}

type ListOfDeviceCommunicationUnit {
  # The list of linked communication units.
  items: [DeviceCommunicationUnit]
  # The total number of items.
  totalCount: Int
}

type ListOfDeviceCommunicationUnitChange {
  # The list of device groups.
  items: [DeviceCommunicationUnitChange]
  # The total number of items.
  totalCount: Int
}

type ListOfDeviceConfigurationRegister {
  # The list of registers.
  items: [DeviceConfigurationRegister]
  # The total number of items.
  totalCount: Int
}

type ListOfDeviceConfigurationTemplate {
  # The list of device configuration templates.
  items: [DeviceConfigurationTemplate]
  # The total number of items.
  totalCount: Int
}

type ListOfDeviceGroup {
  # The list of device groups.
  items: [DeviceGroup]
  # The total number of items.
  totalCount: Int
}

type ListOfDriver {
  # The list of drivers.
  items: [Driver]
  # The total number of items.
  totalCount: Int
}

type ListOfJobDevice {
  # The list of devices in the bulk.
  list: [JobDevice]
  # The total number of items.
  totalCount: Int
}

type ListOfJobDeviceId {
  # The list of devices in the bulk.
  list: [JobDeviceId]
  # The total number of items.
  totalCount: Int
}

type ListOfModemPool {
  # The list of modem pools.
  items: [ModemPool]
  # The total number of items.
  totalCount: Int
}

type ListOfTimeOfUseTable {
  # The list of time-of-use tables.
  items: [TimeOfUseTable]
  # The total number of items.
  totalCount: Int
}

type ListOfVariable {
  # The list of variables.
  items: [Variable]
  # The total number of items.
  totalCount: Int
}

# Sub-message containing measured value
type MeasuredValue {
  # The status of the value.
  status: Int64
  # The exponent of the value. It's used to calculate the real value as value * 10^exponent for double and int values.
  exponent: Int
  # The double-typed value.
  doubleValue: Float
  # The integer-typed value.
  integerValue: Int64
  # The string-typed value.
  stringValue: String
  # The timestamp-typed value.
  timestampValue: Timestamp
  # The timestamp with timezone-typed value, stored as string in ISO-8601.
  timestampTzValue: String
  # The boolean-typed value.
  boolValue: Boolean
  # The normalized status of the value, see StatusBits enum for more details.
  nstatus: BigInt
  # The timestamp when the value (e.g. peak) was recorded. It's typically before the capture timestamp.
  peakTs: Timestamp
}

# Sub-message containing modem connection info
type ModemInfo {
  # The modem identifier. It is automatically generated during creation.
  modemId: String
  # The name of the modem.
  name: String
  # The modem initialization command, e.g. AT&FE0X3
  atInit: String
  # The modem dial command, e.g. ATD.
  atDial: String
  # The modem hangup command, e.g. ATH.
  atHangup: String
  # The modem escape command, e.g. +++.
  atEscape: String
  # The modem connection timeout, if applicable given by the modem_connection field.
  connectTimeout: Duration
  # The modem command timeout, if applicable given by the modem_connection field.
  commandTimeout: Duration
  # The TCP connection type. The modem has either TCP or there is a IP-to-serial converter which handles the serial configuration so no additional serial configuration is needed.
  tcpip: ConnectionTypeDirectTcpIp
  # The serial over IP connection type. The modem is connected behind an IP-to-serial converter and needs connection specific handling.
  serialOverIp: ConnectionTypeControlledSerial
  # The serial baud rate, if applicable given by the modem_connection field.
  serialBaudRate: Int
}

type ModemPool {
  # The modem pool specification.
  spec: ModemPoolSpec
  # The modem pool status.
  status: ModemPoolStatus
  # The metadata fields.
  metadata: MetadataFields
}

type ModemPoolSpec {
  _empty: Boolean
}

type ModemPoolStatus {
  # The list of modems in the pool.
  modems: [ModemInfo]
}

type NetworkMap {
  # Flat or hierarchical list of topology devices
  nodes: [TopologyNode]
  # The list of edges between the devices.
  edges: [TopologyEdge]
}

# Sub-message containing a single profile block
type ProfileBlock {
  # The start timestamp of the block.
  startTimestamp: Timestamp
  # The list of profile values. Values are ordered by timestamp.
  values: [MeasuredValue]
}

# Sub-message containing profile-typed values
type ProfileValues {
  # The period of the profile values.
  period: Int
  # The unit of the profile values.
  unit: String
  # The list of continuous profile blocks.
  blocks: [ProfileBlock]
}

type ProxyBulk {
  # The bulk-job spec.
  spec: ProxyBulkSpec
  # The bulk-job status/data.
  status: BulkStatus
  # The metadata fields.
  metadata: MetadataFields
}

type ProxyBulkSpec {
  # The correlation identifier, e.g. to define relation to non-homogenous group.
  correlationId: UUID
  # The device (driver) type.
  driverType: String
  # The list of custom devices in the proxy bulk.
  devices: ListOfJobDevice
  # The bulk-shared job settings.
  settings: JobSettings
  # The list actions to be executed.
  actions: [JobAction]
  # The webhook URL to call when the proxy bulk is completed.
  webhookUrl: String
}

# Sub-message containing register-typed value
type RegisterValue {
  # The timestamp of the value.
  timestamp: Timestamp
  # The unit of the value.
  unit: String
  # The value.
  value: MeasuredValue
}

# Sub-message containing register-typed values
type RegisterValues {
  # The list of register values.
  values: [RegisterValue]
}

type RemoveCommunicationUnitsFromCommunicationBusRequest {
  # The unique identifier of the communication bus.
  communicationBusId: String
  # The unique identifier of the communication unit.
  communicationUnitId: [String]
}

type RemoveDeviceConfigurationRegisterFromDeviceConfigurationTemplateRequest {
  # The identifier of the device configuration template.
  dctId: String
  # The list of register identifiers to be unlinked from the template.
  registerId: [String]
}

type RemoveDevicesFromGroupRequest {
  # The unique identifier of the device group.
  groupId: String
  # The unique identifier of the device.
  deviceId: [String]
}

type RemoveRegisterFromVariableRequest {
  # The unique identifier of the variable.
  variableId: String
  # The list of register identifiers to be linked to the variable.
  registerId: [String]
}

type SetDeviceCommunicationUnitsRequest {
  # The unique identifier of the device.
  deviceId: String
  # The list of linked communication units.
  communicationUnits: [DeviceCommunicationUnit]
}

type SetModemPoolRequest {
  # The modem pool specification.
  spec: ModemPoolSpec
  # The metadata fields.
  metadata: MetadataFields
}

type SetModemRequest {
  # The modem pool identifier, required for update operation.
  poolId: String
  # The modem specification.
  modem: ModemInfo
}

type TimeOfUseTable {
  # The time-of-use table specification.
  spec: TimeOfUseTableSpec
  # The metadata fields.
  metadata: MetadataFields
}

type TopologyEdge {
  # The unique identifier of the edge.
  fromXId: Int64
  # The unique identifier of the edge.
  toXId: Int64
  # The attributes of the edge.
  attributes: FieldValues
}

type TopologyNode {
  # The unique identifier of the node.
  xId: Int64
  # The type of the node, e.g. "device", "communication_unit", etc.
  type: TopologyNodeType
  # The attributes of the node.
  attributes: FieldValues
}

type Variable {
  # The variable specification.
  spec: VariableSpec
  # The metadata fields.
  metadata: MetadataFields
}

type VariableDeviceData {
  # The unique identifier of the variable.
  variableId: String
  # The list of timestamps for the variable data.
  timestamps: [Timestamp]
  # The list of units for the variable data.
  units: [String]
  # The list of measured values for the variable data.
  values: [MeasuredValue]
}

type VariableSpec {
  # The list of device configuration register identifiers.
  registerId: [String]
  # The data type of the variable. Only registers of the same data type can be linked to the variable.
  dataType: FieldDataType
  # If true, the device data returned for this variable will exclude values at 'from' timestamp. Default is false (include values at 'from' timestamp).
  excludeDataFrom: Boolean
}

# DayProfile represents the profile for a single day, containing multiple Switching times
type DayProfile {
  # Unique identifier for the day profile
  dayId: String
  # List of switching events (each with specific time and relay states)
  switching: [Switching]
}

# RelayStateRecord represents the state of a relay at a specific time.
#  It contains the relay ID and its state (CONNECT or DISCONNECT).
#  The relay ID must be unique within the list of relays.
type RelayStateRecord {
  # Relay ID
  relayId: Int
  # State of the relay (CONNECT or DISCONNECT)
  state: RelayState
}

# Season represents a season which spans across a specific start date and references a week
type Season {
  # Unique identifier for the season
  id: String
  # Name of the season
  name: String
  # Start year of the season
  startYear: Int
  # Start month of the season
  startMonth: Int
  # Start day of the season
  startDay: Int
  # Reference to a Week ID that this season is associated with
  weekId: String
}

# SpecialDay represents specific days such as holidays or exceptions
type SpecialDay {
  # Year of the special day
  year: Int
  # Month of the special day
  month: Int
  # Day of the special day
  day: Int
  # Unique identifier for the special day
  dayId: String
}

# Switching data includes tariffs and relay states for specific times
type Switching {
  # Hour of the switching event.
  hour: Int
  # Minute of the switching event.
  minute: Int
  # Tariff ID.
  tariff: Int
  # Map of relay ID to relay state. The list must not contain duplicit relay IDs.
  relays: [RelayStateRecord]
}

# TimeOfUse represents the main Time-of-Use (TOU) table containing all relevant definitions
type TimeOfUseTableSpec {
  # Expiration date of the TOU table
  expiesAt: Timestamp
  # HDO (High Demand Option) Group ID
  hdoGroupId: String
  # Activation date of the TOU table
  activateAt: Date
  # List of seasons defined in the TOU
  seasons: [Season]
  # List of weeks defined in the TOU
  weeks: [Week]
  # List of day profiles (each day having a list of switching events)
  dayProfiles: [DayProfile]
  # List of special days (e.g., holidays, exceptions)
  specialDays: [SpecialDay]
}

# Week represents a week of the year, containing a list of Day IDs and Week Name
type Week {
  # Unique identifier for the week
  weekId: String
  # Name of the week
  weekName: String
  # List of day IDs that belong to this week
  dayIds: [String]
}

type CreateFieldDescriptorRequest {
  # The field descriptor to be created.
  spec: FieldDescriptor
}

# The field descriptor.
type FieldDescriptor {
  # Whether the field descriptor is user-defined (e.g., custom fields added by users)
  isUserDefined: Boolean
  # Defines the resource type for which the field descriptor is defined, e.g., BULK, DEVICE, etc.
  objectType: ObjectType
  # The system-wide unique identifier of the field descriptor.
  gid: String
  # Unique identifier for the field descriptor
  fieldId: String
  # The path to the field in the TypeScript representation
  jsPath: String
  # The path to the field in the gRPC/JSON simplified representation
  path: String
  # Label displayed for the field
  label: String
  # Group (section) identifier for the field
  groupId: String
  # Data type of the field (e.g., text, double)
  dataType: FieldDataType
  # Display format (e.g., 1h 30m)
  format: FieldDisplayFormat
  # Unit to display (e.g., kWh, USD)
  unit: String
  # Decimal precision for double numbers
  precision: Int
  # Tooltip or hint text
  tooltip: String
  # Whether the field is mandatory
  required: Boolean
  # Whether the field is editable
  editable: Boolean
  # Whether the field is visible
  visible: Boolean
  # Whether the field can have multiple values
  multiValue: Boolean
  # Whether the field shall be handled as a security fields (e.g., password, certificate input area, ...)
  secured: Boolean
  # Validation rules for the field
  validation: FieldValidation
  # The default value of the attribute, it does not support multi-value fields
  defaultValue: FieldValue
}

type FieldDescriptorOptions {
  # The field descriptor options.
  options: [_mapstring]
  # If set to false, the options were filtered out.
  complete: Boolean
}

# The system-wide field descriptor selector.
type FieldDescriptorSelector {
  # Defines the resource type for which the field descriptor is defined, e.g., BULK, DEVICE, etc.
  objectType: ObjectType
  # The system-wide unique identifier of the field descriptor.
  gid: String
}

# Validation rules for the field.
type FieldValidation {
  # Regular expression describing input format. If not set then any value of given type can be used. It can be used for string, int or double fields only.
  re: String
  # The minimum length. It's used for string fields only.
  minLength: Int
  # The maximum length. It's used for string fields only.
  maxLength: Int
  # The minimum value. It's used for integer fields only.
  minInteger: Int64
  # The maximum value. It's used for integer fields only.
  maxInteger: Int64
  # The minimum value. It's used for number fields only.
  minNumber: Float
  # The maximum value. It's used for number fields only.
  maxNumber: Float
  # The list of allowed values to be set (key-value pairs). The key here represents the field value to be set and the value here represents the label to be displayed.
  options: [_mapstring]
  # The options source. If set, then the options shall be dynamically fetched from the server.
  optionsSource: String
}

type FieldValue {
  # Represents a string-typed value.
  stringValue: String
  # Represents a 64-bit integer-typed value.
  integerValue: Int64
  # Represents a 64-bit double-typed value.
  doubleValue: Float
  # Represents a binary-typed value.
  binaryValue: String
  # Represents a boolean-typed value.
  boolValue: Boolean
  # Represents a date-typed value.
  dateValue: Timestamp
  # Represents a duration-typed value.
  durationValue: Duration
}

type FieldValues {
  # The field values.
  attributes: [_mapFieldValue]
}

type ListFieldDescriptorOptionsRequest {
  # The options source. Must be set to the options_source field of the FieldDescriptor.
  optionsSource: String
  # The filter to apply on the options. If set, only options containing this string will be returned.
  filterContains: String
}

type ListOfFieldDescriptor {
  # The list of field descriptors.
  items: [FieldDescriptor]
  # The total number of items.
  totalCount: Int
}

# The list of UUID items.
type ListOfId {
  id: [String]
}

# The list of common-string items.
type ListOfString {
  items: [String]
}

# The listing selector.
type ListSelector {
  # The number of items per page.
  pageSize: Int
  # The offset of the first item to return, zero based.
  offset: Int
  # The sorting criteria.
  sortBy: [ListSelectorSortBy]
  # The filtering criteria.
  filterBy: [ListSelectorFilterBy]
  # FIXME: This needs to be designed properly.
  #
  # The list of additional fields to be returned.
  fields: [String]
}

# The filtering criteria.
#
#  Depending on the operator, the `text`, `integer`, `number`, `boolean` or `date` field should be used.
#  - **No value** must be set for operators: `IS_NULL`, `IS_NOT_NULL`.
#  - Exactly **One value** must be set for single operand operators: `EQUAL`, `NOT_EQUAL`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LESS_THAN`, `LESS_THAN_OR_EQUAL`, `CONTAINS`, `NOT_CONTAINS`, `STARTS_WITH`, `ENDS_WITH`.
#  - Exactly **Two values** must be set for two operand operators: `BETWEEN`.
#  - **Zero or more** values can be set for generic operators: `IN`, `NOT_IN`.
#
#  Field type determines the data type and only related field should be used. Other fields shall not be set and will be ignored by the system.
type ListSelectorFilterBy {
  # The js_path or path from the FieldDescriptor.
  path: String
  # The filter operator.
  operator: FilterOperator
  # The data type of the field.
  dataType: FieldDataType
  # The text-typed value(s) used for filtering.
  text: [String]
  # The integer-typed value(s) used for filtering.
  integer: [Int64]
  # The number-typed value(s) used for filtering.
  number: [Float]
  # The boolean-typed value(s) used for filtering.
  boolean: [Boolean]
  # The date-typed value(s) used for filtering.
  date: [Timestamp]
}

# The sorting criteria.
type ListSelectorSortBy {
  # The js_path or path from the FieldDescriptor.
  path: String
  # Set to true to sort in descending order.
  desc: Boolean
}

# The metadata fields managed by user and system.
type MetadataFields {
  # The UUID of the resource. It serves as the unique identifier of the resource. It's immutable and typically auto-generated during Create operations.
  id: String
  # The generation of the resource.
  generation: Int
  # The additional fields managed by user.
  fields: [_mapFieldValue]
  # The additional fields managed by system.
  managedFields: [_mapFieldValue]
  # The name of the resource. It's mutable and typically set by user. Must be set.
  name: String
}

type UpdateMetadata {
  # The metadata fields of the resource.
  metadata: MetadataFields
}

type CreateCronJobRequest {
  spec: CronJobSpec
  # The metadata fields.
  metadata: MetadataFields
}

type CronJob {
  spec: CronJobSpec
  status: CronJobStatus
  # The metadata fields.
  metadata: MetadataFields
}

type CronJobSpec {
  # The type of the cron job, e.g., CRON_JOB_TYPE_START_BULK, CRON_JOB_TYPE_START_PROXY_BULK.
  type: CronJobTypeEnum
  # The cron job definition, e.g., "0 * * * *" for every hour.
  schedule: String
  # The timezone related to the cron job, e.g. "America/New_York", "Europe/Prague", "CET", "GMT", "Etc/GMT+2".
  timezone: String
  # Whether the cron job is suspended or not. By default, it is false (i.e., not suspended).
  suspend: Boolean
  # The payload to be sent when the cron job runs.
  data: Struct
}

type CronJobStatus {
  # The timestamp of the last run.
  lastRunAt: Timestamp
  # The timestamp of the next run.
  nextRunAt: Timestamp
  # The error message if the cron job schedule is invalid.
  error: String
}

type ListOfCronJob {
  # The list of cron jobs.
  items: [CronJob]
  # The total number of items.
  totalCount: Int
}

# Application config specification.
type ApplicationConfig {
  # The default values for the application configuration.
  items: [ComponentConfig]
}

type ApplicationConfigDescriptor {
  # The component configuration descriptors.
  descriptors: [ComponentConfigDescriptor]
  # The default values for the application configuration.
  items: [ComponentConfig]
}

type ComponentConfig {
  # The component name.
  name: String
  # The component configuration values.
  items: FieldValues
}

type ComponentConfigDescriptor {
  # The component name.
  name: String
  # The component configuration descriptors.
  items: [FieldDescriptor]
}

type _mapValue {
  key: String!
  value: Value
}

type _mapFieldValue {
  key: String!
  value: FieldValue
}

type _mapstring {
  key: String!
  value: String
}

type _mapListOfString {
  key: String!
  value: ListOfString
}

type Query {
  listBulks: ListOfBulk
  listBulkJobs: ListOfBulkJob
  getBulkJob: BulkJob
  updateBulkJob: Empty
  cancelBulk: Empty
  cancelBulkJobs: Empty
  createProxyBulk: StringValue
  getProxyBulk: ProxyBulk
  createBulk: StringValue
  getBulk: Bulk
  updateBulk: Empty
  getApplicationConfig: ApplicationConfigDescriptor
  updateApplicationConfig: Empty
  synchronizeComponentConfig: ComponentConfig
  createCronJob: StringValue
  listCronJobs: ListOfCronJob
  getCronJob: CronJob
  updateCronJob: Empty
  deleteCronJob: Empty
  runCronJob: Empty
  pauseCronJob: Empty
  resumeCronJob: Empty
  createDeviceConfigurationRegister: StringValue
  listDeviceConfigurationRegisters: ListOfDeviceConfigurationRegister
  getDeviceConfigurationRegister: DeviceConfigurationRegister
  updateDeviceConfigurationRegister: Empty
  deleteDeviceConfigurationRegister: Empty
  createDeviceConfigurationTemplate: StringValue
  listDeviceConfigurationTemplates: ListOfDeviceConfigurationTemplate
  getDeviceConfigurationTemplate: DeviceConfigurationTemplate
  updateDeviceConfigurationTemplate: Empty
  deleteDeviceConfigurationTemplate: Empty
  addDeviceConfigurationRegisterToDeviceConfigurationTemplate: Empty
  removeDeviceConfigurationRegisterFromDeviceConfigurationTemplate: Empty
  getDeviceData: DeviceData
  getDeviceDataRegisters: RegisterValues
  getDeviceDataProfiles: ProfileValues
  getDeviceDataIrregularProfiles: IrregularProfileValues
  getMeterEvents: EventRecords
  createCommunicationUnit: StringValue
  updateCommunicationUnit: Empty
  listCommunicationUnits: ListOfCommunicationUnit
  getCommunicationUnit: CommunicationUnit
  getCommunicationUnitNetworkMap: NetworkMap
  createCommunicationBus: StringValue
  listCommunicationBuses: ListOfCommunicationBus
  addCommunicationUnitsToCommunicationBus: Empty
  removeCommunicationUnitsFromCommunicationBus: Empty
  createDevice: StringValue
  updateDevice: Empty
  listDevices: ListOfDevice
  getDevice: Device
  getDeviceInfo: DeviceInfo
  setDeviceCommunicationUnits: Empty
  getDeviceCommunicationUnits: ListOfDeviceCommunicationUnit
  listDeviceCommunicationUnitChanges: ListOfDeviceCommunicationUnitChange
  getDeviceDeviceGroups: ListOfDeviceGroup
  getDeviceNetworkMap: NetworkMap
  createDeviceGroup: StringValue
  listDeviceGroups: ListOfDeviceGroup
  getDeviceGroup: DeviceGroup
  addDevicesToGroup: Empty
  removeDevicesFromGroup: Empty
  listDeviceGroupDevices: ListOfDevice
  listModemPools: ListOfModemPool
  getModemPool: ModemPool
  createModemPool: StringValue
  updateModemPool: Empty
  deleteModemPool: Empty
  createModem: StringValue
  updateModem: Empty
  deleteModem: Empty
  listDrivers: ListOfDriver
  getDriver: Driver
  createFieldDescriptor: StringValue
  updateFieldDescriptor: Empty
  deleteFieldDescriptor: Empty
  listFieldDescriptors: ListOfFieldDescriptor
  listFieldDescriptorOptions: FieldDescriptorOptions
  createTimeOfUseTable: StringValue
  listTimeOfUseTables: ListOfTimeOfUseTable
  getTimeOfUseTable: TimeOfUseTable
  updateTimeOfUseTable: Empty
  deleteTimeOfUseTable: Empty
  createVariable: StringValue
  listVariables: ListOfVariable
  getVariable: Variable
  updateVariable: Empty
  deleteVariable: Empty
  addRegisterToVariable: Empty
  removeRegisterFromVariable: Empty
}

scalar Timestamp
scalar BigInt
scalar Int64
scalar UUID
