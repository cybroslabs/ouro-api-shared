// Editions version of proto3 file
edition = "2023";
package io.clbs.openhes.models.acquisition;

option go_package = "github.com/cybroslabs/ouro-api-shared/gen/go/acquisition";

import "google/protobuf/empty.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";
import "common/messages.proto";
import "common/fields.proto";
import "common/metadata.proto";
import "common/types.proto";
import "acquisition/timeofuse/timeofuse.proto";

// Defines the available job priority levels.
enum JobPriority {
    // Lowest priority.
    JOB_PRIORITY_0 = 0;
    // Priority 1.
    JOB_PRIORITY_1 = 1;
    // Priority 2.
    JOB_PRIORITY_2 = 2;
    // Priority 3.
    JOB_PRIORITY_3 = 3;
    // Priority 4.
    JOB_PRIORITY_4 = 4;
    // Priority 5.
    JOB_PRIORITY_5 = 5;
    // Priority 6.
    JOB_PRIORITY_6 = 6;
    // Priority 7.
    JOB_PRIORITY_7 = 7;
    // Highest priority.
    JOB_PRIORITY_8 = 8;
}

// Defines the read path policies for retrieving data from devices.
enum ReadPathPolicy {
    READ_PATH_POLICY_UNSPECIFIED = 0;  // Keeps the current behavior (typically data-concentrator first).
    METER_FIRST                  = 1;  // Attempts to read directly from the meter and falls back to the data concentrator if needed and supported.
    DC_FIRST                     = 2;  // Attempts to read from the data concentrator first and falls back to the meter if needed and supported.
}

// Defines the parameters and execution rules that control how a job is processed.
message JobSettings {
    google.protobuf.Duration max_duration = 1;  // The maximum duration allowed for a job attempt. This value defines the real- time window for the driver to execute the job.
    JobPriority priority                  = 2;  // The execution priority assigned to the job.
    repeated int32 attempts               = 3;  // The maximum number of allowed job attempts. Must be at least `1`.
    google.protobuf.Duration retry_delay  = 4;  // The delay between two attempts.
    google.protobuf.Duration defer_start  = 5;  // The time offset to wait before starting the job.
    google.protobuf.Timestamp expires_at  = 6;  // The timestamp that specifies when the job expires and should no longer not be executed.
    ReadPathPolicy read_path_policy       = 7;  // The policy that determines how data is read from devices.  It can be red directly from devices (meters) or via the data concentrator.
}

// Defines the job action specification.
// The `JobAction` represents a single action to be performed on a single device.
// For example, if the action is `ActionGetRegister`, it specifies a single register to be read from the devices.
message JobAction {
    string action_id                          = 1;  // The unique identifier of the action.
    map<string, common.FieldValue> attributes = 2;  // The action attributes.
    oneof action {
        ActionGetRegister get_register                    = 3;   // Defines the GetRegister action.
        ActionGetPeriodicalProfile get_periodical_profile = 4;   // Defines the GetPeriodicalProfile action.
        ActionGetIrregularProfile get_irregular_profile   = 5;   // Defines the GetIrregularProfile action.
        ActionGetEvents get_events                        = 6;   // Defines the GetEvents action.
        ActionGetDeviceInfo get_device_info               = 7;   // Defines the GetDeviceInfo action.
        ActionSyncClock sync_clock                        = 8;   // Defines the SyncClock action.
        ActionSetRelayState set_relay_state               = 10;  // Defines the SetRelayState action.
        ActionSetDisconnectorState set_disconnector_state = 12;  // Defines the SetDisconnectorState action.
        ActionGetTou get_tou                              = 13;  // Defines the GetTou action.
        ActionSetTou set_tou                              = 14;  // Defines the SetTou action..
        ActionSetLimiter set_limiter                      = 16;  // Defines the SetLimiter action.
        ActionResetBillingPeriod reset_billing_period     = 17;  // Defines the ResetBillingPeriod action.
        ActionFwUpdate fw_update                          = 18;  // Defines the firmware update action.
    }
}

// Defines the job action set specification.
// Unlike a single `JobAction` that is used only once per bulk. `JobActionSet` may internally cover multiple `JobActions`.
// For example, if the action type is `GetRegister` and no variable filter is specified, the system automatically retrieves all registers defined in the active device configuration template.
message JobActionSet {
    // The variable filter. Meaning depends on the action type:
    //  - `GetRegister`, `GetPeriodicalProfile` and `GetIrregularProfile`: List of variable identifiers (for example, `"A+"`) defined in the system. If not set, all variables are read.
    // - Others: Not applicable (ignored).
    repeated string variables = 2;
    oneof action {
        ActionGetRegister get_register                    = 3;   // Defines the GetRegister action.
        ActionGetPeriodicalProfile get_periodical_profile = 4;   // Defines the GetPeriodicalProfile action.
        ActionGetIrregularProfile get_irregular_profile   = 5;   // Defines the GetIrregularProfile action.
        ActionGetEvents get_events                        = 6;   // Defines the GetEvents action.
        ActionGetDeviceInfo get_device_info               = 7;   // Defines the GetDeviceInfo action.
        ActionSyncClock sync_clock                        = 8;   // Defines the SyncClock action.
        ActionSetRelayState set_relay_state               = 10;  // Defines the SetRelayState action.
        ActionSetDisconnectorState set_disconnector_state = 12;  // Defines the SetDisconnectorState action.
        ActionGetTou get_tou                              = 13;  // Defines the GetTou action.
        ActionSetTou set_tou                              = 14;  // Defines the SetTou action..
        ActionSetLimiter set_limiter                      = 16;  // Defines the SetLimiter action.
        ActionResetBillingPeriod reset_billing_period     = 17;  // Defines the ResetBillingPeriod action.
        ActionFwUpdate fw_update                          = 18;  // Defines the firmware update action.
    }
}

// Sub-message - holds the bulk job specification.

message ListOfJobDevice {
    repeated JobDevice list = 1;  // The list of devices in the bulk.
    int32 total_count       = 2;  // The total number of items.
}

// Defines a list of device identifiers.
message ListOfJobDeviceId {
    repeated JobDeviceId list = 1;  // The list of device identifiers in the bulk.
    int32 total_count         = 2;  // The total number of device identifiers in the list.
}

// Defines the association between bulk jobs and individual devices.
message JobDeviceId {
    string job_id    = 1;  // The identifier of the device's job within the parent bulk.
    string device_id = 2;  // The unique identifier of the device.
}

// Defines single job-device job-device information.
message JobDevice {
    string job_id                                    = 1;  // The device job identifier within the parent bulk.
    string device_id                                 = 2;  // The device identifier. If set, all subsequent details are loaded from the device registry.
    string external_id                               = 3;  // The external identifier of the device.
    map<string, common.FieldValue> device_attributes = 4;  // The connection attributes for the device. Options depend on the `ApplicationProtocolTemplate` of the given application protocol (see the `app_protocol` property).
    repeated ConnectionInfo connection_info          = 5;  // The device connection parameters.
    ApplicationProtocol app_protocol                 = 6;  // The application protocol used by the device.
    string timezone                                  = 7;  // The timezone associated with the device. For example, `"America/New_York"`, `"Europe/Prague"`, `"CET"`, `"GMT"`, `"Etc/GMT+2"`.
}

// Defines modem connection information.
message ModemInfo {
    string modem_id                          = 1;  // The unique identifier of the modem. It is automatically generated during creation.
    string name                              = 2;  // The name of the modem.
    string at_init                           = 3;  // The modem initialization command. For example, `AT&FE0X3`.
    string at_dial                           = 4;  // The modem dial command. For example, `ATD`.
    string at_hangup                         = 5;  // The modem hangup command. For example, `ATH`.
    string at_escape                         = 6;  // The modem escape command. For exampl, `+++`.
    google.protobuf.Duration connect_timeout = 7;  // The modem connection timeout, if applicable by the `modem_connection` field.
    google.protobuf.Duration command_timeout = 8;  // The modem command timeout, if applicable given by the modem_connection field.
    // The modem connection description.
    oneof modem_connection {
        ConnectionTypeDirectTcpIp tcpip               = 9;   // The TCP connection type. The modem either supports TCP directly, or an IP-to-serial converter is used that handles the serial configuration.
        ConnectionTypeControlledSerial serial_over_ip = 10;  // The serial-over-IP connection type. Used when the modem is connected via an IP-to-serial converter and requires specific handling.
    }
    uint32 serial_baud_rate = 11;  // The serial baud rate, if applicable by the `modem_connection` field.
}

// Parity types
enum SerialConfigParity {
    // No parity.
    PARITY_NONE = 0;
    // Even parity.
    PARITY_EVEN = 1;
    // Odd parity.
    PARITY_ODD = 2;
    // Mark parity.
    PARITY_MARK = 3;
    // Space parity.
    PARITY_SPACE = 4;
}

// Baud rate types
enum SerialConfigBaudRate {
    // 110 baud
    BAUD_RATE_110 = 0;
    // 300 baud
    BAUD_RATE_300 = 1;
    // 600 baud
    BAUD_RATE_600 = 2;
    // 1200 baud
    BAUD_RATE_1200 = 3;
    // 2400 baud
    BAUD_RATE_2400 = 4;
    // 4800 baud
    BAUD_RATE_4800 = 5;
    // 9600 baud
    BAUD_RATE_9600 = 6;
    // 14400 baud
    BAUD_RATE_14400 = 7;
    // 19200 baud
    BAUD_RATE_19200 = 8;
    // 38400 baud
    BAUD_RATE_38400 = 9;
    // 57600 baud
    BAUD_RATE_57600 = 10;
    // 115200 baud
    BAUD_RATE_115200 = 11;
    // 230400 baud
    BAUD_RATE_230400 = 12;
    // 460800 baud
    BAUD_RATE_460800 = 13;
    // 921600 baud
    BAUD_RATE_921600 = 14;
}

// Data bits types
enum SerialConfigDataBits {
    // 5 data bits
    DATA_BITS_5 = 0;
    // 6 data bits
    DATA_BITS_6 = 1;
    // 7 data bits
    DATA_BITS_7 = 2;
    // 8 data bits
    DATA_BITS_8 = 3;
}

// Stop bits types
enum SerialConfigStopBits {
    // 1 stop bit
    STOP_BITS_1 = 0;
    // 1.5 stop bits
    STOP_BITS_1_5 = 1;
    // 2 stop bits
    STOP_BITS_2 = 2;
}

// Defines the parameters for serial port configuration.
message SerialConfig {
    SerialConfigBaudRate baud_rate = 1;  // The baud rate.
    SerialConfigParity parity      = 2;  // The parity.
    SerialConfigDataBits data_bits = 3;  // The data bits.
    SerialConfigStopBits stop_bits = 4;  // The stop bits.
}

// Defines the configuration parameters for device connection.
message ConnectionInfo {
    // The entrypoint connection description. The connection can be either direct TCP, a modem from a pool, or a direct serial line over IP (via an using IP-to-serial converter).
    oneof connection {
        ConnectionTypeDirectTcpIp tcpip               = 1;  // The TCP/IP connection type.
        ConnectionTypeModemPool modem_pool            = 2;  // The phone-based (modem pool) connection type..
        ConnectionTypeControlledSerial serial_over_ip = 3;  // The serial-over-IP connection type.
    }
    DataLinkProtocol link_protocol            = 4;  // The data link protocol.
    string communication_bus_id               = 5;  // he communication bus identifier. Works as a custom grouping key to link jobs across multiple communication units when multiple entry points share a single communication bus (foe example, multi-master RS-485 withprimary and backup masters). If not set, jobs are grouped by the default group key based on the connection type.
    map<string, common.FieldValue> attributes = 6;  // The connection attributes. See `GetDataLinkFields` in the acquisition package.
}

// Defines the connection information for direct TCP/IP connection type.
message ConnectionTypeDirectTcpIp {
    string host                      = 1;  // The hostname or IP address of the device to connect to.
    uint32 port                      = 2;  // The TCP port number of the device to connect to.
    google.protobuf.Duration timeout = 3;  // The timeout for TCP/IP connection.
}

// Defines the connection information for a phone line (modem) connection type.
message ConnectionTypeModemPool {
    // The phone number of the device to connect to.
    string number = 1;
    // The unique modem pool identifier. A modem pool is a group of modems that can be used to connect to the device. The final modem is selected by the Taskmaster at the job start.
    string pool_id = 2;
    // The modem device assigned to the job. This field filled only when the connection type is modem. The value is assigned by the Taskmaster at the start of the job, and the driver musr use this modem exclusively for this job!
    ModemInfo modem = 4;
}

// Defines the connection information for a direct serial port connection.
message ConnectionTypeSerialDirect {
    string host                      = 1;  // The host name or IP address of the device to connect to.
    uint32 port                      = 2;  // The TCP port number of the device to connect to.
    google.protobuf.Duration timeout = 3;  // The timeout for the direct serial port connection.
}

// Defines the connection information for a controlled serial line using the Moxa protocol.
message ConnectionTypeSerialMoxa {
    string host                      = 1;  // The host name or IP address of the device to connect to.
    uint32 dataPort                  = 2;  // The TCP data port number of the device to connect to.
    uint32 command_port              = 3;  // The TCP command port number of the device to connect to.
    google.protobuf.Duration timeout = 4;  // The timeout for the serial port connection using the Moxa protocol.
}

// Defines the connection information for a controlled serial line using the RFC 2217 protocol.
message ConnectionTypeSerialRfc2217 {
    string host                      = 1;  // The host name or IP address of the device to connect to.
    uint32 port                      = 2;  // The TCP port number of the device to connect to.
    google.protobuf.Duration timeout = 3;  // The timeout for serial port connection using the RFC 2217 protocol.
}

// Connection types
enum CommunicationType {
    // The communication is done via direct TCP/IP.
    COMMUNICATION_TYPE_TCPIP = 0;
    // The communication is done via phone line (modem).
    COMMUNICATION_TYPE_MODEM_POOL = 1;
    // The communication is done via a direct serial line.
    COMMUNICATION_TYPE_SERIAL_LINE_DIRECT = 2;
    // The communication is done via a controlled  serial line (Moxa).
    COMMUNICATION_TYPE_SERIAL_LINE_MOXA = 3;

    // The communication is passive. The driver listens on a port (for example, DLMS devices in push mode) or subscribes to a message queue (for example, MQTT).
    COMMUNICATION_TYPE_LISTENING = 99;
}

// Data link protocols
enum DataLinkProtocol {
    // The VDEW (IEC 62056-21, IEC-61107) protocol. When combined with the DLMS protocol, the driver initiates communication via IEC and switches to the mode E (HDLC+DLMS) protocol. Supports multiple devices on the same line.
    LINKPROTO_IEC_62056_21 = 0;
    // The HDLC (ISO/IEC-3309) framing. Used with various application protocols, such as DLMS or MODBUS. Supports client/server addressing for multiple devices on the same line.
    LINKPROTO_HDLC = 1;
    // The COSEM wrapper. Used with the DLMS application protocol. Supports client/server addressing for multiple devices on the same line.
    LINKPROTO_COSEM_WRAPPER = 2;
    // The Modbus protocol. Used with the Modbus application protocol where no other data link , such as HDLC is used.
    LINKPROTO_MODBUS = 3;
    // The M-Bus protocol. Used with the M-Bus application protocol.
    LINKPROTO_MBUS = 4;
    // The Viktor protocol. A proprietary protocol used by Viktor-based devices, such as DC450 Vitkor.
    LINKPROTO_VIKTOR = 5;

    // No data link protocol is applicable. Used with listening communication types.
    LINKPROTO_NOT_APPLICABLE = 99;
}

// Application protocols
enum ApplicationProtocol {
    // The IEC 62056-21 (IEC-61107, VDEW) protocol.
    APPPROTO_IEC_62056_21 = 0;
    // The DLMS short-name protocol.
    APPPROTO_DLMS_SN = 1;
    // The DLMS logical-name protocol.
    APPPROTO_DLMS_LN = 2;
    // The SCTM protocol.
    APPPROTO_SCTM = 3;
    // The LIS200 protocol.
    APPPROTO_LIS200 = 4;
    // The ANSI C12 protocol.
    APPPROTO_ANSI_C12 = 5;
    // The MQTT protocol.
    APPPROTO_MQTT = 6;
    // The MODBUS protocol.
    APPPROTO_MODBUS = 7;
    // The MBUS protocol.
    APPPROTO_MBUS = 8;
}

// Defines the destription for one application protocol, for example DLMS_SN.
message ApplicationProtocolTemplate {
    // The application protocol.
    ApplicationProtocol protocol = 1;
    // The list of attribute definitions for the selected application protocol. These attributes are instantiated for each device and communication unit pair.
    repeated common.FieldDescriptor attributes = 2;
}

// Defines the destription of a single data link protocol, for example `HDLC`.
message DataLinkTemplate {
    // The data link protocol.
    DataLinkProtocol link_protocol = 1;
    // The list of application protocol identifiers supported by the driver.
    repeated ApplicationProtocol app_protocol_refs = 2;
    // The list of attribute definitions related to the selected data link type (see l`ink_protocol` property). These field definitions are provided by the system and drivers must leave this field empty.
    repeated common.FieldDescriptor attributes = 3;
}

// Defines the destription of a single communication type, for example `TCP/IP`.
message CommunicationTemplate {
    // The communication type.
    CommunicationType type = 1;
    // The list of supprted data link protocols and their application protocols supported by the driver.
    repeated DataLinkTemplate datalinks = 2;
}

// Defines the access level configuration for a driver.
message AccessLevelTemplate {
    string id   = 1;  // The unique identifier of the access level, such as `"1"`, `"G"`, or `"16"`.
    string name = 2;  // The name of the access level. It must be unique and written in English (for example, `"Management"`, `"Public"`).
}

// Defines the driver templates exchanged during driver negotiation.
message DriverTemplates {
    // The supported communication options templates. Each template represents one communication method. A driver can support multiple communication templates.
    repeated CommunicationTemplate communication_templates = 1;
    // The supported application protocol templates.
    repeated ApplicationProtocolTemplate app_protocols = 2;
    // The job action templates all supported action types. Each supported action type must appear onbly once.
    repeated JobActionAttributes action_attributes = 3;
    // The supported access level templates.
    repeated AccessLevelTemplate access_templates = 4;
    // The supported templates of the job actions constraints.
    JobActionContraints action_constraints = 5;
    // The list of descriptors for uknown devices detected by the communication unit.
    // This applies only to drivers that communicate with devices like data concentrators that can provide information for unknown devices.
    // The descriptors must cover all data attributes used in the `SetUnknownDevicesRequest` message.
    repeated common.FieldDescriptor uknown_device_descriptors = 6;
}

// Defines a progress update for an action within a job.
message ActionProgressUpdate {
    string job_id                         = 1;  // The unique job identifier.
    string action_id                      = 2;  // The unique action identifier.
    ActionResultCode code                 = 3;  // The status code related to the action.
    ActionData data                       = 4;  // The action result data. This field is empty if the code is not OK.
    common.FormattedMessage error_message = 5;  // The user-facing error message provided when the action ends with `ERROR_CODE_ACTION_ERROR`. The message provides details about the failure, can be multiline, and should be in English.
}

// Defines a progress update for a job.
message JobProgressUpdate {
    string job_id                         = 1;  // The unique job identifier.
    JobErrorCode code                     = 2;  // The status code related to the job or action update message.
    google.protobuf.Duration duration     = 3;  // The time spent to handle the job.
    common.FormattedMessage error_message = 4;  // The user-facing error message for the job as a whole. This message related to the whole job. This message is used especially when no action is executed, to log a non-action related error.
}

// Defines the action-based variant of data values.
message ActionData {
    oneof data {
        google.protobuf.Empty nodata             = 1;  // Indicates that no data was returned by the action.
        RegisterValues registers                 = 2;  // The set of register values.
        ProfileValues profile                    = 3;  // The set of profile values.
        IrregularProfileValues irregular_profile = 4;  // The set of irregular (non-periodical) profile values, such as daily profiles.
        DeviceInfo device_info                   = 5;  // The device information.
        EventRecords events                      = 6;  // The event records.
        timeofuse.TimeOfUseTableSpec tou_table   = 7;  // The time-of-use (TOU) table.
    }
}

// Defines a list of event records.
message EventRecords {
    repeated EventRecord values = 1;  // The list of event records.
}

// Defines a single event reported by a device.
message EventRecord {
    google.protobuf.Timestamp timestamp = 1;  // The timestamp of the event.
    int64 event_id                      = 2;  // The identifier of the event.
    int64 event_code                    = 3;  // The event code generated by the device.
    string event_source                 = 5;  // The source of the event.
    string event_text                   = 4;  // The descriptive text of the event.
}

// Defines a single event record associated with the specified device.
message DeviceEventRecord {
    string device_id                    = 1;  // The unique device identifier.
    google.protobuf.Timestamp timestamp = 2;  // The timestamp of the event.
    int64 event_id                      = 3;  // The unique event identifier.
    int64 event_code                    = 4;  // The event code generated by the device.
    string event_source                 = 5;  // The source of the event.
    string event_text                   = 6;  // The descriptive text of the event.
}

// Defines a list of device event records.
message DeviceEvents {
    // The list of device event records.
    repeated DeviceEventRecord events = 1;
}

// Defines common device information.
message DeviceInfo {
    google.protobuf.Timestamp info_timestamp = 1;  // The timestamp when the values were read.
    string manufacturer_serial_number        = 2;  // The serial number of the device assigned by the manufacturer. Typical source: `0-0:42.0.0.255`.
    string device_serial_number              = 3;  // The device serial number.  Typical source: `0-0:96.1.0.255`.
    string firmware_version                  = 4;  // The device firmware version identifier. Typical source: `0-0:0.2.0.255`.
    google.protobuf.Duration clock_delta     = 5;  // The time difference (delta) between the device clock and the acquisition server clock (driver). Positive values mean the device clock is ahead, negative values mean the device clock is behind.
    string device_model                      = 6;  // The device model.
    uint64 error_register                    = 7;  // The error register (register `0`). Typical source: `0-0:97.97.1.255` (higher 32-bit) + `0-0:97.97.0.255` (lower 32-bit).
    repeated bool relay_states               = 8;  // The list of relay states. The order of the relays is the same as in the device. The value is `true` if the relay is connected and `false` if the relay is disconnected.
    bool connection_state                    = 9;  // The connection (disconnector) state. The value is `true` if the customer is connected and `false` if the customer is disconnected.
}

// Defines the profile-type values.
message ProfileValues {
    int32 period                 = 1;  // The period of the profile values in seconds.
    string unit                  = 2;  // The unit of the profile values.
    repeated ProfileBlock blocks = 3;  // The list of continuous profile blocks.
}

// Defines the irregular (non-perioic) profile values.
message IrregularProfileValues {
    string unit                    = 1;  // The unit of the profile values.
    repeated IrregularValue values = 2;  // The list of irregular values.
}

// Defines a single irregular (non-periodic) value with a timestamp.
message IrregularValue {
    google.protobuf.Timestamp timestamp = 1;  // The timestamp of the value.
    MeasuredValue value                 = 2;  // The value.
}

// Defines a single profile block containing the measured values.
message ProfileBlock {
    google.protobuf.Timestamp start_timestamp = 1;  // The start timestamp of the block.
    repeated MeasuredValue values             = 2;  // The list of profile values, ordered by the timestamp.
}

// Defines the register-type values.
message RegisterValues {
    repeated RegisterValue values = 1;  // The list of register values.
}

// Defines a single register-type value.
message RegisterValue {
    google.protobuf.Timestamp timestamp = 1;  // The timestamp of the value.
    string unit                         = 2;  // The unit of the value.
    MeasuredValue value                 = 3;  // The value.
}

// Sub-message containing measured value
message MeasuredValue {
    int64 status   = 1;  // The status of the value.
    int32 exponent = 2;  // The exponent of the value. It's used to calculate the real value as value * 10^exponent for double and int values.
    oneof kind {
        double double_value                       = 3;  // The double-typed value.
        int64 integer_value                       = 4;  // The integer-typed value.
        string string_value                       = 5;  // The string-typed value.
        google.protobuf.Timestamp timestamp_value = 6;  // The timestamp-typed value.
        string timestamp_tz_value                 = 7;  // The timestamp with timezone-typed value, stored as string in ISO-8601.
        bool bool_value                           = 8;  // The boolean-typed value.
    }
    uint64 nstatus                    = 9;   // The normalized status of the value, see StatusBits enum for more details.
    google.protobuf.Timestamp peak_ts = 10;  // The timestamp when the value (e.g. peak) was recorded. It's typically before the capture timestamp.
}

// Sub-message containing job action attributes
message JobActionAttributes {
    // The type of action for which this instance of the template is defined.
    ActionType type = 1;
    // The template of the action attributes. It is represented as a list of attribute definitions.
    repeated common.FieldDescriptor attributes = 2;
}

// Sub-message containing connection info for controlled-serial line over IP (e.g. Moxa) connection type
message ConnectionTypeControlledSerial {
    // IP-to-serial converter description.
    oneof converter {
        ConnectionTypeSerialDirect direct   = 1;  // The simple direct serial connection type.
        ConnectionTypeSerialMoxa moxa       = 2;  // The Moxa connection type.
        ConnectionTypeSerialRfc2217 rfc2217 = 3;  // The RFC 2217 connection type.
        // TBA: Add Advanctech and other IP-to-serial converters.
    }
}

// Action types
enum ActionType {
    // Get register value, for example instantaneous values. The action covers specific register.
    ACTION_TYPE_GET_REGISTER = 0;
    // Get periodical profile, for example load-profile. The action covers specific profile column.
    ACTION_TYPE_GET_PERIODICAL_PROFILE = 1;
    // Get non-periodical profile, for example daily profile or monthly billing registers. The action covers specific profile column and or specific billing register.
    ACTION_TYPE_GET_IRREGULAR_PROFILE = 2;
    // Get event log. The action covers specific event log.
    ACTION_TYPE_GET_EVENTS = 3;

    // Get device info. The action returns info data about remote device.
    ACTION_TYPE_GET_DEVICE_INFO = 10;

    // Synchronize clock. The action synchronizes the time in the device, it can forcefully set it if force attribute is set.
    ACTION_TYPE_SYNC_CLOCK = 11;

    // Set relay state. The action covers single relay.
    ACTION_TYPE_SET_RELAY_STATE = 21;

    // Get disconnector state. The action covers single disconnector if multiple disconnectors are present in the device.
    ACTION_TYPE_GET_DISCONNECTOR_STATE = 22;
    // Set disconnector state. The action covers single relay. The action covers single disconnector if multiple disconnectors are present in the device.
    ACTION_TYPE_SET_DISCONNECTOR_STATE = 23;

    // Get time-of-use table.
    ACTION_TYPE_GET_TOU = 24;
    // Set time-of-use table.
    ACTION_TYPE_SET_TOU = 25;

    // Set limiter settings. The action covers single limiter.
    ACTION_TYPE_SET_LIMITER = 27;

    // Reset billing period.
    ACTION_TYPE_RESET_BILLING_PERIOD = 40;

    // Start firmware update. The action updates starts FW upgrade procedure.
    ACTION_TYPE_FW_UPDATE = 50;
}

// Sub-message containing get register action specification
message ActionGetRegister {
    common.FieldDataType data_type = 1;  // The data type of the target register, e.g. integer, double, string, timestamp, etc. This value can be specified for proxy bulk, while it's automatically taken from the register definition in the system for bulks.
}

// Sub-message containing get periodical profile action specification
message ActionGetPeriodicalProfile {
    google.protobuf.Timestamp range_start = 1;  // The start timestamp of the profile readout.
    google.protobuf.Timestamp range_end   = 2;  // The end timestamp of the profile readout.
    common.FieldDataType data_type        = 3;  // The data type of the target register, e.g. integer, double, string, timestamp, etc. This value can be specified for proxy bulk, while it's automatically taken from the register definition in the system for bulks.
}

// Sub-message containing get irregular profile action specification
message ActionGetIrregularProfile {
    google.protobuf.Timestamp range_start = 1;  // The start timestamp of the profile readout.
    google.protobuf.Timestamp range_end   = 2;  // The end timestamp of the profile readout.
    common.FieldDataType data_type        = 3;  // The data type of the target register, e.g. integer, double, string, timestamp, etc. This value can be specified for proxy bulk, while it's automatically taken from the register definition in the system for bulks.
}

// Sub-message containing get events action specification
message ActionGetEvents {
    google.protobuf.Timestamp range_start = 1;  // The start timestamp of the event readout.
    google.protobuf.Timestamp range_end   = 2;  // The end timestamp of the event readout.
}

// Sub-message containing get device info action specification
message ActionGetDeviceInfo {
}

// Sub-message containing sync clock action specification
message ActionSyncClock {
}

// Sub-message containing set relay state action specification
message ActionSetRelayState {
}

// Sub-message containing set disconnector state action specification
message ActionSetDisconnectorState {
}

// Sub-message containing get tou action specification
message ActionGetTou {
    bool passive = 1;  // Identifies whether to read passive TOU table. By default it is set to false to read active TOU table.
}

// Sub-message containing set tou action specification
message ActionSetTou {
    timeofuse.TimeOfUseTableSpec table = 1;  // The time-of-use table to be set.
}

// Sub-message containing set limiter action specification
message ActionSetLimiter {
}

// Sub-message containing reset billing period action specification
message ActionResetBillingPeriod {
}

// Sub-message containing firmware update action specification
message ActionFwUpdate {
}

// Result codes related to job actions
enum ActionResultCode {
    // The action has been completed successfully.
    ERROR_CODE_ACTION_OK = 0;
    // The action is not supported by the driver (or device).
    ERROR_CODE_ACTION_UNSUPPORTED = 1;
    // The action is pending.
    ERROR_CODE_ACTION_PENDING = 3;
    // The action failed.
    ERROR_CODE_ACTION_ERROR = 5;
}

// Error codes related to jobs
enum JobErrorCode {
    // The job has been completed successfully.
    JOB_ERROR_CODE_NONE = 0;
    // There is no free slot in the driver to handle the job; the job shall be send again later.
    JOB_ERROR_CODE_BUSY = 1;
    // The job failed, the retry will be attempted.
    JOB_ERROR_CODE_ERROR = 5;
    // This should never happen! It means that the same job is currently being processed by the driver and it was sent to the driver mutliple times which would mean that there is a bug.
    JOB_ERROR_CODE_ALREADY_EXISTS = 8;
    // The job failed, the retry will NOT be attempted.
    JOB_ERROR_CODE_FATAL = 9;
}

// Sub-message containing constraints for job actions.
message JobActionContraints {
    // Contains all the register types & their names in the English language. For example: [gen]="Generic Register", [vqi]="Quality VQI Register"
    // Action: ACTION_TYPE_GET_REGISTER
    map<string, string> get_register_type_name = 1;
    // Contains all the register types & their attributes. For example: [gen]=["attribute1", "attribute2"], [vqi]=["attribute1", "attribute3"]
    // See JobActionAttributes for the attribute definitions.
    // Action: ACTION_TYPE_GET_REGISTER
    map<string, common.ListOfString> get_register_type_attributes = 2;
}

// Bulk statuses
enum BulkStatusCode {
    // The job is waiting in the queue
    BULK_STATUS_QUEUED = 0;
    // The job is running
    BULK_STATUS_RUNNING = 1;
    // The job is completed
    BULK_STATUS_COMPLETED = 2;
    // The job is cancelled
    BULK_STATUS_CANCELLED = 3;
    // The job has expired
    BULK_STATUS_EXPIRED = 4;
}

// Sub-message containing job status info
message JobStatus {
    JobStatusCode status                  = 1;  // The status of the job.
    JobErrorCode code                     = 2;  // The error code of the job.
    repeated ActionResult results         = 3;  // The result data for all job actions.
    google.protobuf.Timestamp started_at  = 4;  // The start timestamp of the job.
    google.protobuf.Timestamp finished_at = 5;  // The finish timestamp of the job.
    int32 attempts_done                   = 6;  // The number of attempts already done.
    DeviceInfo device_info                = 7;  // The device info. It contains the data from the action ACTION_TYPE_GET_DEVICE_INFO.
    int64 queue_id                        = 8;  // The internal queue identifier set by the Taskmaster when the job is queued to process.
    common.FormattedMessage error_message = 9;  // The user error message related to the whole job. This is used especially when no action is executed to log a non-action related error message.
}

// Sub-message containing job start request for single device
message StartJobData {
    map<string, common.FieldValue> device_attributes = 1;  // The device attributes. For example HDLC address, password and other driver-specific attributes.
    string job_id                                    = 2;  // The job identifier.
    JobSettings job_settings                         = 3;  // The job parameters.
    repeated JobAction job_actions                   = 4;  // The list actions to be executed.
    ApplicationProtocol app_protocol                 = 5;  // The application protocol.
    string timezone                                  = 6;  // The timezone related to the device, e.g. "America/New_York", "Europe/Prague", "CET", "GMT", "Etc/GMT+2".
}

// Taskmaster -> Driver cancel job request message
message CancelJobRequest {
    string job_id = 1;  // The job identifier.
}

enum RegisterType {
    // The register is a generic register.
    Register = 0;
    // The register is part of a periodical profile.
    PeriodicalProfile = 1;
    // The register is part of an irregular profile.
    IrregularProfile = 2;
    // Synthetic register, not visible by drivers. It can be defined to store derived or external data.
    Synthetic = 99;
}

message DeviceConfigurationRegisterSpec {
    string driver_type                        = 1;  // The device (driver) type.
    RegisterType register_type                = 2;  // The type of action for which the register is defined.
    map<string, common.FieldValue> attributes = 3;  // The field values.
    common.FieldDataType data_type            = 4;  // The data type of the register;
}

// Addon
message DeviceRegister {
    int64 register_id                    = 1;  // The register identifier.
    string public_register_id            = 2;  // The public register identifier.
    DeviceConfigurationRegisterSpec spec = 3;  // The register spec.
    repeated string variable_name        = 4;  // The name of the variable, if the register is assigned to some.
}

// Addon
message DeviceConnectionInfo {
    ConnectionInfo communication_unit                = 1;  // The unique identifier of the communication unit.
    ApplicationProtocol app_protocol                 = 2;  // The application protocol to be used for the communication over the communication unit.
    map<string, common.FieldValue> device_attributes = 3;  // The device attributes. For example HDLC address, password and other driver-specific attributes.
    string timezone                                  = 4;  // The timezone related to the device, e.g. "America/New_York", "Europe/Prague", "CET", "GMT", "Etc/GMT+2".
    string driver_type                               = 5;  // The driver type identifier.
    string driver_version                            = 7;  // The driver version.
    repeated DeviceRegister registers                = 8;  // The list of registers get using current device configuration template.
}

// Addon for DB
message ListOfModemInfo {
    repeated ModemInfo items = 1;
    int32 total_count        = 2;  // The total number of items.
}

// Addon for DB
message ListOfConnectionInfo {
    repeated DeviceConnectionInfo items = 1;
    int32 total_count                   = 2;  // The total number of items.
}

// Addon for DB
message FieldValuesList {
    repeated common.FieldValues items = 1;  // The list of field values.
}

// Generic attribute selector using field values
message AttributeSelector {
    string field_id = 1;                          // The field identifier
    common.FilterOperator operator = 2;           // The filter operator.
    common.FieldDataType data_type          = 3;  // The data type of the field.
    repeated string text                    = 4;  // The text-typed value(s) used for filtering.
    repeated sint64 integer                 = 5;  // The integer-typed value(s) used for filtering.
    repeated double number                  = 6;  // The number-typed value(s) used for filtering.
    repeated bool boolean                   = 7;  // The boolean-typed value(s) used for filtering.
    repeated google.protobuf.Timestamp date = 8;  // The date-typed value(s) used for filtering.
}

// Generic attribute selector using field values for devices
message DeviceAttributeSelector {
    repeated AttributeSelector attributes = 2;  // The list of field values.
}

// Generic attribute selector using field values for devices
message CommunicationUnitAttributeSelector {
    DataLinkProtocol link_protocol        = 1;  // The application protocol to be used for the communication over the communication unit.
    repeated AttributeSelector attributes = 2;  // The list of field values.
}

// Job statuses
enum JobStatusCode {
    // The job is waiting in the queue
    JOB_STATUS_QUEUED = 0;
    // The job is running
    JOB_STATUS_RUNNING = 1;
    // The data has been fully acquired and is being processed
    JOB_STATUS_PROCESSING_DATA = 2;
    // The job is completed
    JOB_STATUS_COMPLETED = 3;
    // The job is failed
    JOB_STATUS_FAILED = 4;
    // The job is cancelled
    JOB_STATUS_CANCELLED = 5;
    // The job has expired
    JOB_STATUS_EXPIRED = 6;
}

// Defines the result of a single action.
message ActionResult {
    string action_id                      = 1;  // The unique action identifier.
    ActionResultCode status               = 2;  // The status code of the action.
    ActionData data                       = 3;  // The action result data.
    string register_id                    = 4;  // The unique register identifier. This is a read-only value and is set only if the action data relats to a register. Applicable only for results of regular bulks.
    repeated string variable_name         = 5;  // The variable names. This is a read-only value and is set only if the action data relates to one or more variables based on device template mapping. Applicable only for results of regular bulks.
    common.FormattedMessage error_message = 6;  // The user-facing error message provided when the action ends with `ERROR_CODE_ACTION_ERROR`. The message provides details about the failure, can be multiline, and should be in English.
}

// Taskmaster -> Dataproxy job/action progress update message
message JobEventData {
    bytes job_id = 1;  // The job identifier.
}

// Sub-message - the device specification.
message DeviceSpec {
    // @gqltype: UUID
    string dct_id                                            = 1;  // The device configuration template identifier.
    string external_id                                       = 2;  // The external identifier of the device.
    repeated DeviceCommunicationUnit communication_unit_link = 3;  // The list of communication unit identifiers (and additional info) that set CUs usable to communicate with the device. It's an ordered set where the first element is the primary communication unit with the highest priority.
    string timezone                                          = 4;  // The timezone related to the device, e.g. "America/New_York", "Europe/Prague", "CET", "GMT", "Etc/GMT+2".
}

message DeviceStatus {
    DeviceInfo info    = 1;  // The device info.
    string driver_type = 2;  // The driver type selecte by it's device configuration template.
}

message DeviceCommunicationUnit {
    string communication_unit_id              = 1;  // The unique identifier of the communication unit.
    ApplicationProtocol app_protocol          = 2;  // The application protocol to be used for the communication over the communication unit.
    map<string, common.FieldValue> attributes = 3;  // The app-protocol related device attributes. It is represented as a list of attribute definitions.
}

// Sub-message - job specification
message JobSpec {
    JobDevice device                            = 2;  // The device info.
    acquisition.JobSettings job_settings        = 3;  // The job parameters.
    string driver_type                          = 4;  // The device (driver) type.
    repeated acquisition.JobAction job_actions  = 5;  // The list actions to be executed.
    repeated JobActionMapRecord job_action_info = 6;  // The mapping data for all actions.
}

message JobActionMapRecord {
    int32 action_index            = 1;  // The index of the action in the job_actions list.
    int64 register_id             = 3;  // The internal register identifier.
    string public_register_id     = 2;  // The register identifier.
    repeated string variable_name = 4;  // The name of the variable, if the register is assigned to some.
}

// Message used to notify DP that the job is done, sent by Taskmaster
message JobDoneNotification {
    JobSpec spec     = 1;  // The job specification.
    JobStatus status = 2;  // The status of the job
}

// Sub-message containing driver info
message DriverInfo {
    string driver_type = 1;  // The driver unique identifier.
    string version     = 2;  // The version of the driver.
}

message CommunicationUnit {
    reserved 2;                          // reserved for status
    CommunicationUnitSpec spec     = 1;  // The communication unit specification.
    common.MetadataFields metadata = 3;  // The metadata fields.
}

message CommunicationUnitSpec {
    string external_id             = 1;  // The external identifier of the communication unit.
    ConnectionInfo connection_info = 2;  // The connection info.
}

message CommunicationBus {
    reserved 1;
    CommunicationBusStatus status  = 2;  // The communication bus status.
    common.MetadataFields metadata = 3;  // The metadata fields.
}

message CommunicationBusStatus {
    repeated string communication_unit_id = 1;  // The list of communication unit identifiers.
}

// Network map messages

enum TopologyNodeType {
    // The node is a device, such as an electricity meter.
    TOPOLOGY_NODE_DEVICE = 0;
    // The node is a communication unit, such as a modem or a data concentrator.
    TOPOLOGY_NODE_COMMUNICATION_UNIT = 1;
}

message TopologyNode {
    int64 x_id                    = 1;  // The unique identifier of the node.
    TopologyNodeType type         = 2;  // The type of the node, e.g. "device", "communication_unit", etc.
    common.FieldValues attributes = 3;  // The attributes of the node.
}

message TopologyEdge {
    int64 from_x_id               = 1;  // The unique identifier of the edge.
    int64 to_x_id                 = 2;  // The unique identifier of the edge.
    common.FieldValues attributes = 3;  // The attributes of the edge.
}

message NetworkMap {
    // Flat or hierarchical list of topology devices
    repeated TopologyNode nodes = 1;
    repeated TopologyEdge edges = 2;  // The list of edges between the devices.
}

// Communication Unit Log Records

enum LogRecordLevel {
    LOG_RECORD_LEVEL_DEBUG   = 0;  // The log record level is debug.
    LOG_RECORD_LEVEL_INFO    = 1;  // The log record level is info.
    LOG_RECORD_LEVEL_WARNING = 2;  // The log record level is warning.
    LOG_RECORD_LEVEL_ERROR   = 3;  // The log record level is error.
    LOG_RECORD_LEVEL_FATAL   = 4;  // The log record level is fatal.
}

message CommunicationUnitLogRecord {
    string id                           = 1;  // The unique identifier of the log record, if provided. If not provided, a hash of the log data is auto-generated.
    string communication_unit_id        = 2;  // The unique identifier of the communication unit to which the log record belongs. When adding the log records, it may be empty and relation can be set on the upper object level instead.
    google.protobuf.Timestamp timestamp = 3;  // The timestamp of the log record. It must not be empty.
    LogRecordLevel level                = 4;  // The log level of the log record, if provided.
    string message                      = 5;  // The log message. It must not be empty.
}

message ListOfCommunicationUnitLogRecord {
    repeated CommunicationUnitLogRecord items = 1;
    int32 total_count                         = 2;  // The total number of items.
}