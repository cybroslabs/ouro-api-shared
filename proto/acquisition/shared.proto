// Editions version of proto3 file
edition = "2023";
package io.clbs.openhes.models.acquisition;

option go_package = "github.com/cybroslabs/ouro-api-shared/gen/go/acquisition";

import "google/protobuf/empty.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";
import "common/messages.proto";
import "common/fields.proto";
import "common/metadata.proto";
import "common/types.proto";
import "acquisition/timeofuse/timeofuse.proto";

// Job priorities
enum JobPriority {
    // The lowest priority
    JOB_PRIORITY_0 = 0;
    // The priority 1
    JOB_PRIORITY_1 = 1;
    // The priority 2
    JOB_PRIORITY_2 = 2;
    // The priority 3
    JOB_PRIORITY_3 = 3;
    // The priority 4
    JOB_PRIORITY_4 = 4;
    // The priority 5
    JOB_PRIORITY_5 = 5;
    // The priority 6
    JOB_PRIORITY_6 = 6;
    // The priority 7
    JOB_PRIORITY_7 = 7;
    // The highest priority
    JOB_PRIORITY_8 = 8;
}

// Sub-message containing job parameters
message JobSettings {
    google.protobuf.Duration max_duration = 1;  // Maximum duration of the job attempt. This is related to the real time for the driver.
    JobPriority priority                  = 2;  // Priority of the job.
    repeated int32 attempts               = 3;  // Maximum number of attempts, 1 is the minimum.
    google.protobuf.Duration retry_delay  = 4;  // Delay between two attempts.
    google.protobuf.Duration defer_start  = 5;  // Time to wait before starting the job.
    google.protobuf.Timestamp expires_at  = 6;  // The timestamp when the job expires.
}

// Sub-message containing job action specification.
// The JobAction is used to define a single action to be performed on a single device.
// For example, if the JobAction is of the ActionGetRegister type then it specifies single register to be read from the devices.
message JobAction {
    string action_id                          = 1;  // The action identifier.
    map<string, common.FieldValue> attributes = 2;  // The action attributes.
    oneof action {
        ActionGetRegister get_register                    = 3;   // The get register action specification.
        ActionGetPeriodicalProfile get_periodical_profile = 4;   // The get periodical profile action specification.
        ActionGetIrregularProfile get_irregular_profile   = 5;   // The get irregular profile action specification.
        ActionGetEvents get_events                        = 6;   // The get events action specification.
        ActionGetDeviceInfo get_device_info               = 7;   // The get device info action specification.
        ActionSyncClock sync_clock                        = 8;   // The sync clock action specification.
        ActionSetRelayState set_relay_state               = 10;  // The set relay state action specification.
        ActionSetDisconnectorState set_disconnector_state = 12;  // The set disconnector state action specification.
        ActionGetTou get_tou                              = 13;  // The get tou action specification.
        ActionSetTou set_tou                              = 14;  // The set tou action specification.
        ActionSetLimiter set_limiter                      = 16;  // The set limiter action specification.
        ActionResetBillingPeriod reset_billing_period     = 17;  // The reset billing period action specification.
        ActionFwUpdate fw_update                          = 18;  // The firmware update action specification.
    }
}

// Sub-message containing job action set specification.
// In comparison the JobAction shall be used only once per bulk but internally it may cover multiple JobActions.
// For example, if the JobActionSet is of the ActionGetRegister type and no variables filter is set
// then then system gets all registers defined for active device configuration template and reads them all.
message JobActionSet {
    // The filter, meaning depends on the action.
    // - GetRegister, GetPeriodicalProfile and GetIrregularProfile: It's the list of variable identifiers, e.g. "A+" defined in the system. If not set then all variables are read.
    // - Others: Not applicable, ignored.
    repeated string variables = 2;
    oneof action {
        ActionGetRegister get_register                    = 3;   // The get register action specification.
        ActionGetPeriodicalProfile get_periodical_profile = 4;   // The get periodical profile action specification.
        ActionGetIrregularProfile get_irregular_profile   = 5;   // The get irregular profile action specification.
        ActionGetEvents get_events                        = 6;   // The get events action specification.
        ActionGetDeviceInfo get_device_info               = 7;   // The get device info action specification.
        ActionSyncClock sync_clock                        = 8;   // The sync clock action specification.
        ActionSetRelayState set_relay_state               = 10;  // The set relay state action specification.
        ActionSetDisconnectorState set_disconnector_state = 12;  // The set disconnector state action specification.
        ActionGetTou get_tou                              = 13;  // The get tou action specification.
        ActionSetTou set_tou                              = 14;  // The set tou action specification.
        ActionSetLimiter set_limiter                      = 16;  // The set limiter action specification.
        ActionResetBillingPeriod reset_billing_period     = 17;  // The reset billing period action specification.
        ActionFwUpdate fw_update                          = 18;  // The firmware update action specification.
    }
}

// Sub-message - holds the bulk job specification.

message ListOfJobDevice {
    repeated JobDevice list = 1;  // The list of devices in the bulk.
    int32 total_count       = 2;  // The total number of items.
}

message ListOfJobDeviceId {
    repeated JobDeviceId list = 1;  // The list of devices in the bulk.
    int32 total_count         = 2;  // The total number of items.
}

message JobDeviceId {
    string job_id    = 1;  // The device's job identifier within the parent bulk.
    string device_id = 2;  // The device identifier.
}

// Sub-message representing a single job-device info.
message JobDevice {
    string job_id                                    = 1;  // The device's job identifier within the parent bulk.
    string device_id                                 = 2;  // The device identifier. If set then all below is loaded from the device registry.
    string external_id                               = 3;  // The external identifier.
    map<string, common.FieldValue> device_attributes = 4;  // The connection attributes to the device, see options in the ApplicationProtocolTemplate for given application protocol (see app_protocol property).
    repeated ConnectionInfo connection_info          = 5;  // The connection (device) parameters.
    ApplicationProtocol app_protocol                 = 6;  // The application protocol.
    string timezone                                  = 7;  // The timezone related to the device, e.g. "America/New_York", "Europe/Prague", "CET", "GMT", "Etc/GMT+2".
}

// Sub-message containing modem connection info
message ModemInfo {
    string modem_id                          = 1;  // The modem identifier. It is automatically generated during creation.
    string name                              = 2;  // The name of the modem.
    string at_init                           = 3;  // The modem initialization command, e.g. AT&FE0X3
    string at_dial                           = 4;  // The modem dial command, e.g. ATD.
    string at_hangup                         = 5;  // The modem hangup command, e.g. ATH.
    string at_escape                         = 6;  // The modem escape command, e.g. +++.
    google.protobuf.Duration connect_timeout = 7;  // The modem connection timeout, if applicable given by the modem_connection field.
    google.protobuf.Duration command_timeout = 8;  // The modem command timeout, if applicable given by the modem_connection field.
    // The modem connection description.
    oneof modem_connection {
        ConnectionTypeDirectTcpIp tcpip               = 9;   // The TCP connection type. The modem has either TCP or there is a IP-to-serial converter which handles the serial configuration so no additional serial configuration is needed.
        ConnectionTypeControlledSerial serial_over_ip = 10;  // The serial over IP connection type. The modem is connected behind an IP-to-serial converter and needs connection specific handling.
    }
    uint32 serial_baud_rate = 11;  // The serial baud rate, if applicable given by the modem_connection field.
}

// Parity types
enum SerialConfigParity {
    // No parity
    PARITY_NONE = 0;
    // Even parity
    PARITY_EVEN = 1;
    // Odd parity
    PARITY_ODD = 2;
    // Mark parity
    PARITY_MARK = 3;
    // Space parity
    PARITY_SPACE = 4;
}

// Baud rate types
enum SerialConfigBaudRate {
    // 110 baud
    BAUD_RATE_110 = 0;
    // 300 baud
    BAUD_RATE_300 = 1;
    // 600 baud
    BAUD_RATE_600 = 2;
    // 1200 baud
    BAUD_RATE_1200 = 3;
    // 2400 baud
    BAUD_RATE_2400 = 4;
    // 4800 baud
    BAUD_RATE_4800 = 5;
    // 9600 baud
    BAUD_RATE_9600 = 6;
    // 14400 baud
    BAUD_RATE_14400 = 7;
    // 19200 baud
    BAUD_RATE_19200 = 8;
    // 38400 baud
    BAUD_RATE_38400 = 9;
    // 57600 baud
    BAUD_RATE_57600 = 10;
    // 115200 baud
    BAUD_RATE_115200 = 11;
    // 230400 baud
    BAUD_RATE_230400 = 12;
    // 460800 baud
    BAUD_RATE_460800 = 13;
    // 921600 baud
    BAUD_RATE_921600 = 14;
}

// Data bits types
enum SerialConfigDataBits {
    // 5 data bits
    DATA_BITS_5 = 0;
    // 6 data bits
    DATA_BITS_6 = 1;
    // 7 data bits
    DATA_BITS_7 = 2;
    // 8 data bits
    DATA_BITS_8 = 3;
}

// Stop bits types
enum SerialConfigStopBits {
    // 1 stop bit
    STOP_BITS_1 = 0;
    // 1.5 stop bits
    STOP_BITS_1_5 = 1;
    // 2 stop bits
    STOP_BITS_2 = 2;
}

// Sub-message containing serial port configuration
message SerialConfig {
    SerialConfigBaudRate baud_rate = 1;  // The baud rate.
    SerialConfigParity parity      = 2;  // The parity.
    SerialConfigDataBits data_bits = 3;  // The data bits.
    SerialConfigStopBits stop_bits = 4;  // The stop bits.
}

// Sub-message containing connection info
message ConnectionInfo {
    // The entrypoint connection description. It can be either direct TCP, a modem from a pool or a direct serial line over IP (using IP-to-serial converter).
    oneof connection {
        ConnectionTypeDirectTcpIp tcpip               = 1;  // The TCP connection type.
        ConnectionTypeModemPool modem_pool            = 2;  // The phone connection type.
        ConnectionTypeControlledSerial serial_over_ip = 3;  // The serial over IP connection type.
    }
    DataLinkProtocol link_protocol            = 4;  // The data link protocol.
    string communication_bus_id               = 5;  // The communication bus identifier. It behaves as a custom grouping key to link jobs together across multiple communication units. It shall be used in a situation when multiple entry points share single communication bus, e.g. multi-master RS-485 (primary and backup master). If not set then jobs are grouped by group-key defined based on the connection type.
    map<string, common.FieldValue> attributes = 6;  // The connection attributes, see GetDataLinkFields in the acquisition package.
}

// Sub-message containing connection info for TCP connection type
message ConnectionTypeDirectTcpIp {
    string host                      = 1;  // The host name or IP address of the device to connect to.
    uint32 port                      = 2;  // The TCP port number of the device to connect to.
    google.protobuf.Duration timeout = 3;  // The timeout for TCP/IP connection.
}

// Sub-message containing connection info for phone line (modem) connection type
message ConnectionTypeModemPool {
    // The phone number of the device to connect to.
    string number = 1;
    // The modem pool identifier. The pool is a group of modems that can be used to connect to the device. Final modem is selected by the Taskmaster at the time of the job start.
    string pool_id = 2;
    // The modem device assigned to the job. This is filled only and only when the connection type is modem. The value is assigned by the Taskmaster when to job is being started. Driver is required to use this modem device to connect to the meter only and only for the time of this job!
    ModemInfo modem = 4;
}

message ConnectionTypeSerialDirect {
    string host                      = 1;  // The host name or IP address of the device to connect to.
    uint32 port                      = 2;  // The TCP port number of the device to connect to.
    google.protobuf.Duration timeout = 3;  // The timeout for direct serial port connection.
}

// Sub-message containing connection info for controlled-serial line (Moxa) connection type
message ConnectionTypeSerialMoxa {
    string host                      = 1;  // The host name or IP address of the device to connect to.
    uint32 dataPort                  = 2;  // The TCP port number of the device to connect to - data port.
    uint32 command_port              = 3;  // The TCP port number of the device to connect to - command port.
    google.protobuf.Duration timeout = 4;  // The timeout for serial port connection that implements the Moxa protocol.
}

// Sub-message containing connection info for controlled-serial line (RFC 2217) connection type
message ConnectionTypeSerialRfc2217 {
    string host                      = 1;  // The host name or IP address of the device to connect to.
    uint32 port                      = 2;  // The TCP port number of the device to connect to.
    google.protobuf.Duration timeout = 3;  // The timeout for serial port connection that implements the RFC 2217 protocol.
}

// Connection types
enum CommunicationType {
    // The communication is done via direct TCP/IP.
    COMMUNICATION_TYPE_TCPIP = 0;
    // The communication is done via phone line (modem).
    COMMUNICATION_TYPE_MODEM_POOL = 1;
    // The communication is done via direct serial line.
    COMMUNICATION_TYPE_SERIAL_LINE_DIRECT = 2;
    // The communication is done via controller-serial line (Moxa).
    COMMUNICATION_TYPE_SERIAL_LINE_MOXA = 3;

    // The communication is passive, the driver is a service that listens on a port (DLMS devices in push mode) or a service that implements a subscriber to a message queue (e.g. MQTT).
    COMMUNICATION_TYPE_LISTENING = 99;
}

// Data link protocols
enum DataLinkProtocol {
    // The VDEW (IEC 62056-21, IEC-61107) protocol. In combination with DLMS protocol the driver initiates the communication by IEC and switches to the mode E to the HDLC+DLMS protocol. Supports addressing = multiple devices on the same line.
    LINKPROTO_IEC_62056_21 = 0;
    // The HDLC (ISO/IEC-3309) framing. It can be used for various application protocols, such as DLMS or MODBUS. Supports client/server addressing = multiple devices on the same line.
    LINKPROTO_HDLC = 1;
    // The COSEM wrapper. It can be used for DLMS application protocol. Supports client/server addressing = multiple devices on the same line.
    LINKPROTO_COSEM_WRAPPER = 2;
    // The Modbus protocol. It shall be used for Modbus application protocol where no other data link layer, such as HDLC, is used.
    LINKPROTO_MODBUS = 3;
    // The M-Bus protocol. It shall be used for M-Bus application protocol.
    LINKPROTO_MBUS = 4;
    // The Viktor protocol. It is a proprietary protocol used by Viktor-based devices, such as DC450 Vitkor.
    LINKPROTO_VIKTOR = 5;

    // The data link protocol is not applicable. It's useful for listening communication type.
    LINKPROTO_NOT_APPLICABLE = 99;
}

// Application protocols
enum ApplicationProtocol {
    // The IEC 62056-21 (IEC-61107, VDEW) protocol.
    APPPROTO_IEC_62056_21 = 0;
    // The DLMS short-name protocol.
    APPPROTO_DLMS_SN = 1;
    // The DLMS logical-name protocol.
    APPPROTO_DLMS_LN = 2;
    // The SCTM protocol.
    APPPROTO_SCTM = 3;
    // The LIS200 protocol.
    APPPROTO_LIS200 = 4;
    // The ANSI C12 protocol.
    APPPROTO_ANSI_C12 = 5;
    // The MQTT protocol.
    APPPROTO_MQTT = 6;
    // The MODBUS procotocol.
    APPPROTO_MODBUS = 7;
    // The MBUS protocol.
    APPPROTO_MBUS = 8;
}

// Sub-message containing destription for one application protocol, e.g. DLMS_SN.
message ApplicationProtocolTemplate {
    // The application protocol.
    ApplicationProtocol protocol = 1;
    // The list of attribute definitions for the application protocol and those will be instantiated for each device & communication unit pair.
    repeated common.FieldDescriptor attributes = 2;
}

// Sub-message containing destription for one data link protocol, e.g. HDLC.
message DataLinkTemplate {
    // The data link protocol.
    DataLinkProtocol link_protocol = 1;
    // The list of application protocol identifiers supported by the driver.
    repeated ApplicationProtocol app_protocol_refs = 2;
    // The list of attribute definitions related to given data link type (see link_protocol property). The field definitions are taken from the system, drivers must leave this empty.
    repeated common.FieldDescriptor attributes = 3;
}

// Sub-message containing destription for one communication type, e.g. TCP/IP.
message CommunicationTemplate {
    // The type of the communication.
    CommunicationType type = 1;
    // The list of data link protocols and their app protocols supported by the driver.
    repeated DataLinkTemplate datalinks = 2;
}

// Sub-message containing access level definition
message AccessLevelTemplate {
    string id   = 1;  // The access level identifier, such as "1", "G", "16" or similar.
    string name = 2;  // The access level name. Should be in English and unique for given driver, e.g. "Management", "Public".
}

// Sub-message in driver negotiation request
message DriverTemplates {
    // The templates of the communication options. Every template represents an option how the drivers allows to communicate. The driver can support multiple communication templates.
    repeated CommunicationTemplate communication_templates = 1;
    // The templates of the application protocols supported by the driver.
    repeated ApplicationProtocolTemplate app_protocols = 2;
    // The templates of the job actions for all supported action types. It must contain every action type supported by the driver once and only once.
    repeated JobActionAttributes action_attributes = 3;
    // The templates of the access levels supported by the driver.
    repeated AccessLevelTemplate access_templates = 4;
    // The templates of the job actions constraints.
    JobActionContraints action_constraints = 5;
    // The list of descriptors related to the uknown devices visible to the communication unit.
    // This relates only to the drivers that communications with a device like data-concentrator that can provide information for unknown devices.
    // The descripts must cover all data attributes which drivers sets in the SetUnknownDevicesRequest message.
    repeated common.FieldDescriptor uknown_device_descriptors = 6;
}

// Sub-message containing action progress update
message ActionProgressUpdate {
    string job_id                         = 1;  // The job identifier.
    string action_id                      = 2;  // The action identifier.
    ActionResultCode code                 = 3;  // The status related to the action.
    ActionData data                       = 4;  // The action result data. Shall be empty if the code is not OK.
    common.FormattedMessage error_message = 5;  // The user error message related to the action which ends up with code ERROR_CODE_ACTION_ERROR, if any. It is used to provide more details about the action result. It can be multiline and should be in English language.
}

// Sub-message containing job progress update
message JobProgressUpdate {
    string job_id                     = 1;  // The job identifier.
    JobErrorCode code                 = 2;  // The status related to the job and or action update message.
    google.protobuf.Duration duration = 3;  // The time spent to handle the job.
}

// Sub-message containing action-based variant of data values
message ActionData {
    oneof data {
        google.protobuf.Empty nodata             = 1;  // No data
        RegisterValues registers                 = 2;  // Register values
        ProfileValues profile                    = 3;  // Profile values
        IrregularProfileValues irregular_profile = 4;  // Irregular (non-periodical) profile values, e.g. daily profile
        DeviceInfo device_info                   = 5;  // Device info
        EventRecords events                      = 6;  // Event records
        timeofuse.TimeOfUseTableSpec tou_table   = 7;  // The time-of-use table.
    }
}

// Sub-message containing event records
message EventRecords {
    repeated EventRecord values = 1;  // The list of events.
}

// Sub-message describing a single event.
message EventRecord {
    google.protobuf.Timestamp timestamp = 1;  // The timestamp of the event.
    int64 event_id                      = 2;  // The identifier of the event.
    int64 event_code                    = 3;  // The code of the event as generated by the device.
    string event_source                 = 5;  // The event source.
    string event_text                   = 4;  // The text of the event.
}

// Sub-message containing event data
message DeviceEventRecord {
    string device_id                    = 1;  // The device identifier.
    google.protobuf.Timestamp timestamp = 2;  // The timestamp of the event.
    int64 event_id                      = 3;  // The identifier of the event.
    int64 event_code                    = 4;  // The code of the event as generated by the device.
    string event_source                 = 5;  // The event source.
    string event_text                   = 6;  // The text of the event.
}

// Message containing a list of device events.
message DeviceEvents {
    // The list of device events.
    repeated DeviceEventRecord events = 1;
}

// Message holds common device information.
message DeviceInfo {
    google.protobuf.Timestamp info_timestamp = 1;  // The timestamp when the values were read.
    string manufacturer_serial_number        = 2;  // The serial number of the device set by manufacturer. Typical source: 0-0:42.0.0.255
    string device_serial_number              = 3;  // The device serial number of the device.  Typical source: 0-0:96.1.0.255
    string firmware_version                  = 4;  // The firmware version identifier of the device. Typical source: 0-0:0.2.0.255
    google.protobuf.Duration clock_delta     = 5;  // The clock delta against acquisition server clock (got by a driver) where positive value means that the device clock is ahead of local clock and vice versa.
    string device_model                      = 6;  // The model of the device.
    uint64 error_register                    = 7;  // The error register 0. Typical source: 0-0:97.97.1.255 (higher 32-bit) + 0-0:97.97.0.255 (lower 32-bit)
    repeated bool relay_states               = 8;  // The list of relay states. The order of the relays is the same as in the device. The value is true if the relay is connected and false if the relay is disconnected.
    bool connection_state                    = 9;  // The state of the connection. It represents the disconnector state where true means that the customer is connected and false means that the customer is disconnected.
}

// Sub-message containing profile-typed values
message ProfileValues {
    int32 period                 = 1;  // The period of the profile values.
    string unit                  = 2;  // The unit of the profile values.
    repeated ProfileBlock blocks = 3;  // The list of continuous profile blocks.
}

message IrregularProfileValues {
    string unit                    = 1;  // The unit of the profile values.
    repeated IrregularValue values = 2;  // The list of continuous profile blocks.
}

message IrregularValue {
    google.protobuf.Timestamp timestamp = 1;  // The timestamp of the value.
    MeasuredValue value                 = 2;  // The value.
}

// Sub-message containing a single profile block
message ProfileBlock {
    google.protobuf.Timestamp start_timestamp = 1;  // The start timestamp of the block.
    repeated MeasuredValue values             = 2;  // The list of profile values. Values are ordered by timestamp.
}

// Sub-message containing register-typed values
message RegisterValues {
    repeated RegisterValue values = 1;  // The list of register values.
}

// Sub-message containing register-typed value
message RegisterValue {
    google.protobuf.Timestamp timestamp = 1;  // The timestamp of the value.
    string unit                         = 2;  // The unit of the value.
    MeasuredValue value                 = 3;  // The value.
}

// Sub-message containing measured value
message MeasuredValue {
    int64 status   = 1;  // The status of the value.
    int32 exponent = 2;  // The exponent of the value. It's used to calculate the real value as value * 10^exponent for double and int values.
    oneof kind {
        double double_value                       = 3;  // The double-typed value.
        int64 integer_value                       = 4;  // The integer-typed value.
        string string_value                       = 5;  // The string-typed value.
        google.protobuf.Timestamp timestamp_value = 6;  // The timestamp-typed value.
        string timestamp_tz_value                 = 7;  // The timestamp with timezone-typed value, stored as string in ISO-8601.
        bool bool_value                           = 8;  // The boolean-typed value.
    }
    uint64 nstatus                    = 9;   // The normalized status of the value, see StatusBits enum for more details.
    google.protobuf.Timestamp peak_ts = 10;  // The timestamp when the value (e.g. peak) was recorded. It's typically before the capture timestamp.
}

// Sub-message containing job action attributes
message JobActionAttributes {
    // The type of action for which this instance of the template is defined.
    ActionType type = 1;
    // The template of the action attributes. It is represented as a list of attribute definitions.
    repeated common.FieldDescriptor attributes = 2;
}

// Sub-message containing connection info for controlled-serial line over IP (e.g. Moxa) connection type
message ConnectionTypeControlledSerial {
    // IP-to-serial converter description.
    oneof converter {
        ConnectionTypeSerialDirect direct   = 1;  // The simple direct serial connection type.
        ConnectionTypeSerialMoxa moxa       = 2;  // The Moxa connection type.
        ConnectionTypeSerialRfc2217 rfc2217 = 3;  // The RFC 2217 connection type.
        // TBA: Add Advanctech and other IP-to-serial converters.
    }
}

// Action types
enum ActionType {
    // Get register value, for example instantaneous values. The action covers specific register.
    ACTION_TYPE_GET_REGISTER = 0;
    // Get periodical profile, for example load-profile. The action covers specific profile column.
    ACTION_TYPE_GET_PERIODICAL_PROFILE = 1;
    // Get non-periodical profile, for example daily profile or monthly billing registers. The action covers specific profile column and or specific billing register.
    ACTION_TYPE_GET_IRREGULAR_PROFILE = 2;
    // Get event log. The action covers specific event log.
    ACTION_TYPE_GET_EVENTS = 3;

    // Get device info. The action returns info data about remote device.
    ACTION_TYPE_GET_DEVICE_INFO = 10;

    // Synchronize clock. The action synchronizes the time in the device, it can forcefully set it if force attribute is set.
    ACTION_TYPE_SYNC_CLOCK = 11;

    // Set relay state. The action covers single relay.
    ACTION_TYPE_SET_RELAY_STATE = 21;

    // Get disconnector state. The action covers single disconnector if multiple disconnectors are present in the device.
    ACTION_TYPE_GET_DISCONNECTOR_STATE = 22;
    // Set disconnector state. The action covers single relay. The action covers single disconnector if multiple disconnectors are present in the device.
    ACTION_TYPE_SET_DISCONNECTOR_STATE = 23;

    // Get time-of-use table.
    ACTION_TYPE_GET_TOU = 24;
    // Set time-of-use table.
    ACTION_TYPE_SET_TOU = 25;

    // Set limiter settings. The action covers single limiter.
    ACTION_TYPE_SET_LIMITER = 27;

    // Reset billing period.
    ACTION_TYPE_RESET_BILLING_PERIOD = 40;

    // Start firmware update. The action updates starts FW upgrade procedure.
    ACTION_TYPE_FW_UPDATE = 50;
}

// Sub-message containing get register action specification
message ActionGetRegister {
    common.FieldDataType data_type = 1;  // The data type of the target register, e.g. integer, double, string, timestamp, etc. This value can be specified for proxy bulk, while it's automatically taken from the register definition in the system for bulks.
}

// Sub-message containing get periodical profile action specification
message ActionGetPeriodicalProfile {
    google.protobuf.Timestamp from = 1;  // The start timestamp of the profile.
    google.protobuf.Timestamp to   = 2;  // The end timestamp of the profile.
    common.FieldDataType data_type = 3;  // The data type of the target register, e.g. integer, double, string, timestamp, etc. This value can be specified for proxy bulk, while it's automatically taken from the register definition in the system for bulks.
}

// Sub-message containing get irregular profile action specification
message ActionGetIrregularProfile {
    google.protobuf.Timestamp from = 1;  // The start timestamp of the profile.
    google.protobuf.Timestamp to   = 2;  // The end timestamp of the profile.
    common.FieldDataType data_type = 3;  // The data type of the target register, e.g. integer, double, string, timestamp, etc. This value can be specified for proxy bulk, while it's automatically taken from the register definition in the system for bulks.
}

// Sub-message containing get events action specification
message ActionGetEvents {
    google.protobuf.Timestamp from = 1;  // The start timestamp of the profile.
    google.protobuf.Timestamp to   = 2;  // The end timestamp of the profile.
}

// Sub-message containing get device info action specification
message ActionGetDeviceInfo {
}

// Sub-message containing sync clock action specification
message ActionSyncClock {
}

// Sub-message containing set relay state action specification
message ActionSetRelayState {
}

// Sub-message containing set disconnector state action specification
message ActionSetDisconnectorState {
}

// Sub-message containing get tou action specification
message ActionGetTou {
    bool passive = 1;  // Identifies whether to read passive TOU table. By default it is set to false to read active TOU table.
}

// Sub-message containing set tou action specification
message ActionSetTou {
    timeofuse.TimeOfUseTableSpec table = 1;  // The time-of-use table to be set.
}

// Sub-message containing set limiter action specification
message ActionSetLimiter {
}

// Sub-message containing reset billing period action specification
message ActionResetBillingPeriod {
}

// Sub-message containing firmware update action specification
message ActionFwUpdate {
}

// Result codes related to job actions
enum ActionResultCode {
    // The action has been completed successfully.
    ERROR_CODE_ACTION_OK = 0;
    // The action is not supported by the driver (or device).
    ERROR_CODE_ACTION_UNSUPPORTED = 1;
    // The action is pending.
    ERROR_CODE_ACTION_PENDING = 3;
    // The action failed.
    ERROR_CODE_ACTION_ERROR = 5;
}

// Error codes related to jobs
enum JobErrorCode {
    // The job has been completed successfully.
    JOB_ERROR_CODE_NONE = 0;
    // There is no free slot in the driver to handle the job; the job shall be send again later.
    JOB_ERROR_CODE_BUSY = 1;
    // The job failed, the retry will be attempted.
    JOB_ERROR_CODE_ERROR = 5;
    // This should never happen! It means that the same job is currently being processed by the driver and it was sent to the driver mutliple times which would mean that there is a bug.
    JOB_ERROR_CODE_ALREADY_EXISTS = 8;
    // The job failed, the retry will NOT be attempted.
    JOB_ERROR_CODE_FATAL = 9;
}

// Sub-message containing constraints for job actions.
message JobActionContraints {
    // Contains all the register types & their names in the English language. For example: [gen]="Generic Register", [vqi]="Quality VQI Register"
    // Action: ACTION_TYPE_GET_REGISTER
    map<string, string> get_register_type_name = 1;
    // Contains all the register types & their attributes. For example: [gen]=["attribute1", "attribute2"], [vqi]=["attribute1", "attribute3"]
    // See JobActionAttributes for the attribute definitions.
    // Action: ACTION_TYPE_GET_REGISTER
    map<string, common.ListOfString> get_register_type_attributes = 2;
}

// Bulk statuses
enum BulkStatusCode {
    // The job is waiting in the queue
    BULK_STATUS_QUEUED = 0;
    // The job is running
    BULK_STATUS_RUNNING = 1;
    // The job is completed
    BULK_STATUS_COMPLETED = 2;
    // The job is cancelled
    BULK_STATUS_CANCELLED = 3;
    // The job has expired
    BULK_STATUS_EXPIRED = 4;
}

// Sub-message containing job status info
message JobStatus {
    JobStatusCode status                  = 1;  // The status of the job.
    JobErrorCode code                     = 2;  // The error code of the job.
    repeated ActionResult results         = 3;  // The result data for all job actions.
    google.protobuf.Timestamp started_at  = 4;  // The start timestamp of the job.
    google.protobuf.Timestamp finished_at = 5;  // The finish timestamp of the job.
    int32 attempts_done                   = 6;  // The number of attempts already done.
    DeviceInfo device_info                = 7;  // The device info. It contains the data from the action ACTION_TYPE_GET_DEVICE_INFO.
    int64 queue_id                        = 8;  // The internal queue identifier set by the Taskmaster when the job is queued to process.
}

// Sub-message containing job start request for single device
message StartJobData {
    map<string, common.FieldValue> device_attributes = 1;  // The device attributes. For example HDLC address, password and other driver-specific attributes.
    string job_id                                    = 2;  // The job identifier.
    JobSettings job_settings                         = 3;  // The job parameters.
    repeated JobAction job_actions                   = 4;  // The list actions to be executed.
    ApplicationProtocol app_protocol                 = 5;  // The application protocol.
    string timezone                                  = 6;  // The timezone related to the device, e.g. "America/New_York", "Europe/Prague", "CET", "GMT", "Etc/GMT+2".
}

// Taskmaster -> Driver cancel job request message
message CancelJobRequest {
    string job_id = 1;  // The job identifier.
}

enum RegisterType {
    // The register is a generic register.
    Register = 0;
    // The register is part of a periodical profile.
    PeriodicalProfile = 1;
    // The register is part of an irregular profile.
    IrregularProfile = 2;
    // Synthetic register, not visible by drivers. It can be defined to store derived or external data.
    Synthetic = 99;
}

message DeviceConfigurationRegisterSpec {
    string driver_type                        = 1;  // The device (driver) type.
    RegisterType register_type                = 2;  // The type of action for which the register is defined.
    map<string, common.FieldValue> attributes = 3;  // The field values.
    common.FieldDataType data_type            = 4;  // The data type of the register;
}

// Addon
message DeviceRegister {
    int64 register_id                    = 1;  // The register identifier.
    string public_register_id            = 2;  // The public register identifier.
    DeviceConfigurationRegisterSpec spec = 3;  // The register spec.
    repeated string variable_name        = 4;  // The name of the variable, if the register is assigned to some.
}

// Addon
message DeviceConnectionInfo {
    ConnectionInfo communication_unit                = 1;  // The unique identifier of the communication unit.
    ApplicationProtocol app_protocol                 = 2;  // The application protocol to be used for the communication over the communication unit.
    map<string, common.FieldValue> device_attributes = 3;  // The device attributes. For example HDLC address, password and other driver-specific attributes.
    string timezone                                  = 4;  // The timezone related to the device, e.g. "America/New_York", "Europe/Prague", "CET", "GMT", "Etc/GMT+2".
    string driver_type                               = 5;  // The driver type identifier.
    string driver_version                            = 7;  // The driver version.
    repeated DeviceRegister registers                = 8;  // The list of registers get using current device configuration template.
}

// Addon for DB
message ListOfModemInfo {
    repeated ModemInfo items = 1;
    int32 total_count        = 2;  // The total number of items.
}

// Addon for DB
message ListOfConnectionInfo {
    repeated DeviceConnectionInfo items = 1;
    int32 total_count                   = 2;  // The total number of items.
}

// Addon for DB
message FieldValuesList {
    repeated common.FieldValues items = 1;  // The list of field values.
}

// Generic attribute selector using field values
message AttributeSelector {
    string field_id = 1;                          // The field identifier
    common.FilterOperator operator = 2;           // The filter operator.
    common.FieldDataType data_type          = 3;  // The data type of the field.
    repeated string text                    = 4;  // The text-typed value(s) used for filtering.
    repeated sint64 integer                 = 5;  // The integer-typed value(s) used for filtering.
    repeated double number                  = 6;  // The number-typed value(s) used for filtering.
    repeated bool boolean                   = 7;  // The boolean-typed value(s) used for filtering.
    repeated google.protobuf.Timestamp date = 8;  // The date-typed value(s) used for filtering.
}

// Generic attribute selector using field values for devices
message DeviceAttributeSelector {
    repeated AttributeSelector attributes = 2;  // The list of field values.
}

// Generic attribute selector using field values for devices
message CommunicationUnitAttributeSelector {
    DataLinkProtocol link_protocol        = 1;  // The application protocol to be used for the communication over the communication unit.
    repeated AttributeSelector attributes = 2;  // The list of field values.
}

// Job statuses
enum JobStatusCode {
    // The job is waiting in the queue
    JOB_STATUS_QUEUED = 0;
    // The job is running
    JOB_STATUS_RUNNING = 1;
    // The data has been fully acquired and is being processed
    JOB_STATUS_PROCESSING_DATA = 2;
    // The job is completed
    JOB_STATUS_COMPLETED = 3;
    // The job is failed
    JOB_STATUS_FAILED = 4;
    // The job is cancelled
    JOB_STATUS_CANCELLED = 5;
    // The job has expired
    JOB_STATUS_EXPIRED = 6;
}

// Sub-message containing action result for a single action.
message ActionResult {
    string action_id                      = 1;  // The action identifier.
    ActionResultCode status               = 2;  // The status of the action.
    ActionData data                       = 3;  // The action result data.
    string register_id                    = 4;  // The register identifier. It is a read-only value, set only if the action data are related to a register. The value is applicable only and only for results for regular bulks.
    repeated string variable_name         = 5;  // The variable name(s). It is a read-only value, set only if the action data are related to one or more variables based on device template mapping. The value is applicable only and only for results for regular bulks.
    common.FormattedMessage error_message = 6;  // The user error message related to the action which ends up with code ERROR_CODE_ACTION_ERROR, if any. It is used to provide more details about the action result. It can be multiline and should be in English language.
}

// Taskmaster -> Dataproxy job/action progress update message
message JobEventData {
    bytes job_id = 1;  // The job identifier.
}

// Sub-message - the device specification.
message DeviceSpec {
    // @gqltype: UUID
    string dct_id                                            = 1;  // The device configuration template identifier.
    string external_id                                       = 2;  // The external identifier of the device.
    repeated DeviceCommunicationUnit communication_unit_link = 3;  // The list of communication unit identifiers (and additional info) that set CUs usable to communicate with the device. It's an ordered set where the first element is the primary communication unit with the highest priority.
    string timezone                                          = 4;  // The timezone related to the device, e.g. "America/New_York", "Europe/Prague", "CET", "GMT", "Etc/GMT+2".
}

message DeviceStatus {
    DeviceInfo info    = 1;  // The device info.
    string driver_type = 2;  // The driver type selecte by it's device configuration template.
}

message DeviceCommunicationUnit {
    string communication_unit_id              = 1;  // The unique identifier of the communication unit.
    ApplicationProtocol app_protocol          = 2;  // The application protocol to be used for the communication over the communication unit.
    map<string, common.FieldValue> attributes = 3;  // The app-protocol related device attributes. It is represented as a list of attribute definitions.
}

// Sub-message - job specification
message JobSpec {
    JobDevice device                            = 2;  // The device info.
    acquisition.JobSettings job_settings        = 3;  // The job parameters.
    string driver_type                          = 4;  // The device (driver) type.
    repeated acquisition.JobAction job_actions  = 5;  // The list actions to be executed.
    repeated JobActionMapRecord job_action_info = 6;  // The mapping data for all actions.
}

message JobActionMapRecord {
    int32 action_index            = 1;  // The index of the action in the job_actions list.
    int64 register_id             = 3;  // The internal register identifier.
    string public_register_id     = 2;  // The register identifier.
    repeated string variable_name = 4;  // The name of the variable, if the register is assigned to some.
}

// Message used to notify DP that the job is done, sent by Taskmaster
message JobDoneNotification {
    JobSpec spec     = 1;  // The job specification.
    JobStatus status = 2;  // The status of the job
}

// Sub-message containing driver info
message DriverInfo {
    string driver_type = 1;  // The driver unique identifier.
    string version     = 2;  // The version of the driver.
}

message CommunicationUnit {
    reserved 2;                          // reserved for status
    CommunicationUnitSpec spec     = 1;  // The communication unit specification.
    common.MetadataFields metadata = 3;  // The metadata fields.
}

message CommunicationUnitSpec {
    string external_id             = 1;  // The external identifier of the communication unit.
    ConnectionInfo connection_info = 2;  // The connection info.
}

message CommunicationBus {
    reserved 1;
    CommunicationBusStatus status  = 2;  // The communication bus status.
    common.MetadataFields metadata = 3;  // The metadata fields.
}

message CommunicationBusStatus {
    repeated string communication_unit_id = 1;  // The list of communication unit identifiers.
}

// Network map messages

enum TopologyNodeType {
    // The node is a device, such as an electricity meter.
    TOPOLOGY_NODE_DEVICE = 0;
    // The node is a communication unit, such as a modem or a data concentrator.
    TOPOLOGY_NODE_COMMUNICATION_UNIT = 1;
}

message TopologyNode {
    int64 x_id                    = 1;  // The unique identifier of the node.
    TopologyNodeType type         = 2;  // The type of the node, e.g. "device", "communication_unit", etc.
    common.FieldValues attributes = 3;  // The attributes of the node.
}

message TopologyEdge {
    int64 from_x_id               = 1;  // The unique identifier of the edge.
    int64 to_x_id                 = 2;  // The unique identifier of the edge.
    common.FieldValues attributes = 3;  // The attributes of the edge.
}

message NetworkMap {
    // Flat or hierarchical list of topology devices
    repeated TopologyNode nodes = 1;
    repeated TopologyEdge edges = 2;  // The list of edges between the devices.
}

// Communication Unit Log Records

enum LogRecordLevel {
    LOG_RECORD_LEVEL_DEBUG   = 0;  // The log record level is debug.
    LOG_RECORD_LEVEL_INFO    = 1;  // The log record level is info.
    LOG_RECORD_LEVEL_WARNING = 2;  // The log record level is warning.
    LOG_RECORD_LEVEL_ERROR   = 3;  // The log record level is error.
    LOG_RECORD_LEVEL_FATAL   = 4;  // The log record level is fatal.
}

message CommunicationUnitLogRecord {
    string id                           = 1;  // The unique identifier of the log record, if provided. If not provided, a hash of the log data is auto-generated.
    string communication_unit_id        = 2;  // The unique identifier of the communication unit to which the log record belongs. When adding the log records, it may be empty and relation can be set on the upper object level instead.
    google.protobuf.Timestamp timestamp = 3;  // The timestamp of the log record. It must not be empty.
    LogRecordLevel level                = 4;  // The log level of the log record, if provided.
    string message                      = 5;  // The log message. It must not be empty.
}

message ListOfCommunicationUnitLogRecord {
    repeated CommunicationUnitLogRecord items = 1;
    int32 total_count                         = 2;  // The total number of items.
}