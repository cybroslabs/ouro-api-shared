// Editions version of proto3 file
edition = "2023";
package io.clbs.openhes.models.acquisition;

option go_package = "github.com/cybroslabs/ouro-api-shared/gen/go/acquisition";

import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";
import "common/metadata.proto";
import "common/fields.proto";
import "acquisition/shared.proto";
import "acquisition/timeofuse/timeofuse.proto";

// Defines a specification for creating a new communication unit.
message CreateCommunicationUnitRequest {
    CommunicationUnitSpec spec     = 1;  // The communication unit specification.
    common.MetadataFields metadata = 2;  // The metadata fields.
}

// Defines a list of communication units.
message ListOfCommunicationUnit {
    repeated CommunicationUnit items = 1;  // The list of communication unit specifications.
    int32 total_count                = 2;  // The total number of items in the list.
}

// Defines a specification for creating a new communication bus.
message CreateCommunicationBusRequest {
    reserved 1;
    common.MetadataFields metadata = 2;  // The metadata fields.
}

// Defines a list of communication buses.
message ListOfCommunicationBus {
    repeated CommunicationBus items = 1;  // The list of communication unit buses.
    int32 total_count               = 2;  // The total number of items in the list.
}

// Defines a specification for adding communication units to a communication bus.
message AddCommunicationUnitsToCommunicationBusRequest {
    string communication_bus_id           = 1;  // The unique communication bus identifier.
    repeated string communication_unit_id = 2;  // A list of communication unit identifiers.
}

// Defines a specification for removing communication units from a communicaation bus.
message RemoveCommunicationUnitsFromCommunicationBusRequest {
    string communication_bus_id           = 1;  // The unique communication bus identifier.
    repeated string communication_unit_id = 2;  // A list of communication unit identifiers.
}

// Defines a specification for creating a new device.
message CreateDeviceRequest {
    DeviceSpec spec                = 1;  // The device specification.
    common.MetadataFields metadata = 2;  // The metadata fields.
}

// Defines a list of devices.
message ListOfDevice {
    repeated Device items = 1;  // The list of devices.
    int32 total_count     = 2;  // The total number of items.
}

// Defines a device model representing an energy meter or IoT device in the system.
// A device is a physical or logical entity that can be communicated with via one or more communication units,
// has a specific driver type for protocol handling, and belongs to device groups for organizational purposes.
message Device {
    DeviceSpec spec                = 1;  // The device specification containing configuration and identification details.
    DeviceStatus status            = 2;  // The current operational status including connection state and statistics.
    common.MetadataFields metadata = 3;  // Metadata including id, name, generation, user-managed fields, and system-managed fields.
}

// Defines a partial representation of driver types for a list of devices.
message StreamDevicesDriverTypesRequest {
    repeated string device_id = 1;  // The list of devices.
}

// Defines the mapping of devices to their driver types in a response.
message StreamDevicesDriverTypesResponse {
    map<string, string> data = 1;  // The map of devices to their driver types. The key is the unique device identifier, the value is the driver type.
}

// Defines the list of changes in device communication units.
message ListOfDeviceCommunicationUnitChange {
    repeated DeviceCommunicationUnitChange items = 1;  // The list of device groups.
    int32 total_count                            = 2;  // The total number of items in the list.
}

// Defines the changes in device communication units.
message DeviceCommunicationUnitChange {
    reserved 1, 3;
    DeviceCommunicationUnitChangeStatus status = 2;  // The device communication unit change status.
}

// Defines the status of the device communication unit change.
message DeviceCommunicationUnitChangeStatus {
    google.protobuf.Timestamp change_at = 1;  // The timestamp when the change occured.
    string communication_unit_id        = 2;  // The unique communication unit identifier.
    string communication_unit_name      = 3;  // The communication unit name.
    string device_id                    = 4;  // The unique device identifier.
    string device_name                  = 5;  // The device name.
}

// Defines an unknown device model representing devices discovered during network scanning but not yet registered in the system.
// Unknown devices are typically found by data concentrators or gateway devices during topology discovery.
// They can be promoted to registered devices once their configuration is verified.
message UnknownDevice {
    reserved 1;
    UnknownDeviceStatus status     = 2;  // The status information about the discovered device.
    common.MetadataFields metadata = 3;  // Metadata including id, name, generation, user-managed fields, and system-managed fields.
}

// Defines the status of an unknown device discovered during network scanning.
message UnknownDeviceStatus {
    string driver_type           = 1;  // The driver type that discovered this device, indicating the communication protocol.
    string communication_unit_id = 2;  // The identifier of the communication unit (gateway/concentrator) that discovered this device.
}

// Defines the specification for creating a new device group.
message CreateDeviceGroupRequest {
    DeviceGroupSpec spec           = 1;  // The device group specification.
    common.MetadataFields metadata = 2;  // The metadata fields.
}

// Defines a list of device groups.
message ListOfDeviceGroup {
    repeated DeviceGroup items = 1;  // The list of device groups.
    int32 total_count          = 2;  // The total number of items in the list.
}

// Defines a partial representation of a device group.
message StreamDeviceGroup {
    // The oneof field containing the device group partial data.
    oneof parts {
        DeviceGroupSpec spec           = 1;  // The device group specification.
        StreamDeviceGroupStatus status = 2;  // The device group status.
        common.MetadataFields metadata = 3;  // The metadata fields.
    }
}

// Defines a device group model for organizing devices into logical collections.
// Device groups are used to perform bulk operations, apply common configurations, and organize devices
// by location, type, or any other business logic. Devices can belong to multiple groups simultaneously.
message DeviceGroup {
    reserved 2;
    DeviceGroupSpec spec           = 1;  // The device group specification defining identification and type.
    common.MetadataFields metadata = 3;  // Metadata including id, name, generation, user-managed fields, and system-managed fields.
}

// Defines a device group specification containing the basic attributes and type information.
message DeviceGroupSpec {
    string external_id  = 1;  // An external identifier for integration with third-party systems or legacy identifiers.
    bool is_scada_group = 2;  // Indicates whether this is a SCADA group used for supervisory control and data acquisition systems.
}

// Defines a partial representation of a device group status.
message StreamDeviceGroupStatus {
    map<string, DeviceGroupStatusDevice> devices = 4;  // The list of devices that are part of the group. The key represents the device identifier, the value contains additional information.
}

// Defines the status of a device within a device group.
message DeviceGroupStatusDevice {
    string driver_type = 1;  // The driver type.
}

// Defines a specification for adding or updating communication units linked to a device .
message SetDeviceCommunicationUnitsRequest {
    string device_id                                     = 1;  // The unique device identifier.
    repeated DeviceCommunicationUnit communication_units = 2;  // The list of linked communication units.
}

// Defines a list of communication units linked to a device.
message ListOfDeviceCommunicationUnit {
    repeated DeviceCommunicationUnit items = 1;  // The list of linked communication units.
    int32 total_count                      = 2;  // The total number of items in the list .
}

// Defines a specification for adding devices to a device groups.
message AddDevicesToGroupRequest {
    string group_id           = 1;  // The unique device group identifier.
    repeated string device_id = 2;  // A list of device identifiers.
}

// Defines a specification for removing devices from a device group.
message RemoveDevicesFromGroupRequest {
    string group_id           = 1;  // The unique device group identifier.
    repeated string device_id = 2;  // A list of device identifiers.
}

// Defines a list of devices withing a device group.
message ListDeviceGroupDevicesRequest {
    string group_id                                     = 1;  // The unique device group identifier.
    io.clbs.openhes.models.common.ListSelector selector = 2;  // The listing criteria.
}

// Defines a specification for creating a new bulk.
message CreateBulkRequest {
    BulkSpec spec                  = 1;  // The bulk specification.
    common.MetadataFields metadata = 2;  // The metadata fields.
}

// Defines a list of bulks.
message ListOfBulk {
    repeated Bulk items = 1;  // The list of bulks.
    int32 total_count   = 2;  // The total number of items in the list.
}

// Defines a bulk operation model for executing actions across multiple devices concurrently.
// Bulks enable efficient mass operations such as data collection, firmware updates, or configuration changes
// across hundreds or thousands of devices. Each bulk creates individual jobs per device.
message Bulk {
    BulkSpec spec                  = 1;  // The bulk specification defining target devices and actions.
    BulkStatus status              = 2;  // The current status tracking job counts and completion state.
    common.MetadataFields metadata = 3;  // Metadata including id, name, generation, user-managed fields, and system-managed fields.
}

// Defines a bulk specification containing the configuration for a mass operation.
message BulkSpec {
    // @gqltype: UUID
    string correlation_id = 1;  // A correlation identifier for grouping related bulks across different driver types.
    oneof device {
        ListOfJobDeviceId devices = 2;  // An explicit list of device identifiers to target.
        string device_group_id    = 3;  // A device group identifier to target all devices in the group.
    }
    JobSettings settings          = 4;  // Execution settings including priority, retry logic, and timeout values.
    repeated JobActionSet actions = 5;  // The sequence of actions to execute on each device (e.g., read registers, update firmware).
    bool skip_data_processing     = 6;  // When true, collected data bypasses normal processing pipelines (useful for testing). Default is false.
}

// Defines the status of a bulk.
message BulkStatus {
    BulkStatusCode status                 = 1;  // The overall bulk status.
    int32 jobs_count                      = 2;  // The total number of jobs in the bulk.
    int32 jobs_finished                   = 3;  // The number of jobs that have finished.
    int32 jobs_successful                 = 4;  // The number of jobs that finished successfully.
    google.protobuf.Timestamp created_at  = 5;  // The timestamp when the bulk was created.
    google.protobuf.Timestamp started_at  = 6;  // The timestamp when the bulk started.
    google.protobuf.Timestamp finished_at = 7;  // The timestamp when the bulk finished.
}

// Defines the bulk job model.
message BulkJob {
    BulkJobSpec spec               = 1;  // The job specification.
    JobStatus status               = 2;  // The job status.
    common.MetadataFields metadata = 3;  // The metadata fields.
}

// Defines the specification of a bulk job.
message BulkJobSpec {
    JobDevice device = 1;  // The device information.
}

// Defines a specification for listing of jobs within a specified bulk.
message ListBulkJobsRequest {
    string bulk_id                                      = 1;  // The unique bulk identifier.
    io.clbs.openhes.models.common.ListSelector selector = 2;  // The listing criteria.
}

// Defines a list of jobs within a bulk.
message ListOfBulkJob {
    repeated BulkJob items = 1;  // The list of jobs.
    int32 total_count      = 2;  // The total number of items in the list.
}

// Defines a specification for creating a new proxy bulk.
message CreateProxyBulkRequest {
    ProxyBulkSpec spec             = 1;  // The proxy bulk specification.
    common.MetadataFields metadata = 2;  // The metadata fields.
}

// Defines a proxy bulk specification for operations forwarded from the DataProxy to the main API.
// Proxy bulks are used when data collection is initiated externally and needs to be tracked in the main system.
message ProxyBulkSpec {
    // @gqltype: UUID
    string correlation_id      = 1;  // A correlation identifier linking this proxy bulk to the originating bulk in the DataProxy.
    string driver_type         = 2;  // The driver type that will execute the jobs (e.g., "dlms", "mbus").
    ListOfJobDevice devices    = 3;  // The list of devices with their connection information for the proxy bulk.
    JobSettings settings       = 4;  // Execution settings including priority, retry logic, and timeout values.
    repeated JobAction actions = 5;  // The sequence of driver-specific actions to execute on each device.
}

// Defines a proxy bulk model.
message ProxyBulk {
    ProxyBulkSpec spec             = 1;  // The proxy bulk specification.
    BulkStatus status              = 2;  // The proxy bulk status.
    common.MetadataFields metadata = 3;  // The metadata fields.
}

// Defines a specification for creating or updating a modem pool.
message SetModemPoolRequest {
    reserved 2;
    ModemPoolSpec spec             = 1;  // The modem pool specification.
    common.MetadataFields metadata = 3;  // The metadata fields.
}

// Defines a list of modem pools.
message ListOfModemPool {
    repeated ModemPool items = 1;  // The list of modem pools.
    int32 total_count        = 2;  // The total number of items in the list.
}

// Defines a modem pool specification.
message ModemPoolSpec {
}

// Defines a modem pool status.
message ModemPoolStatus {
    repeated ModemInfo modems = 1;  // The list of modems in the pool.
}

// Defines a modem pool model.
message ModemPool {
    ModemPoolSpec spec             = 1;  // The modem pool specification.
    ModemPoolStatus status         = 2;  // The modem pool status.
    common.MetadataFields metadata = 3;  // The metadata fields.
}

// Defines a specification for creating or updating modems linked to a modem pool.
message SetModemRequest {
    string pool_id  = 1;  // The unique modem pool identifier. Required for update operation.
    ModemInfo modem = 2;  // The modem specification.
}

// Defines a specification for creating or updating a driver.
message SetDriver {
    reserved 2, 3;
    DriverSpec spec = 1;  // The driver specification.
}

// Defines a list of drivers.
message ListOfDriver {
    repeated Driver items = 1;  // The list of drivers.
    int32 total_count     = 2;  // The total number of items in the list.
}

// Defines a driver model.
message Driver {
    reserved 3;
    DriverSpec spec     = 1;  // The driver specification.
    DriverStatus status = 2;  // The driver status.
}

// Defines the driver specification.
message DriverSpec {
    // The driver version. The format is not defined. Typically matches the docker image tag or another user-readable version string.
    string version = 1;
    // The port on which the driver's gRPC listens.
    uint32 listening_port = 2;
    // The technical/internal ID of the driver.
    string driver_type = 3;
    // The maximum number of concurrent jobs the driver can handle. A value of `0` is not allowed. The maximum value should respect `typical_mem_usage` to avoid exceeding memory resources!
    int32 max_concurrent_jobs = 4;
    // The maximum cascade depth the driver can handle. Value `1` means that cascading jobs are not supported. Value `2` means one level of cascading is allowed, and so on.
    // Value `0` means that the driver can handle any number of cascading jobs.
    uint32 max_cascade_depth = 5;
    // The typical memory usage of the driver in `MB`.
    int32 typical_mem_usage = 6;
    // The connection and action templates.
    DriverTemplates templates = 7;
    // The display name of the driver. Must be in the following format: `<manufacturer> <device_type> [<device_type_version>]`.
    // Must respect upper/lower case.
    // Generic drivers, such as `cybros labs generic`, must be in the following format: `<driver_company_name> generic`.
    // @example: `Addax NP73E`, `cybros labs generic`, `Landis+Gyr S650 v2`
    string display_name = 8;
}

// Defines the driver status.
message DriverStatus {
    bool is_latest       = 1;  // Indicates whether this is the latest installed version of the driver in the system. Note that this does not necessarily mean it is the latest released version!
    bool update_finished = 2;  // Indicates whether the update from the previous version (if any) has finished.
}

// Defines a specification for creating a new variable.
message CreateVariableRequest {
    VariableSpec spec              = 1;  // The variable specification.
    common.MetadataFields metadata = 2;  // The metadata fields.
}

// Defines a list of variables.
message ListOfVariable {
    repeated Variable items = 1;  // The list of variables.
    int32 total_count       = 2;  // The total number of items in the list.
}

// Defines a variable model.
message Variable {
    reserved 2;
    VariableSpec spec              = 1;  // The variable specification.
    common.MetadataFields metadata = 3;  // The metadata fields.
}

// Defines a variable specification.
message VariableSpec {
    repeated string register_id    = 1;  // The list of device configuration register identifiers.
    common.FieldDataType data_type = 2;  // The data type of the variable. Only registers of the same data type can be linked to the variable.
    bool exclude_data_from         = 3;  // Indicates whether the returned data for this variabe should exclude values at `from` timestamp. If set to `true`, the returned device data returned for this variable dos not include values at `from` timestamp. Default value is `false`.
}

// Defines a specification for adding registers to a variable.
message AddRegisterToVariableRequest {
    // The unique variable identifier.
    // @gqltype: UUID
    string variable_id          = 1;
    // A list of register identifiers.
    // @gqltype: UUID
    repeated string register_id = 2;
}

// Defines a specification for removing registers from a variable.
message RemoveRegisterFromVariableRequest {
    // The unique identifier of the variable.
    // @gqltype: UUID
    string variable_id          = 1;
    // A list of register identifiers.
    // @gqltype: UUID
    repeated string register_id = 2;
}

// Defines the specification for creating a new device configuration register.
message CreateDeviceConfigurationRegisterRequest {
    DeviceConfigurationRegisterSpec spec = 1;  // The register specification.
    common.MetadataFields metadata       = 2;  // The metadata fields.
}

// Defines a lost of device configuration registers.
message ListOfDeviceConfigurationRegister {
    repeated DeviceConfigurationRegister items = 1;  // The list of registers.
    int32 total_count                          = 2;  // The total number of items in the list.
}

// Defines a device configuration register specification.
message DeviceConfigurationRegister {
    reserved 2;
    DeviceConfigurationRegisterSpec spec = 1;  // The register specification.
    common.MetadataFields metadata       = 3;  // The metadata fields.
}

// Defines a map of device configuration registers.
message DeviceConfigurationRegisterMap {
    repeated DeviceConfigurationRegisterMapRecord items = 1;  // A list of device configuration registers records to form a map.
}

// Defines a single record in the device configuration register map.
message DeviceConfigurationRegisterMapRecord {
    int64 register_id             = 1;  // The unique register identifier.
    // The public register identifier.
    // @gqltype: UUID
    string public_register_id     = 2;
    // The register name.
    // @example: "L+G E570 Active Energy Import (Total)"
    // @example: "L+G E570 Active Energy Export (Total)"
    string register_name          = 3;
    // Variable names, if the register is assigned to any.
    // @example: ["A+", "Energy Import"]
    repeated string variable_name = 4;
}

// Defines a specification for creating a new device configuration template.
message CreateDeviceConfigurationTemplateRequest {
    DeviceConfigurationTemplateSpec spec = 1;  // The device configuration template specification.
    common.MetadataFields metadata       = 2;  // The metadata fields.
}

// Defines a list of device configuration templates.
message ListOfDeviceConfigurationTemplate {
    repeated DeviceConfigurationTemplate items = 1;  // The list of device configuration templates.
    int32 total_count                          = 2;  // The total number of items in the list.
}

// Defines a device configuration template model.
message DeviceConfigurationTemplate {
    reserved 2;
    DeviceConfigurationTemplateSpec spec = 1;  // The device configuration template specification.
    common.MetadataFields metadata       = 3;  // The metadata fields.
}

// Defines a device configuration template specification.
message DeviceConfigurationTemplateSpec {
    // The driver type.
    // @example: "METERCONTROL_ST402D_DLMS"
    // @example: "LANDISGYR_E650_DLMS_SN"
    string driver_type                = 1;
    // A list of device configuration register identifiers used by standard readout.
    // @gqltype: UUID
    repeated string register_id       = 2;
    // A list of device configuration register identifiers used by SCADA readout.
    // @gqltype: UUID
    repeated string scada_register_id = 3;
}

// Defines the specification for adding device configuration registers to device configuration templates.
message AddDeviceConfigurationRegisterToDeviceConfigurationTemplateRequest {
    // The unique device configuration template identifier.
    // @gqltype: UUID
    string dct_id                     = 1;
    // A list of device configuration register identifiers used by standard readout.
    // @gqltype: UUID
    repeated string register_id       = 2;
    // A list of device configuration register identifiers used by SCADA readout.
    // @gqltype: UUID
    repeated string scada_register_id = 3;
}

// Defines the specification for removing device configuration registers to device configuration templates.
message RemoveDeviceConfigurationRegisterFromDeviceConfigurationTemplateRequest {
    // The unique device configuration template identifier.
    // @gqltype: UUID
    string dct_id                     = 1;
    // A list of device configuration register identifiers used by standard readout.
    // @gqltype: UUID
    repeated string register_id       = 2;
    // A list of device configuration register identifiers used by SCADA readout.
    // @gqltype: UUID
    repeated string scada_register_id = 3;
}

// Defines a specification for retrieving device data.
message GetDeviceDataRequest {
    google.protobuf.Timestamp range_start       = 1;  // The start timestamp of the requested data. The exclusivness/inclusiveness of the timestamp is defined in a variable.
    google.protobuf.Timestamp range_end         = 2;  // The end timestamp of the data. The timestamp is inclusive.
    repeated GetDeviceDataSeriesSelector series = 3;  // One or more selectors identifying devices and variables for which data is requested.
    int64 filter_include_status                 = 4;  // The status bit filter. Only values with these status bits will be included in the response.
    int64 filter_exclude_status                 = 5;  // The status bit filter. Values with these status bits will not be included in the response.
    google.protobuf.Timestamp snapshot          = 6;  // If set, returns a snapshot of stoered data from the given point in time.
}

// Defines a selector for identifying device and variable pairs.
message GetDeviceDataSeriesSelector {
    // The unique device identifier.
    // @gqltype: UUID
    string device_id   = 1;
    // The unique variable identifier.
    // @gqltype: UUID
    string variable_id = 2;
}

// Defines a list of data items.
message DeviceData {
    repeated DeviceDeviceData devices = 1;  // A list of device data items.
}

// Defines data items for a specific device.
message DeviceDeviceData {
    // The unique device identifier.
    // @gqltype: UUID
    string device_id                 = 1;
    repeated VariableDeviceData data = 2;  // A list of variable data items.
}

// Defines data for a specific variable within a device.
message VariableDeviceData {
    // The unique variable identifier.
    // @gqltype: UUID
    string variable_id                            = 1;
    repeated google.protobuf.Timestamp timestamps = 2;  // A list of timestamps for the variable data.
    // A list of units for the variable data.
    // @example: ["kWh", "kWh", "kWh"]
    // @example: ["V", "V", "V"]
    repeated string units                         = 3;
    repeated MeasuredValue values                 = 4;  // A list of measured values for the variable data.
}

// Defines device data information model.
message DeviceDataInfo {
    reserved 3;
    DeviceDataInfoSpec spec     = 1;  // The device data info specification.
    DeviceDataInfoStatus status = 2;  // The device data info status.
}

// Defines the device data information specification.
message DeviceDataInfoSpec {
    // The unique device identifier.
    // @gqltype: UUID
    string device_id   = 1;
    // The unique register identifier.
    // @gqltype: UUID
    string register_id = 2;
}

// Defines the device data information status.
message DeviceDataInfoStatus {
    // The register name.
    // @example: "L+G E570 Active Energy Import (Total)"
    // @example: "L+G E570 Voltage L1"
    string register_name                    = 1;
    // The period of the regular profile values, if applicable (in minutes).
    // @example: 15
    // @example: 60
    int32 period                            = 2;
    google.protobuf.Timestamp last_value_at = 3;  // The timestamp of the last stored value.
}

// Defines a list of device data information items.
message ListOfDeviceDataInfo {
    repeated DeviceDataInfo items = 1;  // The list of device data info items.
    int32 total_count             = 2;  // The total number of items.
}

// Defines a specification for retrieving device events.
message GetDeviceEventsRequest {
    google.protobuf.Timestamp range_start = 1;  // The start timestamp of the device events selection. It is inclusive.
    google.protobuf.Timestamp range_end   = 2;  // The end timestamp of the device events selection. It is inclusive.
    // The unique identifier of the device.
    // @gqltype: UUID
    string device_id                      = 3;
}

// Defines a specification for retrieving device bulks from a specified time range.
message GetDeviceBulksRequest {
    google.protobuf.Timestamp range_start = 1;  // The start timestamp of the bulks selection. It is inclusive.
    google.protobuf.Timestamp range_end   = 2;  // The end timestamp of the bulks selection. It is inclusive.
    // The unique identifier of the device.
    // @gqltype: UUID
    string device_id                      = 3;
}

// Defines a list of device bulks.
message DeviceBulks {
    repeated Bulk bulks = 1;  // The list of bulks.
}

// Defines a specification for creating a new time-of-use table.
message CreateTimeOfUseTableRequest {
    timeofuse.TimeOfUseTableSpec spec = 1;  // The time-of-use table specification.
    common.MetadataFields metadata    = 2;  // The metadata fields.
}

// Defines a list of time-of-use tables.
message ListOfTimeOfUseTable {
    repeated TimeOfUseTable items = 1;  // The list of time-of-use tables.
    int32 total_count             = 2;  // The total number of items in the list.
}

// Defines a specification for a time-of-use table.
message TimeOfUseTable {
    reserved 2;
    timeofuse.TimeOfUseTableSpec spec = 1;  // The time-of-use table specification.
    common.MetadataFields metadata    = 3;  // The metadata fields.
}

// Defines a specification for creating a new firmware image.
message CreateFirmwareImageRequest {
    FirmwareImageSpec spec         = 1;  // The firmware image specification.
    common.MetadataFields metadata = 2;  // The metadata fields.
}

// Defines a list of firmware images.
message ListOfFirmwareImage {
    repeated FirmwareImage items = 1;  // The list of firmware images.
    int32 total_count            = 2;  // The total number of items in the list.
}

// Defines a specification for a firmware image object.
message FirmwareImage {
    FirmwareImageSpec spec         = 1;  // The firmware image specification.
    common.MetadataFields metadata = 2;  // The metadata fields.
}

// Defines a firmware image specification.
message FirmwareImageSpec {
    // The driver type.
    // @example: "METERCONTROL_ST402D_DLMS"
    // @example: "LANDISGYR_E650_DLMS_SN"
    string driver_type                        = 1;
    // The firmware version.
    // @example: "1.2.3"
    // @example: "v2.0.1"
    string version                            = 2;
    repeated FirmwareImageFile content        = 3;  // The list of firmware image files.
    // The firmware image description.
    // @example: "Firmware update for ST402D meters - bug fixes and performance improvements"
    string description                        = 4;
    map<string, common.FieldValue> attributes = 5;  // The firmware attributes, depending on the driver type.
}

// Defines a file within a firmware image.
message FirmwareImageFile {
    // The firmware image file name.
    // @example: "firmware.bin"
    // @example: "bootloader.hex"
    string file_name = 2;
    int32 file_size  = 3;  // The size of the firmware image file in bytes.
}

// Defines a request for retrieving a block of firmware image data.
message GetFirmwareImageBlockRequest {
    // The unique firmware image identifier.
    // @gqltype: UUID
    string firmware_image_id = 1;
    // The firmware image file name.
    // @example: "firmware.bin"
    string file_name         = 2;
    int32 block_size         = 3;  // The size of the block to retrieve in bytes.
    int32 block_index        = 4;  // The index of the block to retrieve (0-based).
}

// Defines a request for retrieving a block of firmware image data for streamed upload.
message StreamUploadFirmwareImageRequest {
    // The unique firmware image identifier.
    // @gqltype: UUID
    string firmware_image_id = 1;
    // The firmware image file name.
    // @example: "firmware.bin"
    string file_name         = 2;
    int32 block_size         = 3;  // The size of the block to retrieve in bytes.
    int32 block_index        = 4;  // The index of the block to retrieve (0-based). All blocks must be send in order.
    bool last_block          = 5;  // Indicates whether this is the last block in the stream.
    bytes block_data         = 6;  // The data block of firmware image.
}

// Defines a block of firmware image data.
message FirmwareImageBlock {
    bytes block_data = 1;  // The data block of firmware image.
    int32 file_size  = 2;  // The total size of the firmware image in bytes.
}

// Defines a request for streaming download of a firmware image file.
message StreamDownloadFirmwareImageFileRequest {
    // The unique firmware image identifier.
    // @gqltype: UUID
    string firmware_image_id = 1;
    // The firmware image file name.
    // @example: "firmware.bin"
    string file_name         = 2;
}